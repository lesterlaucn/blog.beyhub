{"meta":{"title":"采菊东篱","subtitle":"采菊东篱下，悠然见南山","description":"","author":"刘远程 Lester","url":"https://blog.beyhub.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"21/08/2021","updated":"21/08/2021","comments":false,"path":"/404.html","permalink":"https://blog.beyhub.com/404.html","excerpt":"","text":""},{"title":"archives","date":"20/08/2021","updated":"20/08/2021","comments":true,"path":"archives/index.html","permalink":"https://blog.beyhub.com/archives/index.html","excerpt":"","text":""},{"title":"关于本站","date":"21/08/2021","updated":"21/08/2021","comments":false,"path":"about/index.html","permalink":"https://blog.beyhub.com/about/index.html","excerpt":"","text":""},{"title":"文章分类","date":"21/08/2021","updated":"21/08/2021","comments":true,"path":"categories/index.html","permalink":"https://blog.beyhub.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"21/08/2021","updated":"21/08/2021","comments":false,"path":"links/index.html","permalink":"https://blog.beyhub.com/links/index.html","excerpt":"","text":""},{"title":"标签","date":"21/08/2021","updated":"21/08/2021","comments":true,"path":"tags/index.html","permalink":"https://blog.beyhub.com/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"23/08/2021","updated":"23/08/2021","comments":false,"path":"repository/index.html","permalink":"https://blog.beyhub.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"从ReentrantLock的实现看AQS的原理","path":"post/从reentrantlock的实现看aqs的原理/","text":"Java中的大部分同步类（Lock、Semaphore、ReentrantLock等）都是基于AbstractQueuedSynchronizer（简称为AQS）实现的。AQS是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架。本文会从应用层逐渐深入到原理层，并通过ReentrantLock的基本特性和ReentrantLock与AQS的关联，来深入解读AQS相关独占锁的知识点，同时采取问答的模式来帮助大家理解AQS。由于篇幅原因，本篇文章主要阐述AQS中独占锁的逻辑和Sync Queue，不讲述包含共享锁和Condition Queue的部分（本篇文章核心为AQS原理剖析，只是简单介绍了ReentrantLock，感兴趣同学可以阅读一下ReentrantLock的源码）。 下面列出本篇文章的大纲和思路，以便于大家更好地理解： 1 ReentrantLock# 1.1 ReentrantLock特性概览# ReentrantLock意思为可重入锁，指的是一个线程能够对一个临界资源重复加锁。为了帮助大家更好地理解ReentrantLock的特性，我们先将ReentrantLock跟常用的Synchronized进行比较，其特性如下（蓝色部分为本篇文章主要剖析的点）： 下面通过伪代码，进行更加直观的比较： 123456789101112131415161718192021synchronized (this) &#123;&#125;synchronized (object) &#123;&#125;public synchronized void test () &#123;&#125;for (int i = 0; i &lt; 100; i++) &#123;synchronized (this) &#123;&#125;&#125;public void test () throw Exception &#123;ReentrantLock lock = new ReentrantLock(true);lock.lock();try &#123;try &#123;if(lock.tryLock(100, TimeUnit.MILLISECONDS))&#123; &#125;&#125; finally &#123;lock.unlock()&#125;&#125; finally &#123;lock.unlock();&#125;&#125; 1.2 ReentrantLock与AQS的关联# 通过上文我们已经了解，ReentrantLock支持公平锁和非公平锁（关于公平锁和非公平锁的原理分析，可参考《不可不说的Java“锁”事》），并且ReentrantLock的底层就是由AQS来实现的。那么ReentrantLock是如何通过公平锁和非公平锁与AQS关联起来呢？ 我们着重从这两者的加锁过程来理解一下它们与AQS之间的关系（加锁过程中与AQS的关联比较明显，解锁流程后续会介绍）。 非公平锁源码中的加锁流程如下： 1234567891011static final class NonfairSync extends Sync &#123;...final void lock() &#123;if (compareAndSetState(0, 1))setExclusiveOwnerThread(Thread.currentThread());elseacquire(1);&#125; ...&#125; 这块代码的含义为： 若通过CAS设置变量State（同步状态）成功，也就是获取锁成功，则将当前线程设置为独占线程。 若通过CAS设置变量State（同步状态）失败，也就是获取锁失败，则进入Acquire方法进行后续处理。 第一步很好理解，但第二步获取锁失败后，后续的处理策略是怎么样的呢？这块可能会有以下思考： 某个线程获取锁失败的后续流程是什么呢？有以下两种可能： (1) 将当前线程获锁结果设置为失败，获取锁流程结束。这种设计会极大降低系统的并发度，并不满足我们实际的需求。所以就需要下面这种流程，也就是AQS框架的处理流程。 (2) 存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。 对于问题1的第二种情况，既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？ 处于排队等候机制中的线程，什么时候可以有机会获取锁呢？ 如果处于排队等候机制中的线程一直无法获取锁，还是需要一直等待吗，还是有别的策略来解决这一问题？ 带着非公平锁的这些问题，再看下公平锁源码中获锁的方式： 1234567static final class FairSync extends Sync &#123; ... final void lock() &#123;acquire(1);&#125; ...&#125; 看到这块代码，我们可能会存在这种疑问：Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？ 结合公平锁和非公平锁的加锁流程，虽然流程上有一定的不同，但是都调用了Acquire方法，而Acquire方法是FairSync和UnfairSync的父类AQS中的核心方法。 对于上边提到的问题，其实在ReentrantLock类源码中都无法解答，而这些问题的答案，都是位于Acquire方法所在的类AbstractQueuedSynchronizer中，也就是本文的核心——AQS。下面我们会对AQS以及ReentrantLock和AQS的关联做详细介绍（相关问题答案会在2.3.5小节中解答）。 2 AQS# 首先，我们通过下面的架构图来整体了解一下AQS框架： 上图中有颜色的为Method，无颜色的为Attribution。 总的来说，AQS框架共分为五层，自上而下由浅入深，从AQS对外暴露的API到底层基础数据。 当有自定义同步器接入时，只需重写第一层所需要的部分方法即可，不需要关注底层具体的实现流程。当自定义同步器进行加锁或者解锁操作时，先经过第一层的API进入AQS内部方法，然后经过第二层进行锁的获取，接着对于获取锁失败的流程，进入第三层和第四层的等待队列处理，而这些处理方式均依赖于第五层的基础数据提供层。 下面我们会从整体到细节，从流程到方法逐一剖析AQS框架，主要分析过程如下： 2.1 原理概览# AQS核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。 CLH：Craig、Landin and Hagersten队列，是单向链表，AQS中的队列是CLH变体的虚拟双向队列（FIFO），AQS是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配。 主要原理图如下： AQS使用一个Volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。 2.1.1 AQS数据结构# 先来看下AQS中最基本的数据结构——Node，Node即为上面CLH变体队列中的节点。 解释一下几个方法和属性值的含义： 方法和属性值 含义 waitStatus 当前节点在队列中的状态 thread 表示处于该节点的线程 prev 前驱指针 predecessor 返回前驱节点，没有的话抛出npe nextWaiter 指向下一个处于CONDITION状态的节点（由于本篇文章不讲述Condition Queue队列，这个指针不多介绍） next 后继指针 线程两种锁的模式： 模式 含义 SHARED 表示线程以共享的模式等待锁 EXCLUSIVE 表示线程正在以独占的方式等待锁 waitStatus有下面几个枚举值： 枚举 含义 0 当一个Node被初始化的时候的默认值 CANCELLED 为1，表示线程获取锁的请求已经取消了 CONDITION 为-2，表示节点在等待队列中，节点线程等待唤醒 PROPAGATE 为-3，当前线程处在SHARED情况下，该字段才会使用 SIGNAL 为-1，表示线程已经准备好了，就等资源释放了 2.1.2 同步状态State# 在了解数据结构后，接下来了解一下AQS的同步状态——State。AQS中维护了一个名为state的字段，意为同步状态，是由Volatile修饰的，用于展示当前临界资源的获锁情况。 1private volatile int state; 下面提供了几个访问这个字段的方法： 方法名 描述 protected final int getState() 获取State的值 protected final void setState(int newState) 设置State的值 protected final boolean compareAndSetState(int expect, int update) 使用CAS方式更新State 这几个方法都是Final修饰的，说明子类中无法重写它们。我们可以通过修改State字段表示的同步状态来实现多线程的独占模式和共享模式（加锁过程）。 对于我们自定义的同步工具，需要自定义获取同步状态和释放状态的方式，也就是AQS架构图中的第一层：API层。 2.2 AQS重要方法与ReentrantLock的关联# 从架构图中可以得知，AQS提供了大量用于自定义同步器实现的Protected方法。自定义同步器实现的相关方法也只是为了通过修改State字段来实现多线程的独占模式或者共享模式。自定义同步器需要实现以下方法（ReentrantLock需要实现的方法如下，并不是全部）： 方法名 描述 protected boolean isHeldExclusively() 该线程是否正在独占资源。只有用到Condition才需要去实现它。 protected boolean tryAcquire(int arg) 独占方式。arg为获取锁的次数，尝试获取资源，成功则返回True，失败则返回False。 protected boolean tryRelease(int arg) 独占方式。arg为释放锁的次数，尝试释放资源，成功则返回True，失败则返回False。 protected int tryAcquireShared(int arg) 共享方式。arg为获取锁的次数，尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。 protected boolean tryReleaseShared(int arg) 共享方式。arg为释放锁的次数，尝试释放资源，如果释放后允许唤醒后续等待结点返回True，否则返回False。 一般来说，自定义同步器要么是独占方式，要么是共享方式，它们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。ReentrantLock是独占锁，所以实现了tryAcquire-tryRelease。 以非公平锁为例，这里主要阐述一下非公平锁与AQS之间方法的关联之处，具体每一处核心方法的作用会在文章后面详细进行阐述。 为了帮助大家理解ReentrantLock和AQS之间方法的交互过程，以非公平锁为例，我们将加锁和解锁的交互流程单独拎出来强调一下，以便于对后续内容的理解。 加锁： 通过ReentrantLock的加锁方法Lock进行加锁操作。 会调用到内部类Sync的Lock方法，由于Sync#lock是抽象方法，根据ReentrantLock初始化选择的公平锁和非公平锁，执行相关内部类的Lock方法，本质上都会执行AQS的Acquire方法。 AQS的Acquire方法会执行tryAcquire方法，但是由于tryAcquire需要自定义同步器实现，因此执行了ReentrantLock中的tryAcquire方法，由于ReentrantLock是通过公平锁和非公平锁内部类实现的tryAcquire方法，因此会根据锁类型不同，执行不同的tryAcquire。 tryAcquire是获取锁逻辑，获取失败后，会执行框架AQS的后续逻辑，跟ReentrantLock自定义同步器无关。 解锁： 通过ReentrantLock的解锁方法Unlock进行解锁。 Unlock会调用内部类Sync的Release方法，该方法继承于AQS。 Release中会调用tryRelease方法，tryRelease需要自定义同步器实现，tryRelease只在ReentrantLock中的Sync实现，因此可以看出，释放锁的过程，并不区分是否为公平锁。 释放成功后，所有处理由AQS框架完成，与自定义同步器无关。 通过上面的描述，大概可以总结出ReentrantLock加锁解锁时API层核心方法的映射关系。 2.3 通过ReentrantLock理解AQS# ReentrantLock中公平锁和非公平锁在底层是相同的，这里以非公平锁为例进行分析。 在非公平锁中，有一段这样的代码： 12345678910static final class NonfairSync extends Sync &#123;...final void lock() &#123;if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread());else acquire(1);&#125; ...&#125; 看一下这个Acquire是怎么写的： 1234public final void acquire(int arg) &#123;if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; 再看一下tryAcquire方法： 123protected boolean tryAcquire(int arg) &#123; throw new UnsupportedOperationException();&#125; 可以看出，这里只是AQS的简单实现，具体获取锁的实现方法是由各自的公平锁和非公平锁单独实现的（以ReentrantLock为例）。如果该方法返回了True，则说明当前线程获取锁成功，就不用往后执行了；如果获取失败，就需要加入到等待队列中。下面会详细解释线程是何时以及怎样被加入进等待队列中的。 2.3.1 线程加入等待队列# 2.3.1.1 加入队列的时机# 当执行Acquire(1)时，会通过tryAcquire获取锁。在这种情况下，如果获取锁失败，就会调用addWaiter加入到等待队列中去。 2.3.1.2 如何加入队列# 获取锁失败后，会执行addWaiter(Node.EXCLUSIVE)加入等待队列，具体实现方法如下： 12345678910111213141516private Node addWaiter(Node mode) &#123;Node node = new Node(Thread.currentThread(), mode);Node pred = tail;if (pred != null) &#123; node.prev = pred;if (compareAndSetTail(pred, node)) &#123; pred.next = node;return node;&#125;&#125;enq(node); return node;&#125;private final boolean compareAndSetTail(Node expect, Node update) &#123; return unsafe.compareAndSwapObject(this, tailOffset, expect, update);&#125; 主要的流程如下： 通过当前的线程和锁模式新建一个节点。 Pred指针指向尾节点Tail。 将New中Node的Prev指针指向Pred。 通过compareAndSetTail方法，完成尾节点的设置。这个方法主要是对tailOffset和Expect进行比较，如果tailOffset的Node和Expect的Node地址是相同的，那么设置Tail的值为Update的值。 1234567891011static &#123;try &#123; stateOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(&quot;state&quot;)); headOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(&quot;head&quot;)); tailOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(&quot;tail&quot;)); waitStatusOffset = unsafe.objectFieldOffset(Node.class.getDeclaredField(&quot;waitStatus&quot;)); nextOffset = unsafe.objectFieldOffset(Node.class.getDeclaredField(&quot;next&quot;));&#125; catch (Exception ex) &#123; throw new Error(ex); &#125;&#125; 从AQS的静态代码块可以看出，都是获取一个对象的属性相对于该对象在内存当中的偏移量，这样我们就可以根据这个偏移量在对象内存当中找到这个属性。tailOffset指的是tail对应的偏移量，所以这个时候会将new出来的Node置为当前队列的尾节点。同时，由于是双向链表，也需要将前一个节点指向尾节点。 如果Pred指针是Null（说明等待队列中没有元素），或者当前Pred指针和Tail指向的位置不同（说明被别的线程已经修改），就需要看一下Enq的方法。 123456789101112131415private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125; 如果没有被初始化，需要进行初始化一个头结点出来。但请注意，初始化的头结点并不是当前线程节点，而是调用了无参构造函数的节点。如果经历了初始化或者并发导致队列中有元素，则与之前的方法相同。其实，addWaiter就是一个在双端链表添加尾节点的操作，需要注意的是，双端链表的头结点是一个无参构造函数的头结点。 总结一下，线程获取锁的时候，过程大体如下： 当没有线程获取到锁时，线程1获取锁成功。 线程2申请锁，但是锁被线程1占有。 如果再有线程要获取锁，依次在队列中往后排队即可。 回到上边的代码，hasQueuedPredecessors是公平锁加锁时判断等待队列中是否存在有效节点的方法。如果返回False，说明当前线程可以争取共享资源；如果返回True，说明队列中存在有效节点，当前线程必须加入到等待队列中。 123456public final boolean hasQueuedPredecessors() &#123; Node t = tail; Node h = head; Node s; return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());&#125; 看到这里，我们理解一下h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());为什么要判断的头结点的下一个节点？第一个节点储存的数据是什么？ 双向链表中，第一个节点为虚节点，其实并不存储任何信息，只是占位。真正的第一个有数据的节点，是在第二个节点开始的。当h != t时： 如果(s = h.next) == null，等待队列正在有线程进行初始化，但只是进行到了Tail指向Head，没有将Head指向Tail，此时队列中有元素，需要返回True（这块具体见下边代码分析）。 如果(s = h.next) != null，说明此时队列中至少有一个有效节点。如果此时s.thread == Thread.currentThread()，说明等待队列的第一个有效节点中的线程与当前线程相同，那么当前线程是可以获取资源的；如果s.thread != Thread.currentThread()，说明等待队列的第一个有效节点线程与当前线程不同，当前线程必须加入进等待队列。 12345678910if (t == null) &#123; if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125;&#125; 节点入队不是原子操作，所以会出现短暂的head != tail，此时Tail指向最后一个节点，而且Tail指向Head。如果Head没有指向Tail（可见5、6、7行），这种情况下也需要将相关线程加入队列中。所以这块代码是为了解决极端情况下的并发问题。 2.3.1.3 等待队列中线程出队列时机# 回到最初的源码： 1234public final void acquire(int arg) &#123;if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; 上文解释了addWaiter方法，这个方法其实就是把对应的线程以Node的数据结构形式加入到双端队列里，返回的是一个包含该线程的Node。而这个Node会作为参数，进入到acquireQueued方法中。acquireQueued方法可以对排队中的线程进行“获锁”操作。 总的来说，一个线程获取锁失败了，被放入等待队列，acquireQueued会把放入队列中的线程不断去获取锁，直到获取成功或者不再需要获取（中断）。 下面我们从“何时出队列？”和“如何出队列？”两个方向来分析一下acquireQueued源码： 123456789101112131415161718192021final boolean acquireQueued(final Node node, int arg) &#123;boolean failed = true;try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125;&#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 注：setHead方法是把当前节点置为虚节点，但并没有修改waitStatus，因为它是一直需要用的数据。 123456789101112131415161718192021private void setHead(Node node) &#123; head = node; node.thread = null; node.prev = null;&#125;private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; int ws = pred.waitStatus; if (ws == Node.SIGNAL) return true; if (ws &gt; 0) &#123; do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false;&#125; parkAndCheckInterrupt主要用于挂起当前线程，阻塞调用栈，返回当前线程的中断状态。 1234private final boolean parkAndCheckInterrupt() &#123; LockSupport.park(this); return Thread.interrupted();&#125; 上述方法的流程图如下： 从上图可以看出，跳出当前循环的条件是当“前置节点是头结点，且当前线程获取锁成功”。为了防止因死循环导致CPU资源被浪费，我们会判断前置节点的状态来决定是否要将当前线程挂起，具体挂起流程用流程图表示如下（shouldParkAfterFailedAcquire流程）： 从队列中释放节点的疑虑打消了，那么又有新问题了： shouldParkAfterFailedAcquire中取消节点是怎么生成的呢？什么时候会把一个节点的waitStatus设置为-1？ 是在什么时间释放节点通知到被挂起的线程呢？ 2.3.2 CANCELLED状态节点生成# acquireQueued方法中的Finally代码： 1234567891011121314151617final boolean acquireQueued(final Node node, int arg) &#123;boolean failed = true;try &#123; ... for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; ... failed = false; ... &#125; ...&#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 通过cancelAcquire方法，将Node的状态标记为CANCELLED。接下来，我们逐行来分析这个方法的原理： 1234567891011121314151617181920212223private void cancelAcquire(Node node) &#123; if (node == null) return; node.thread = null; Node pred = node.prev; while (pred.waitStatus &gt; 0) node.prev = pred = pred.prev; Node predNext = pred.next; node.waitStatus = Node.CANCELLED; if (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123; compareAndSetNext(pred, predNext, null); &#125; else &#123; int ws; if (pred != head &amp;&amp; ((ws = pred.waitStatus) == Node.SIGNAL || (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; pred.thread != null) &#123; Node next = node.next; if (next != null &amp;&amp; next.waitStatus &lt;= 0) compareAndSetNext(pred, predNext, next); &#125; else &#123; unparkSuccessor(node); &#125; node.next = node; &#125;&#125; 当前的流程： 获取当前节点的前驱节点，如果前驱节点的状态是CANCELLED，那就一直往前遍历，找到第一个waitStatus &lt;= 0的节点，将找到的Pred节点和当前Node关联，将当前Node设置为CANCELLED。 根据当前节点的位置，考虑以下三种情况： (1) 当前节点是尾节点。 (2) 当前节点是Head的后继节点。 (3) 当前节点不是Head的后继节点，也不是尾节点。 根据上述第二条，我们来分析每一种情况的流程。 当前节点是尾节点。 当前节点是Head的后继节点。 当前节点不是Head的后继节点，也不是尾节点。 通过上面的流程，我们对于CANCELLED节点状态的产生和变化已经有了大致的了解，但是为什么所有的变化都是对Next指针进行了操作，而没有对Prev指针进行操作呢？什么情况下会对Prev指针进行操作？ 执行cancelAcquire的时候，当前节点的前置节点可能已经从队列中出去了（已经执行过Try代码块中的shouldParkAfterFailedAcquire方法了），如果此时修改Prev指针，有可能会导致Prev指向另一个已经移除队列的Node，因此这块变化Prev指针不安全。 shouldParkAfterFailedAcquire方法中，会执行下面的代码，其实就是在处理Prev指针。shouldParkAfterFailedAcquire是获取锁失败的情况下才会执行，进入该方法后，说明共享资源已被获取，当前节点之前的节点都不会出现变化，因此这个时候变更Prev指针比较安全。 123do &#123;node.prev = pred = pred.prev;&#125; while (pred.waitStatus &gt; 0); 2.3.3 如何解锁# 我们已经剖析了加锁过程中的基本流程，接下来再对解锁的基本流程进行分析。由于ReentrantLock在解锁的时候，并不区分公平锁和非公平锁，所以我们直接看解锁的源码： 123public void unlock() &#123; sync.release(1);&#125; 可以看到，本质释放锁的地方，是通过框架来完成的。 123456789public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false;&#125; 在ReentrantLock里面的公平锁和非公平锁的父类Sync定义了可重入锁的释放锁机制。 123456789101112131415protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; setState(c); return free;&#125; 我们来解释下述源码： 12345678910public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false;&#125; 这里的判断条件为什么是h != null &amp;&amp; h.waitStatus != 0？ h == null Head还没初始化。初始情况下，head == null，第一个节点入队，Head会被初始化一个虚拟节点。所以说，这里如果还没来得及入队，就会出现head == null 的情况。 h != null &amp;&amp; waitStatus == 0 表明后继节点对应的线程仍在运行中，不需要唤醒。 h != null &amp;&amp; waitStatus &lt; 0 表明后继节点可能被阻塞了，需要唤醒。 再看一下unparkSuccessor方法： 123456789101112131415private void unparkSuccessor(Node node) &#123; int ws = node.waitStatus; if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); Node s = node.next; if (s == null || s.waitStatus &gt; 0) &#123; s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t;&#125;if (s != null) LockSupport.unpark(s.thread);&#125; 为什么要从后往前找第一个非Cancelled的节点呢？原因如下。 之前的addWaiter方法： 12345678910111213private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode); Node pred = tail; if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; enq(node); return node;&#125; 我们从这里可以看到，节点入队并不是原子操作，也就是说，node.prev = pred; compareAndSetTail(pred, node) 这两个地方可以看作Tail入队的原子操作，但是此时pred.next = node;还没执行，如果这个时候执行了unparkSuccessor方法，就没办法从前往后找了，所以需要从后往前找。还有一点原因，在产生CANCELLED状态节点的时候，先断开的是Next指针，Prev指针并未断开，因此也是必须要从后往前遍历才能够遍历完全部的Node。 综上所述，如果是从前往后找，由于极端情况下入队的非原子操作和CANCELLED节点产生过程中断开Next指针的操作，可能会导致无法遍历所有的节点。所以，唤醒对应的线程后，对应的线程就会继续往下执行。继续执行acquireQueued方法以后，中断如何处理？ 2.3.4 中断恢复后的执行流程# 唤醒后，会执行return Thread.interrupted();，这个函数返回的是当前执行线程的中断状态，并清除。 1234private final boolean parkAndCheckInterrupt() &#123; LockSupport.park(this); return Thread.interrupted();&#125; 再回到acquireQueued代码，当parkAndCheckInterrupt返回True或者False的时候，interrupted的值不同，但都会执行下次循环。如果这个时候获取锁成功，就会把当前interrupted返回。 1234567891011121314151617181920final boolean acquireQueued(final Node node, int arg) &#123;boolean failed = true;try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125;&#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 如果acquireQueued为True，就会执行selfInterrupt方法。 123static void selfInterrupt() &#123;Thread.currentThread().interrupt();&#125; 该方法其实是为了中断线程。但为什么获取了锁以后还要中断线程呢？这部分属于Java提供的协作式中断知识内容，感兴趣同学可以查阅一下。这里简单介绍一下： 当中断线程被唤醒时，并不知道被唤醒的原因，可能是当前线程在等待中被中断，也可能是释放了锁以后被唤醒。因此我们通过Thread.interrupted()方法检查中断标记（该方法返回了当前线程的中断状态，并将当前线程的中断标识设置为False），并记录下来，如果发现该线程被中断过，就再中断一次。 线程在等待资源的过程中被唤醒，唤醒后还是会不断地去尝试获取锁，直到抢到锁为止。也就是说，在整个流程中，并不响应中断，只是记录中断记录。最后抢到锁返回了，那么如果被中断过的话，就需要补充一次中断。 这里的处理方式主要是运用线程池中基本运作单元Worder中的runWorker，通过Thread.interrupted()进行额外的判断处理，感兴趣的同学可以看下ThreadPoolExecutor源码。 2.3.5 小结# 我们在1.3小节中提出了一些问题，现在来回答一下。 Q：某个线程获取锁失败的后续流程是什么呢？ A：存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。 Q：既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？ A：是CLH变体的FIFO双端队列。 Q：处于排队等候机制中的线程，什么时候可以有机会获取锁呢？ A：可以详细看下2.3.1.3小节。 Q：如果处于排队等候机制中的线程一直无法获取锁，需要一直等待么？还是有别的策略来解决这一问题？ A：线程所在节点的状态会变成取消状态，取消状态的节点会从队列中释放，具体可见2.3.2小节。 Q：Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？ A：AQS的Acquire会调用tryAcquire方法，tryAcquire由各个自定义同步器实现，通过tryAcquire完成加锁过程。 3 AQS应用# 3.1 ReentrantLock的可重入应用# ReentrantLock的可重入性是AQS很好的应用之一，在了解完上述知识点以后，我们很容易得知ReentrantLock实现可重入的方法。在ReentrantLock里面，不管是公平锁还是非公平锁，都有一段逻辑。 公平锁： 12345678910111213if (c == 0) &#123; if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125;&#125;else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true;&#125; 非公平锁： 12345678910111213if (c == 0) &#123; if (compareAndSetState(0, acquires))&#123; setExclusiveOwnerThread(current); return true; &#125;&#125;else if (current == getExclusiveOwnerThread()) &#123;int nextc = c + acquires;if (nextc &lt; 0) t hrow new Error(&quot;Maximum lock count exceeded&quot;);setState(nextc);return true;&#125; 从上面这两段都可以看到，有一个同步状态State来控制整体可重入的情况。State是Volatile修饰的，用于保证一定的可见性和有序性。 1private volatile int state; 接下来看State这个字段主要的过程： State初始化的时候为0，表示没有任何线程持有锁。 当有线程持有该锁时，值就会在原来的基础上+1，同一个线程多次获得锁是，就会多次+1，这里就是可重入的概念。 解锁也是对这个字段-1，一直到0，此线程对锁释放。 3.2 JUC中的应用场景# 除了上边ReentrantLock的可重入性的应用，AQS作为并发编程的框架，为很多其他同步工具提供了良好的解决方案。下面列出了JUC中的几种同步工具，大体介绍一下AQS的应用场景： 同步工具 同步工具与AQS的关联 ReentrantLock 使用AQS保存锁重复持有的次数。当一个线程获取锁时，ReentrantLock记录当前获得锁的线程标识，用于检测是否重复获取，以及错误线程试图解锁操作时异常情况的处理。 Semaphore 使用AQS同步状态来保存信号量的当前计数。tryRelease会增加计数，acquireShared会减少计数。 CountDownLatch 使用AQS同步状态来表示计数。计数为0时，所有的Acquire操作（CountDownLatch的await方法）才可以通过。 ReentrantReadWriteLock 使用AQS同步状态中的16位保存写锁持有的次数，剩下的16位用于保存读锁的持有次数。 ThreadPoolExecutor Worker利用AQS同步状态实现对独占线程变量的设置（tryAcquire和tryRelease）。 3.3 自定义同步工具# 了解AQS基本原理以后，按照上面所说的AQS知识点，自己实现一个同步工具。 123456789101112131415161718192021222324public class LeeLock &#123; private static class Sync extends AbstractQueuedSynchronizer &#123; @Override protected boolean tryAcquire (int arg) &#123; return compareAndSetState(0, 1); &#125; @Override protected boolean tryRelease (int arg) &#123; setState(0); return true; &#125; @Override protected boolean isHeldExclusively () &#123; return getState() == 1; &#125; &#125; private Sync sync = new Sync(); public void lock () &#123; sync.acquire(1); &#125; public void unlock () &#123; sync.release(1); &#125;&#125; 通过我们自己定义的Lock完成一定的同步功能。 12345678910111213141516171819202122232425262728293031public class LeeMain &#123; static int count = 0; static LeeLock leeLock = new LeeLock(); public static void main (String[] args) throws InterruptedException &#123; Runnable runnable = new Runnable() &#123; @Override public void run () &#123; try &#123; leeLock.lock(); for (int i = 0; i &lt; 10000; i++) &#123; count++; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; leeLock.unlock(); &#125; &#125; &#125;; Thread thread1 = new Thread(runnable); Thread thread2 = new Thread(runnable); thread1.start(); thread2.start(); thread1.join(); thread2.join(); System.out.println(count); &#125;&#125; 上述代码每次运行结果都会是20000。通过简单的几行代码就能实现同步功能，这就是AQS的强大之处。 总结# 我们日常开发中使用并发的场景太多，但是对并发内部的基本框架原理了解的人却不多。由于篇幅原因，本文仅介绍了可重入锁ReentrantLock的原理和AQS原理，希望能够成为大家了解AQS和ReentrantLock等同步器的“敲门砖”。 参考资料# Lea D. The java. util. concurrent synchronizer framework[J]. Science of Computer Programming, 2005, 58(3): 293-309. 《Java并发编程实战》 不可不说的Java“锁”事 一张图读懂公平锁与非公平锁 公平锁和非公平锁的区别","content":"<p>Java中的大部分同步类（Lock、Semaphore、ReentrantLock等）都是基于AbstractQueuedSynchronizer（简称为AQS）实现的。AQS是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架。本文会从应用层逐渐深入到原理层，并通过ReentrantLock的基本特性和ReentrantLock与AQS的关联，来深入解读AQS相关独占锁的知识点，同时采取问答的模式来帮助大家理解AQS。由于篇幅原因，本篇文章主要阐述AQS中独占锁的逻辑和Sync Queue，不讲述包含共享锁和Condition Queue的部分（本篇文章核心为AQS原理剖析，只是简单介绍了ReentrantLock，感兴趣同学可以阅读一下ReentrantLock的源码）。</p>\n<span id=\"more\"></span>\n<p>下面列出本篇文章的大纲和思路，以便于大家更好地理解：<br>\n<img src=\"https://p1.meituan.net/travelcube/9d182d944e0889c304ef529ba50a4fcd205214.png\" alt></p>\n<h2><span id=\"1-reentrantlock\">1 ReentrantLock</span><a href=\"#1-reentrantlock\" class=\"header-anchor\">#</a></h2>\n<h3><span id=\"1-1-reentrantlock-te-xing-gai-lan\">1.1 ReentrantLock特性概览</span><a href=\"#1-1-reentrantlock-te-xing-gai-lan\" class=\"header-anchor\">#</a></h3>\n<p>ReentrantLock意思为可重入锁，指的是一个线程能够对一个临界资源重复加锁。为了帮助大家更好地理解ReentrantLock的特性，我们先将ReentrantLock跟常用的Synchronized进行比较，其特性如下（蓝色部分为本篇文章主要剖析的点）：</p>\n<p><img src=\"https://p0.meituan.net/travelcube/412d294ff5535bbcddc0d979b2a339e6102264.png\" alt></p>\n<p>下面通过伪代码，进行更加直观的比较：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">synchronized</span> (object) &#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span> <span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\"><span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span> <span class=\"params\">()</span> throw Exception </span>&#123;</span><br><span class=\"line\">ReentrantLock lock = <span class=\"keyword\">new</span> ReentrantLock(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">lock.lock();</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(lock.tryLock(<span class=\"number\">100</span>, TimeUnit.MILLISECONDS))&#123; &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">lock.unlock()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">lock.unlock();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"1-2-reentrantlock-yu-aqs-de-guan-lian\">1.2 ReentrantLock与AQS的关联</span><a href=\"#1-2-reentrantlock-yu-aqs-de-guan-lian\" class=\"header-anchor\">#</a></h3>\n<p>通过上文我们已经了解，ReentrantLock支持公平锁和非公平锁（关于公平锁和非公平锁的原理分析，可参考《<a href=\"https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=2651749434&amp;idx=3&amp;sn=5ffa63ad47fe166f2f1a9f604ed10091&amp;chksm=bd12a5778a652c61509d9e718ab086ff27ad8768586ea9b38c3dcf9e017a8e49bcae3df9bcc8&amp;scene=38#wechat_redirect\">不可不说的Java“锁”事</a>》），并且ReentrantLock的底层就是由AQS来实现的。那么ReentrantLock是如何通过公平锁和非公平锁与AQS关联起来呢？ 我们着重从这两者的加锁过程来理解一下它们与AQS之间的关系（加锁过程中与AQS的关联比较明显，解锁流程后续会介绍）。</p>\n<p>非公平锁源码中的加锁流程如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NonfairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\">setExclusiveOwnerThread(Thread.currentThread());</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">acquire(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这块代码的含义为：</p>\n<ul>\n<li>\n<p>若通过CAS设置变量State（同步状态）成功，也就是获取锁成功，则将当前线程设置为独占线程。</p>\n</li>\n<li>\n<p>若通过CAS设置变量State（同步状态）失败，也就是获取锁失败，则进入Acquire方法进行后续处理。</p>\n</li>\n</ul>\n<p>第一步很好理解，但第二步获取锁失败后，后续的处理策略是怎么样的呢？这块可能会有以下思考：</p>\n<ul>\n<li>某个线程获取锁失败的后续流程是什么呢？有以下两种可能：</li>\n</ul>\n<p>(1) 将当前线程获锁结果设置为失败，获取锁流程结束。这种设计会极大降低系统的并发度，并不满足我们实际的需求。所以就需要下面这种流程，也就是AQS框架的处理流程。</p>\n<p>(2) 存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。</p>\n<ul>\n<li>\n<p>对于问题1的第二种情况，既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？</p>\n</li>\n<li>\n<p>处于排队等候机制中的线程，什么时候可以有机会获取锁呢？</p>\n</li>\n<li>\n<p>如果处于排队等候机制中的线程一直无法获取锁，还是需要一直等待吗，还是有别的策略来解决这一问题？</p>\n</li>\n</ul>\n<p>带着非公平锁的这些问题，再看下公平锁源码中获锁的方式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static final class FairSync extends Sync &#123;</span><br><span class=\"line\">  ...  </span><br><span class=\"line\">final void lock() &#123;</span><br><span class=\"line\">acquire(1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看到这块代码，我们可能会存在这种疑问：Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？</p>\n<p>结合公平锁和非公平锁的加锁流程，虽然流程上有一定的不同，但是都调用了Acquire方法，而Acquire方法是FairSync和UnfairSync的父类AQS中的核心方法。</p>\n<p>对于上边提到的问题，其实在ReentrantLock类源码中都无法解答，而这些问题的答案，都是位于Acquire方法所在的类AbstractQueuedSynchronizer中，也就是本文的核心——AQS。下面我们会对AQS以及ReentrantLock和AQS的关联做详细介绍（相关问题答案会在2.3.5小节中解答）。</p>\n<h2><span id=\"2-aqs\">2 AQS</span><a href=\"#2-aqs\" class=\"header-anchor\">#</a></h2>\n<p>首先，我们通过下面的架构图来整体了解一下AQS框架：</p>\n<p><img src=\"https://p1.meituan.net/travelcube/82077ccf14127a87b77cefd1ccf562d3253591.png\" alt></p>\n<ul>\n<li>\n<p>上图中有颜色的为Method，无颜色的为Attribution。</p>\n</li>\n<li>\n<p>总的来说，AQS框架共分为五层，自上而下由浅入深，从AQS对外暴露的API到底层基础数据。</p>\n</li>\n<li>\n<p>当有自定义同步器接入时，只需重写第一层所需要的部分方法即可，不需要关注底层具体的实现流程。当自定义同步器进行加锁或者解锁操作时，先经过第一层的API进入AQS内部方法，然后经过第二层进行锁的获取，接着对于获取锁失败的流程，进入第三层和第四层的等待队列处理，而这些处理方式均依赖于第五层的基础数据提供层。</p>\n</li>\n</ul>\n<p>下面我们会从整体到细节，从流程到方法逐一剖析AQS框架，主要分析过程如下：</p>\n<p><img src=\"https://p1.meituan.net/travelcube/d2f7f7fffdc30d85d17b44266c3ab05323338.png\" alt></p>\n<h3><span id=\"2-1-yuan-li-gai-lan\">2.1 原理概览</span><a href=\"#2-1-yuan-li-gai-lan\" class=\"header-anchor\">#</a></h3>\n<p>AQS核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。</p>\n<p>CLH：Craig、Landin and Hagersten队列，是单向链表，AQS中的队列是CLH变体的虚拟双向队列（FIFO），AQS是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配。</p>\n<p>主要原理图如下：</p>\n<p><img src=\"https://p0.meituan.net/travelcube/7132e4cef44c26f62835b197b239147b18062.png\" alt></p>\n<p>AQS使用一个Volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。</p>\n<h4><span id=\"2-1-1-aqs-shu-ju-jie-gou\">2.1.1 AQS数据结构</span><a href=\"#2-1-1-aqs-shu-ju-jie-gou\" class=\"header-anchor\">#</a></h4>\n<p>先来看下AQS中最基本的数据结构——Node，Node即为上面CLH变体队列中的节点。</p>\n<p><img src=\"https://p1.meituan.net/travelcube/960271cf2b5c8a185eed23e98b72c75538637.png\" alt></p>\n<p>解释一下几个方法和属性值的含义：</p>\n<table>\n<thead>\n<tr>\n<th>方法和属性值</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>waitStatus</td>\n<td>当前节点在队列中的状态</td>\n</tr>\n<tr>\n<td>thread</td>\n<td>表示处于该节点的线程</td>\n</tr>\n<tr>\n<td>prev</td>\n<td>前驱指针</td>\n</tr>\n<tr>\n<td>predecessor</td>\n<td>返回前驱节点，没有的话抛出npe</td>\n</tr>\n<tr>\n<td>nextWaiter</td>\n<td>指向下一个处于CONDITION状态的节点（由于本篇文章不讲述Condition Queue队列，这个指针不多介绍）</td>\n</tr>\n<tr>\n<td>next</td>\n<td>后继指针</td>\n</tr>\n</tbody>\n</table>\n<p>线程两种锁的模式：</p>\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SHARED</td>\n<td>表示线程以共享的模式等待锁</td>\n</tr>\n<tr>\n<td>EXCLUSIVE</td>\n<td>表示线程正在以独占的方式等待锁</td>\n</tr>\n</tbody>\n</table>\n<p>waitStatus有下面几个枚举值：</p>\n<table>\n<thead>\n<tr>\n<th>枚举</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>当一个Node被初始化的时候的默认值</td>\n</tr>\n<tr>\n<td>CANCELLED</td>\n<td>为1，表示线程获取锁的请求已经取消了</td>\n</tr>\n<tr>\n<td>CONDITION</td>\n<td>为-2，表示节点在等待队列中，节点线程等待唤醒</td>\n</tr>\n<tr>\n<td>PROPAGATE</td>\n<td>为-3，当前线程处在SHARED情况下，该字段才会使用</td>\n</tr>\n<tr>\n<td>SIGNAL</td>\n<td>为-1，表示线程已经准备好了，就等资源释放了</td>\n</tr>\n</tbody>\n</table>\n<h4><span id=\"2-1-2-tong-bu-zhuang-tai-state\">2.1.2 同步状态State</span><a href=\"#2-1-2-tong-bu-zhuang-tai-state\" class=\"header-anchor\">#</a></h4>\n<p>在了解数据结构后，接下来了解一下AQS的同步状态——State。AQS中维护了一个名为state的字段，意为同步状态，是由Volatile修饰的，用于展示当前临界资源的获锁情况。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private volatile int state;</span><br></pre></td></tr></table></figure>\n<p>下面提供了几个访问这个字段的方法：</p>\n<table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>protected final int getState()</td>\n<td>获取State的值</td>\n</tr>\n<tr>\n<td>protected final void setState(int newState)</td>\n<td>设置State的值</td>\n</tr>\n<tr>\n<td>protected final boolean compareAndSetState(int expect, int update)</td>\n<td>使用CAS方式更新State</td>\n</tr>\n</tbody>\n</table>\n<p>这几个方法都是Final修饰的，说明子类中无法重写它们。我们可以通过修改State字段表示的同步状态来实现多线程的独占模式和共享模式（加锁过程）。</p>\n<p><img src=\"https://p0.meituan.net/travelcube/27605d483e8935da683a93be015713f331378.png\" alt> <img src=\"https://p0.meituan.net/travelcube/3f1e1a44f5b7d77000ba4f9476189b2e32806.png\" alt></p>\n<p>对于我们自定义的同步工具，需要自定义获取同步状态和释放状态的方式，也就是AQS架构图中的第一层：API层。</p>\n<h2><span id=\"2-2-aqs-chong-yao-fang-fa-yu-reentrantlock-de-guan-lian\">2.2 AQS重要方法与ReentrantLock的关联</span><a href=\"#2-2-aqs-chong-yao-fang-fa-yu-reentrantlock-de-guan-lian\" class=\"header-anchor\">#</a></h2>\n<p>从架构图中可以得知，AQS提供了大量用于自定义同步器实现的Protected方法。自定义同步器实现的相关方法也只是为了通过修改State字段来实现多线程的独占模式或者共享模式。自定义同步器需要实现以下方法（ReentrantLock需要实现的方法如下，并不是全部）：</p>\n<table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>protected boolean isHeldExclusively()</td>\n<td>该线程是否正在独占资源。只有用到Condition才需要去实现它。</td>\n</tr>\n<tr>\n<td>protected boolean tryAcquire(int arg)</td>\n<td>独占方式。arg为获取锁的次数，尝试获取资源，成功则返回True，失败则返回False。</td>\n</tr>\n<tr>\n<td>protected boolean tryRelease(int arg)</td>\n<td>独占方式。arg为释放锁的次数，尝试释放资源，成功则返回True，失败则返回False。</td>\n</tr>\n<tr>\n<td>protected int tryAcquireShared(int arg)</td>\n<td>共享方式。arg为获取锁的次数，尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</td>\n</tr>\n<tr>\n<td>protected boolean tryReleaseShared(int arg)</td>\n<td>共享方式。arg为释放锁的次数，尝试释放资源，如果释放后允许唤醒后续等待结点返回True，否则返回False。</td>\n</tr>\n</tbody>\n</table>\n<p>一般来说，自定义同步器要么是独占方式，要么是共享方式，它们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。ReentrantLock是独占锁，所以实现了tryAcquire-tryRelease。</p>\n<p>以非公平锁为例，这里主要阐述一下非公平锁与AQS之间方法的关联之处，具体每一处核心方法的作用会在文章后面详细进行阐述。</p>\n<p><img src=\"https://p1.meituan.net/travelcube/b8b53a70984668bc68653efe9531573e78636.png\" alt></p>\n<p>为了帮助大家理解ReentrantLock和AQS之间方法的交互过程，以非公平锁为例，我们将加锁和解锁的交互流程单独拎出来强调一下，以便于对后续内容的理解。</p>\n<p><img src=\"https://p1.meituan.net/travelcube/7aadb272069d871bdee8bf3a218eed8136919.png\" alt></p>\n<p>加锁：</p>\n<ul>\n<li>通过ReentrantLock的加锁方法Lock进行加锁操作。</li>\n<li>会调用到内部类Sync的Lock方法，由于Sync#lock是抽象方法，根据ReentrantLock初始化选择的公平锁和非公平锁，执行相关内部类的Lock方法，本质上都会执行AQS的Acquire方法。</li>\n<li>AQS的Acquire方法会执行tryAcquire方法，但是由于tryAcquire需要自定义同步器实现，因此执行了ReentrantLock中的tryAcquire方法，由于ReentrantLock是通过公平锁和非公平锁内部类实现的tryAcquire方法，因此会根据锁类型不同，执行不同的tryAcquire。</li>\n<li>tryAcquire是获取锁逻辑，获取失败后，会执行框架AQS的后续逻辑，跟ReentrantLock自定义同步器无关。</li>\n</ul>\n<p>解锁：</p>\n<ul>\n<li>通过ReentrantLock的解锁方法Unlock进行解锁。</li>\n<li>Unlock会调用内部类Sync的Release方法，该方法继承于AQS。</li>\n<li>Release中会调用tryRelease方法，tryRelease需要自定义同步器实现，tryRelease只在ReentrantLock中的Sync实现，因此可以看出，释放锁的过程，并不区分是否为公平锁。</li>\n<li>释放成功后，所有处理由AQS框架完成，与自定义同步器无关。</li>\n</ul>\n<p>通过上面的描述，大概可以总结出ReentrantLock加锁解锁时API层核心方法的映射关系。</p>\n<p><img src=\"https://p0.meituan.net/travelcube/f30c631c8ebbf820d3e8fcb6eee3c0ef18748.png\" alt></p>\n<h2><span id=\"2-3-tong-guo-reentrantlock-li-jie-aqs\">2.3 通过ReentrantLock理解AQS</span><a href=\"#2-3-tong-guo-reentrantlock-li-jie-aqs\" class=\"header-anchor\">#</a></h2>\n<p>ReentrantLock中公平锁和非公平锁在底层是相同的，这里以非公平锁为例进行分析。</p>\n<p>在非公平锁中，有一段这样的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NonfairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\">    setExclusiveOwnerThread(Thread.currentThread());</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    acquire(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看一下这个Acquire是怎么写的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">    selfInterrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再看一下tryAcquire方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected boolean tryAcquire(int arg) &#123;</span><br><span class=\"line\">    throw new UnsupportedOperationException();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出，这里只是AQS的简单实现，具体获取锁的实现方法是由各自的公平锁和非公平锁单独实现的（以ReentrantLock为例）。如果该方法返回了True，则说明当前线程获取锁成功，就不用往后执行了；如果获取失败，就需要加入到等待队列中。下面会详细解释线程是何时以及怎样被加入进等待队列中的。</p>\n<h3><span id=\"2-3-1-xian-cheng-jia-ru-deng-dai-dui-lie\">2.3.1 线程加入等待队列</span><a href=\"#2-3-1-xian-cheng-jia-ru-deng-dai-dui-lie\" class=\"header-anchor\">#</a></h3>\n<h4><span id=\"2-3-1-1-jia-ru-dui-lie-de-shi-ji\">2.3.1.1 加入队列的时机</span><a href=\"#2-3-1-1-jia-ru-dui-lie-de-shi-ji\" class=\"header-anchor\">#</a></h4>\n<p>当执行Acquire(1)时，会通过tryAcquire获取锁。在这种情况下，如果获取锁失败，就会调用addWaiter加入到等待队列中去。</p>\n<h4><span id=\"2-3-1-2-ru-he-jia-ru-dui-lie\">2.3.1.2 如何加入队列</span><a href=\"#2-3-1-2-ru-he-jia-ru-dui-lie\" class=\"header-anchor\">#</a></h4>\n<p>获取锁失败后，会执行addWaiter(Node.EXCLUSIVE)加入等待队列，具体实现方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">addWaiter</span><span class=\"params\">(Node mode)</span> </span>&#123;</span><br><span class=\"line\">Node node = <span class=\"keyword\">new</span> Node(Thread.currentThread(), mode);</span><br><span class=\"line\">Node pred = tail;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (pred != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    node.prev = pred;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class=\"line\">    pred.next = node;</span><br><span class=\"line\"><span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">enq(node);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSetTail</span><span class=\"params\">(Node expect, Node update)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.compareAndSwapObject(<span class=\"keyword\">this</span>, tailOffset, expect, update);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>主要的流程如下：</p>\n<ul>\n<li>\n<p>通过当前的线程和锁模式新建一个节点。</p>\n</li>\n<li>\n<p>Pred指针指向尾节点Tail。</p>\n</li>\n<li>\n<p>将New中Node的Prev指针指向Pred。</p>\n</li>\n<li>\n<p>通过compareAndSetTail方法，完成尾节点的设置。这个方法主要是对tailOffset和Expect进行比较，如果tailOffset的Node和Expect的Node地址是相同的，那么设置Tail的值为Update的值。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    stateOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(<span class=\"string\">&quot;state&quot;</span>));</span><br><span class=\"line\">    headOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(<span class=\"string\">&quot;head&quot;</span>));</span><br><span class=\"line\">    tailOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(<span class=\"string\">&quot;tail&quot;</span>));</span><br><span class=\"line\">    waitStatusOffset = unsafe.objectFieldOffset(Node.class.getDeclaredField(<span class=\"string\">&quot;waitStatus&quot;</span>));</span><br><span class=\"line\">    nextOffset = unsafe.objectFieldOffset(Node.class.getDeclaredField(<span class=\"string\">&quot;next&quot;</span>));</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception ex) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(ex); </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从AQS的静态代码块可以看出，都是获取一个对象的属性相对于该对象在内存当中的偏移量，这样我们就可以根据这个偏移量在对象内存当中找到这个属性。tailOffset指的是tail对应的偏移量，所以这个时候会将new出来的Node置为当前队列的尾节点。同时，由于是双向链表，也需要将前一个节点指向尾节点。</p>\n<ul>\n<li>如果Pred指针是Null（说明等待队列中没有元素），或者当前Pred指针和Tail指向的位置不同（说明被别的线程已经修改），就需要看一下Enq的方法。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">enq</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        Node t = tail;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>) &#123; </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetHead(<span class=\"keyword\">new</span> Node()))</span><br><span class=\"line\">                tail = head;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                node.prev = t;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class=\"line\">                t.next = node;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果没有被初始化，需要进行初始化一个头结点出来。但请注意，初始化的头结点并不是当前线程节点，而是调用了无参构造函数的节点。如果经历了初始化或者并发导致队列中有元素，则与之前的方法相同。其实，addWaiter就是一个在双端链表添加尾节点的操作，需要注意的是，双端链表的头结点是一个无参构造函数的头结点。</p>\n<p>总结一下，线程获取锁的时候，过程大体如下：</p>\n<ol>\n<li>\n<p>当没有线程获取到锁时，线程1获取锁成功。</p>\n</li>\n<li>\n<p>线程2申请锁，但是锁被线程1占有。</p>\n</li>\n</ol>\n<p><img src=\"https://p0.meituan.net/travelcube/e9e385c3c68f62c67c8d62ab0adb613921117.png\" alt></p>\n<ol>\n<li>如果再有线程要获取锁，依次在队列中往后排队即可。</li>\n</ol>\n<p>回到上边的代码，hasQueuedPredecessors是公平锁加锁时判断等待队列中是否存在有效节点的方法。如果返回False，说明当前线程可以争取共享资源；如果返回True，说明队列中存在有效节点，当前线程必须加入到等待队列中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasQueuedPredecessors</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Node t = tail; </span><br><span class=\"line\">    Node h = head;</span><br><span class=\"line\">    Node s;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h != t &amp;&amp; ((s = h.next) == <span class=\"keyword\">null</span> || s.thread != Thread.currentThread());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看到这里，我们理解一下h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());为什么要判断的头结点的下一个节点？第一个节点储存的数据是什么？</p>\n<blockquote>\n<p>双向链表中，第一个节点为虚节点，其实并不存储任何信息，只是占位。真正的第一个有数据的节点，是在第二个节点开始的。当h != t时： 如果(s = h.next) == null，等待队列正在有线程进行初始化，但只是进行到了Tail指向Head，没有将Head指向Tail，此时队列中有元素，需要返回True（这块具体见下边代码分析）。 如果(s = h.next) != null，说明此时队列中至少有一个有效节点。如果此时s.thread == Thread.currentThread()，说明等待队列的第一个有效节点中的线程与当前线程相同，那么当前线程是可以获取资源的；如果s.thread != Thread.currentThread()，说明等待队列的第一个有效节点线程与当前线程不同，当前线程必须加入进等待队列。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (compareAndSetHead(<span class=\"keyword\">new</span> Node()))</span><br><span class=\"line\">        tail = head;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        node.prev = t;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class=\"line\">        t.next = node;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>节点入队不是原子操作，所以会出现短暂的head != tail，此时Tail指向最后一个节点，而且Tail指向Head。如果Head没有指向Tail（可见5、6、7行），这种情况下也需要将相关线程加入队列中。所以这块代码是为了解决极端情况下的并发问题。</p>\n<h4><span id=\"2-3-1-3-deng-dai-dui-lie-zhong-xian-cheng-chu-dui-lie-shi-ji\">2.3.1.3 等待队列中线程出队列时机</span><a href=\"#2-3-1-3-deng-dai-dui-lie-zhong-xian-cheng-chu-dui-lie-shi-ji\" class=\"header-anchor\">#</a></h4>\n<p>回到最初的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">    selfInterrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上文解释了addWaiter方法，这个方法其实就是把对应的线程以Node的数据结构形式加入到双端队列里，返回的是一个包含该线程的Node。而这个Node会作为参数，进入到acquireQueued方法中。acquireQueued方法可以对排队中的线程进行“获锁”操作。</p>\n<p>总的来说，一个线程获取锁失败了，被放入等待队列，acquireQueued会把放入队列中的线程不断去获取锁，直到获取成功或者不再需要获取（中断）。</p>\n<p>下面我们从“何时出队列？”和“如何出队列？”两个方向来分析一下acquireQueued源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">acquireQueued</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node, <span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> interrupted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node p = node.predecessor();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class=\"line\">        setHead(node);</span><br><span class=\"line\">        p.next = <span class=\"keyword\">null</span>; </span><br><span class=\"line\">        failed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> interrupted;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class=\"line\">        interrupted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">    cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注：setHead方法是把当前节点置为虚节点，但并没有修改waitStatus，因为它是一直需要用的数据。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setHead</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    head = node;</span><br><span class=\"line\">    node.thread = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    node.prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">shouldParkAfterFailedAcquire</span><span class=\"params\">(Node pred, Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ws = pred.waitStatus;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws == Node.SIGNAL)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        node.prev = pred = pred.prev;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (pred.waitStatus &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">        pred.next = node;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>parkAndCheckInterrupt主要用于挂起当前线程，阻塞调用栈，返回当前线程的中断状态。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">parkAndCheckInterrupt</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    LockSupport.park(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Thread.interrupted();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述方法的流程图如下：</p>\n<p><img src=\"https://p0.meituan.net/travelcube/c124b76dcbefb9bdc778458064703d1135485.png\" alt></p>\n<p>从上图可以看出，跳出当前循环的条件是当“前置节点是头结点，且当前线程获取锁成功”。为了防止因死循环导致CPU资源被浪费，我们会判断前置节点的状态来决定是否要将当前线程挂起，具体挂起流程用流程图表示如下（shouldParkAfterFailedAcquire流程）：</p>\n<p><img src=\"https://p0.meituan.net/travelcube/9af16e2481ad85f38ca322a225ae737535740.png\" alt></p>\n<p>从队列中释放节点的疑虑打消了，那么又有新问题了：</p>\n<ul>\n<li>\n<p>shouldParkAfterFailedAcquire中取消节点是怎么生成的呢？什么时候会把一个节点的waitStatus设置为-1？</p>\n</li>\n<li>\n<p>是在什么时间释放节点通知到被挂起的线程呢？</p>\n</li>\n</ul>\n<h3><span id=\"2-3-2-cancelled-zhuang-tai-jie-dian-sheng-cheng\">2.3.2 CANCELLED状态节点生成</span><a href=\"#2-3-2-cancelled-zhuang-tai-jie-dian-sheng-cheng\" class=\"header-anchor\">#</a></h3>\n<p>acquireQueued方法中的Finally代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">acquireQueued</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node, <span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node p = node.predecessor();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        failed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">        cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过cancelAcquire方法，将Node的状态标记为CANCELLED。接下来，我们逐行来分析这个方法的原理：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">cancelAcquire</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    node.thread = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    Node pred = node.prev;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (pred.waitStatus &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    node.prev = pred = pred.prev;</span><br><span class=\"line\">    Node predNext = pred.next;</span><br><span class=\"line\">    node.waitStatus = Node.CANCELLED;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class=\"line\">        compareAndSetNext(pred, predNext, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ws;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pred != head &amp;&amp; ((ws = pred.waitStatus) == Node.SIGNAL || (ws &lt;= <span class=\"number\">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; pred.thread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            Node next = node.next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (next != <span class=\"keyword\">null</span> &amp;&amp; next.waitStatus &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">            compareAndSetNext(pred, predNext, next);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            unparkSuccessor(node);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        node.next = node; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当前的流程：</p>\n<ul>\n<li>\n<p>获取当前节点的前驱节点，如果前驱节点的状态是CANCELLED，那就一直往前遍历，找到第一个waitStatus &lt;= 0的节点，将找到的Pred节点和当前Node关联，将当前Node设置为CANCELLED。</p>\n</li>\n<li>\n<p>根据当前节点的位置，考虑以下三种情况：</p>\n</li>\n</ul>\n<p>(1) 当前节点是尾节点。</p>\n<p>(2) 当前节点是Head的后继节点。</p>\n<p>(3) 当前节点不是Head的后继节点，也不是尾节点。</p>\n<p>根据上述第二条，我们来分析每一种情况的流程。</p>\n<p>当前节点是尾节点。</p>\n<p><img src=\"https://p1.meituan.net/travelcube/b845211ced57561c24f79d56194949e822049.png\" alt></p>\n<p>当前节点是Head的后继节点。</p>\n<p><img src=\"https://p1.meituan.net/travelcube/ab89bfec875846e5028a4f8fead32b7117975.png\" alt></p>\n<p>当前节点不是Head的后继节点，也不是尾节点。</p>\n<p><img src=\"https://p0.meituan.net/travelcube/45d0d9e4a6897eddadc4397cf53d6cd522452.png\" alt></p>\n<p>通过上面的流程，我们对于CANCELLED节点状态的产生和变化已经有了大致的了解，但是为什么所有的变化都是对Next指针进行了操作，而没有对Prev指针进行操作呢？什么情况下会对Prev指针进行操作？</p>\n<blockquote>\n<p>执行cancelAcquire的时候，当前节点的前置节点可能已经从队列中出去了（已经执行过Try代码块中的shouldParkAfterFailedAcquire方法了），如果此时修改Prev指针，有可能会导致Prev指向另一个已经移除队列的Node，因此这块变化Prev指针不安全。 shouldParkAfterFailedAcquire方法中，会执行下面的代码，其实就是在处理Prev指针。shouldParkAfterFailedAcquire是获取锁失败的情况下才会执行，进入该方法后，说明共享资源已被获取，当前节点之前的节点都不会出现变化，因此这个时候变更Prev指针比较安全。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">do &#123;</span><br><span class=\"line\">node.prev = pred = pred.prev;</span><br><span class=\"line\">&#125; while (pred.waitStatus &gt; 0);</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h3><span id=\"2-3-3-ru-he-jie-suo\">2.3.3 如何解锁</span><a href=\"#2-3-3-ru-he-jie-suo\" class=\"header-anchor\">#</a></h3>\n<p>我们已经剖析了加锁过程中的基本流程，接下来再对解锁的基本流程进行分析。由于ReentrantLock在解锁的时候，并不区分公平锁和非公平锁，所以我们直接看解锁的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    sync.release(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，本质释放锁的地方，是通过框架来完成的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">release</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryRelease(arg)) &#123;</span><br><span class=\"line\">        Node h = head;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h != <span class=\"keyword\">null</span> &amp;&amp; h.waitStatus != <span class=\"number\">0</span>)</span><br><span class=\"line\">        unparkSuccessor(h);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在ReentrantLock里面的公平锁和非公平锁的父类Sync定义了可重入锁的释放锁机制。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> releases)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = getState() - releases;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> free = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    free = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    setExclusiveOwnerThread(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    setState(c);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> free;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们来解释下述源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">release</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryRelease(arg)) &#123;</span><br><span class=\"line\">        Node h = head;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h != <span class=\"keyword\">null</span> &amp;&amp; h.waitStatus != <span class=\"number\">0</span>)</span><br><span class=\"line\">            unparkSuccessor(h);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的判断条件为什么是h != null &amp;&amp; h.waitStatus != 0？</p>\n<blockquote>\n<p>h == null Head还没初始化。初始情况下，head == null，第一个节点入队，Head会被初始化一个虚拟节点。所以说，这里如果还没来得及入队，就会出现head == null 的情况。</p>\n<p>h != null &amp;&amp; waitStatus == 0 表明后继节点对应的线程仍在运行中，不需要唤醒。</p>\n<p>h != null &amp;&amp; waitStatus &lt; 0 表明后继节点可能被阻塞了，需要唤醒。</p>\n</blockquote>\n<p>再看一下unparkSuccessor方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">unparkSuccessor</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ws = node.waitStatus;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    compareAndSetWaitStatus(node, ws, <span class=\"number\">0</span>);</span><br><span class=\"line\">    Node s = node.next;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span> || s.waitStatus &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    s = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Node t = tail; t != <span class=\"keyword\">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t.waitStatus &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">    s = t;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (s != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    LockSupport.unpark(s.thread);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为什么要从后往前找第一个非Cancelled的节点呢？原因如下。</p>\n<p>之前的addWaiter方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">addWaiter</span><span class=\"params\">(Node mode)</span> </span>&#123;</span><br><span class=\"line\">    Node node = <span class=\"keyword\">new</span> Node(Thread.currentThread(), mode);</span><br><span class=\"line\">    Node pred = tail;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pred != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        node.prev = pred;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class=\"line\">            pred.next = node;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    enq(node);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们从这里可以看到，节点入队并不是原子操作，也就是说，node.prev = pred; compareAndSetTail(pred, node) 这两个地方可以看作Tail入队的原子操作，但是此时pred.next = node;还没执行，如果这个时候执行了unparkSuccessor方法，就没办法从前往后找了，所以需要从后往前找。还有一点原因，在产生CANCELLED状态节点的时候，先断开的是Next指针，Prev指针并未断开，因此也是必须要从后往前遍历才能够遍历完全部的Node。</p>\n<p>综上所述，如果是从前往后找，由于极端情况下入队的非原子操作和CANCELLED节点产生过程中断开Next指针的操作，可能会导致无法遍历所有的节点。所以，唤醒对应的线程后，对应的线程就会继续往下执行。继续执行acquireQueued方法以后，中断如何处理？</p>\n<h3><span id=\"2-3-4-zhong-duan-hui-fu-hou-de-zhi-xing-liu-cheng\">2.3.4 中断恢复后的执行流程</span><a href=\"#2-3-4-zhong-duan-hui-fu-hou-de-zhi-xing-liu-cheng\" class=\"header-anchor\">#</a></h3>\n<p>唤醒后，会执行return Thread.interrupted();，这个函数返回的是当前执行线程的中断状态，并清除。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">parkAndCheckInterrupt</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    LockSupport.park(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Thread.interrupted();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再回到acquireQueued代码，当parkAndCheckInterrupt返回True或者False的时候，interrupted的值不同，但都会执行下次循环。如果这个时候获取锁成功，就会把当前interrupted返回。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">acquireQueued</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node, <span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> interrupted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node p = node.predecessor();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class=\"line\">            setHead(node);</span><br><span class=\"line\">            p.next = <span class=\"keyword\">null</span>; </span><br><span class=\"line\">            failed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> interrupted;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class=\"line\">        interrupted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">        cancelAcquire(node);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果acquireQueued为True，就会执行selfInterrupt方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">selfInterrupt</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">Thread.currentThread().interrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法其实是为了中断线程。但为什么获取了锁以后还要中断线程呢？这部分属于Java提供的协作式中断知识内容，感兴趣同学可以查阅一下。这里简单介绍一下：</p>\n<ol>\n<li>\n<p>当中断线程被唤醒时，并不知道被唤醒的原因，可能是当前线程在等待中被中断，也可能是释放了锁以后被唤醒。因此我们通过Thread.interrupted()方法检查中断标记（该方法返回了当前线程的中断状态，并将当前线程的中断标识设置为False），并记录下来，如果发现该线程被中断过，就再中断一次。</p>\n</li>\n<li>\n<p>线程在等待资源的过程中被唤醒，唤醒后还是会不断地去尝试获取锁，直到抢到锁为止。也就是说，在整个流程中，并不响应中断，只是记录中断记录。最后抢到锁返回了，那么如果被中断过的话，就需要补充一次中断。</p>\n</li>\n</ol>\n<p>这里的处理方式主要是运用线程池中基本运作单元Worder中的runWorker，通过Thread.interrupted()进行额外的判断处理，感兴趣的同学可以看下ThreadPoolExecutor源码。</p>\n<h3><span id=\"2-3-5-xiao-jie\">2.3.5 小结</span><a href=\"#2-3-5-xiao-jie\" class=\"header-anchor\">#</a></h3>\n<p>我们在1.3小节中提出了一些问题，现在来回答一下。</p>\n<blockquote>\n<p>Q：某个线程获取锁失败的后续流程是什么呢？</p>\n<p>A：存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。</p>\n<p>Q：既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？</p>\n<p>A：是CLH变体的FIFO双端队列。</p>\n<p>Q：处于排队等候机制中的线程，什么时候可以有机会获取锁呢？</p>\n<p>A：可以详细看下2.3.1.3小节。</p>\n<p>Q：如果处于排队等候机制中的线程一直无法获取锁，需要一直等待么？还是有别的策略来解决这一问题？</p>\n<p>A：线程所在节点的状态会变成取消状态，取消状态的节点会从队列中释放，具体可见2.3.2小节。</p>\n<p>Q：Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？</p>\n<p>A：AQS的Acquire会调用tryAcquire方法，tryAcquire由各个自定义同步器实现，通过tryAcquire完成加锁过程。</p>\n</blockquote>\n<h2><span id=\"3-aqs-ying-yong\">3 AQS应用</span><a href=\"#3-aqs-ying-yong\" class=\"header-anchor\">#</a></h2>\n<h3><span id=\"3-1-reentrantlock-de-ke-chong-ru-ying-yong\">3.1 ReentrantLock的可重入应用</span><a href=\"#3-1-reentrantlock-de-ke-chong-ru-ying-yong\" class=\"header-anchor\">#</a></h3>\n<p>ReentrantLock的可重入性是AQS很好的应用之一，在了解完上述知识点以后，我们很容易得知ReentrantLock实现可重入的方法。在ReentrantLock里面，不管是公平锁还是非公平锁，都有一段逻辑。</p>\n<p>公平锁：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">        setExclusiveOwnerThread(current);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nextc = c + acquires;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class=\"line\">    setState(nextc);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>非公平锁：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, acquires))&#123;</span><br><span class=\"line\">        setExclusiveOwnerThread(current);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> nextc = c + acquires;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>) </span><br><span class=\"line\"><span class=\"function\">t   hrow new <span class=\"title\">Error</span><span class=\"params\">(<span class=\"string\">&quot;Maximum lock count exceeded&quot;</span>)</span></span>;</span><br><span class=\"line\">setState(nextc);</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面这两段都可以看到，有一个同步状态State来控制整体可重入的情况。State是Volatile修饰的，用于保证一定的可见性和有序性。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> state;</span><br></pre></td></tr></table></figure>\n<p>接下来看State这个字段主要的过程：</p>\n<ol>\n<li>\n<p>State初始化的时候为0，表示没有任何线程持有锁。</p>\n</li>\n<li>\n<p>当有线程持有该锁时，值就会在原来的基础上+1，同一个线程多次获得锁是，就会多次+1，这里就是可重入的概念。</p>\n</li>\n<li>\n<p>解锁也是对这个字段-1，一直到0，此线程对锁释放。</p>\n</li>\n</ol>\n<h3><span id=\"3-2-juc-zhong-de-ying-yong-chang-jing\">3.2 JUC中的应用场景</span><a href=\"#3-2-juc-zhong-de-ying-yong-chang-jing\" class=\"header-anchor\">#</a></h3>\n<p>除了上边ReentrantLock的可重入性的应用，AQS作为并发编程的框架，为很多其他同步工具提供了良好的解决方案。下面列出了JUC中的几种同步工具，大体介绍一下AQS的应用场景：</p>\n<table>\n<thead>\n<tr>\n<th>同步工具</th>\n<th>同步工具与AQS的关联</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ReentrantLock</td>\n<td>使用AQS保存锁重复持有的次数。当一个线程获取锁时，ReentrantLock记录当前获得锁的线程标识，用于检测是否重复获取，以及错误线程试图解锁操作时异常情况的处理。</td>\n</tr>\n<tr>\n<td>Semaphore</td>\n<td>使用AQS同步状态来保存信号量的当前计数。tryRelease会增加计数，acquireShared会减少计数。</td>\n</tr>\n<tr>\n<td>CountDownLatch</td>\n<td>使用AQS同步状态来表示计数。计数为0时，所有的Acquire操作（CountDownLatch的await方法）才可以通过。</td>\n</tr>\n<tr>\n<td>ReentrantReadWriteLock</td>\n<td>使用AQS同步状态中的16位保存写锁持有的次数，剩下的16位用于保存读锁的持有次数。</td>\n</tr>\n<tr>\n<td>ThreadPoolExecutor</td>\n<td>Worker利用AQS同步状态实现对独占线程变量的设置（tryAcquire和tryRelease）。</td>\n</tr>\n</tbody>\n</table>\n<h3><span id=\"3-3-zi-ding-yi-tong-bu-gong-ju\">3.3 自定义同步工具</span><a href=\"#3-3-zi-ding-yi-tong-bu-gong-ju\" class=\"header-anchor\">#</a></h3>\n<p>了解AQS基本原理以后，按照上面所说的AQS知识点，自己实现一个同步工具。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LeeLock</span>  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span> <span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span> <span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">            setState(<span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isHeldExclusively</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> getState() == <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Sync sync = <span class=\"keyword\">new</span> Sync();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        sync.acquire(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        sync.release(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过我们自己定义的Lock完成一定的同步功能。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LeeMain</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> LeeLock leeLock = <span class=\"keyword\">new</span> LeeLock();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span> <span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Runnable runnable = <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    leeLock.lock();</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">                        count++;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    leeLock.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        Thread thread1 = <span class=\"keyword\">new</span> Thread(runnable);</span><br><span class=\"line\">        Thread thread2 = <span class=\"keyword\">new</span> Thread(runnable);</span><br><span class=\"line\">        thread1.start();</span><br><span class=\"line\">        thread2.start();</span><br><span class=\"line\">        thread1.join();</span><br><span class=\"line\">        thread2.join();</span><br><span class=\"line\">        System.out.println(count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码每次运行结果都会是20000。通过简单的几行代码就能实现同步功能，这就是AQS的强大之处。</p>\n<h2><span id=\"zong-jie\">总结</span><a href=\"#zong-jie\" class=\"header-anchor\">#</a></h2>\n<p>我们日常开发中使用并发的场景太多，但是对并发内部的基本框架原理了解的人却不多。由于篇幅原因，本文仅介绍了可重入锁ReentrantLock的原理和AQS原理，希望能够成为大家了解AQS和ReentrantLock等同步器的“敲门砖”。</p>\n<h2><span id=\"can-kao-zi-liao\">参考资料</span><a href=\"#can-kao-zi-liao\" class=\"header-anchor\">#</a></h2>\n<ul>\n<li>Lea D. The java. util. concurrent synchronizer framework[J]. Science of Computer Programming, 2005, 58(3): 293-309.</li>\n<li>《Java并发编程实战》</li>\n<li><a href=\"https://tech.meituan.com/2018/11/15/java-lock.html\">不可不说的Java“锁”事</a></li>\n<li><a href=\"https://www.jianshu.com/p/f584799f1c77\">一张图读懂公平锁与非公平锁</a></li>\n<li><a href=\"https://blog.csdn.net/qq_35190492/article/details/104943579\">公平锁和非公平锁的区别</a></li>\n</ul>\n<link rel=\"stylesheet\" href=\"/css/markmap.css\" type=\"text/css\">","tags":[{"name":"Java","slug":"Java","permalink":"https://blog.beyhub.com/tags/Java/"},{"name":"锁","slug":"锁","permalink":"https://blog.beyhub.com/tags/%E9%94%81/"},{"name":"高并发","slug":"高并发","permalink":"https://blog.beyhub.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"}]},{"title":"Java SDK中的SPI机制","path":"post/java-sdk中的spi机制/","text":"本文通过探析JDK提供的，在开源项目中比较常用的Java SPI机制，希望给大家在实际开发实践、学习开源项目提供参考。SPI全称Service Provider Interface，是Java提供的一套用来被第三方实现或者扩展的API，它可以用来启用框架扩展和替换组件。 整体机制图如下： Java SPI 实际上是“基于接口的编程＋策略模式＋配置文件”组合实现的动态加载机制。 系统设计的各个抽象，往往有很多不同的实现方案，在面向的对象的设计里，一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。 Java SPI就是提供这样的一个机制：为某个接口寻找服务实现的机制。有点类似IOC的思想，就是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要。所以SPI的核心思想就是解耦。 概括地说，适用于：调用者根据实际使用需要，启用、扩展、或者替换框架的实现策略 比较常见的例子： 数据库驱动加载接口实现类的加载 JDBC加载不同类型数据库的驱动 日志门面接口实现类加载 SLF4J加载不同提供商的日志实现类 Spring Spring中大量使用了SPI,比如：对servlet3.0规范对ServletContainerInitializer的实现、自动类型转换Type Conversion SPI(Converter SPI、Formatter SPI)等 Dubbo Dubbo中也大量使用SPI的方式实现框架的扩展, 不过它对Java提供的原生SPI做了封装，允许用户扩展实现Filter接口 要使用Java SPI，需要遵循如下约定： 1、当服务提供者提供了接口的一种具体实现后，在jar包的META-INF/services目录下创建一个以“接口全限定名”为命名的文件，内容为实现类的全限定名； 2、接口实现类所在的jar包放在主程序的classpath中； 3、主程序通过java.util.ServiceLoder动态装载实现模块，它通过扫描META-INF/services目录下的配置文件找到实现类的全限定名，把类加载到JVM； 4、SPI的实现类必须携带一个不带参数的构造方法； 示例代码# 步骤1、定义一组接口 (假设是org.foo.demo.IShout)，并写出接口的一个或多个实现，(假设是org.foo.demo.animal.Dog、org.foo.demo.animal.Cat)。 123456789101112131415public interface IShout &#123; void shout();&#125;public class Cat implements IShout &#123; @Override public void shout() &#123; System.out.println(&quot;miao miao&quot;); &#125;&#125;public class Dog implements IShout &#123; @Override public void shout() &#123; System.out.println(&quot;wang wang&quot;); &#125;&#125; 步骤2、在 src/main/resources/ 下建立 /META-INF/services 目录， 新增一个以接口命名的文件 (org.foo.demo.IShout文件)，内容是要应用的实现类（这里是org.foo.demo.animal.Dog和org.foo.demo.animal.Cat，每行一个类）。 文件位置 123456- src -main -resources - META-INF - services - org.foo.demo.IShout 文件内容 12org.foo.demo.animal.Dogorg.foo.demo.animal.Cat 步骤3、使用 ServiceLoader 来加载配置文件中指定的实现。 12345678public class SPIMain &#123; public static void main(String[] args) &#123; ServiceLoader&lt;IShout&gt; shouts = ServiceLoader.load(IShout.class); for (IShout s : shouts) &#123; s.shout(); &#125; &#125;&#125; 代码输出： 首先看ServiceLoader类的签名类的成员变量： 12345678910public final class ServiceLoader&lt;S&gt; implements Iterable&lt;S&gt;&#123;private static final String PREFIX = &quot;META-INF/services/&quot;; private final Class&lt;S&gt; service; private final ClassLoader loader; private final AccessControlContext acc; private LinkedHashMap&lt;String,S&gt; providers = new LinkedHashMap&lt;&gt;(); private LazyIterator lookupIterator; ......&#125; 参考具体ServiceLoader具体源码，代码量不多，加上注释一共587行，梳理了一下，实现的流程如下： 1 应用程序调用ServiceLoader.load方法 ServiceLoader.load方法内先创建一个新的ServiceLoader，并实例化该类中的成员变量，包括： loader(ClassLoader类型，类加载器) acc(AccessControlContext类型，访问控制器) providers(LinkedHashMap&lt;String,S&gt;类型，用于缓存加载成功的类) lookupIterator(实现迭代器功能) 2 应用程序通过迭代器接口获取对象实例 ServiceLoader先判断成员变量providers对象中(LinkedHashMap&lt;String,S&gt;类型)是否有缓存实例对象，如果有缓存，直接返回。 如果没有缓存，执行类的装载，实现如下： (1) 读取META-INF/services/下的配置文件，获得所有能被实例化的类的名称，值得注意的是，ServiceLoader可以跨越jar包获取META-INF下的配置文件，具体加载配置的实现代码如下： 123456789try &#123; String fullName = PREFIX + service.getName(); if (loader == null) configs = ClassLoader.getSystemResources(fullName); else configs = loader.getResources(fullName);&#125; catch (IOException x) &#123; fail(service, &quot;Error locating configuration files&quot;, x);&#125; (2) 通过反射方法Class.forName()加载类对象，并用instance()方法将类实例化。 (3) 把实例化后的类缓存到providers对象中，(LinkedHashMap&lt;String,S&gt;类型） 然后返回实例对象。 优点： 使用Java SPI机制的优势是实现解耦，使得第三方服务模块的装配控制的逻辑与调用者的业务代码分离，而不是耦合在一起。应用程序可以根据实际业务情况启用框架扩展或替换框架组件。 相比使用提供接口jar包，供第三方服务模块实现接口的方式，SPI的方式使得源框架，不必关心接口的实现类的路径，可以不用通过下面的方式获取接口实现类： 代码硬编码import 导入实现类 指定类全路径反射获取：例如在JDBC4.0之前，JDBC中获取数据库驱动类需要通过Class.forName(“com.mysql.jdbc.Driver”)，类似语句先动态加载数据库相关的驱动，然后再进行获取连接等的操作 第三方服务模块把接口实现类实例注册到指定地方，源框架从该处访问实例 通过SPI的方式，第三方服务模块实现接口后，在第三方的项目代码的META-INF/services目录下的配置文件指定实现类的全路径名，源码框架即可找到实现类 缺点： 虽然ServiceLoader也算是使用的延迟加载，但是基本只能通过遍历全部获取，也就是接口的实现类全部加载并实例化一遍。如果你并不想用某些实现类，它也被加载并实例化了，这就造成了浪费。获取某个实现类的方式不够灵活，只能通过Iterator形式获取，不能根据某个参数来获取对应的实现类。 多个并发多线程使用ServiceLoader类的实例是不安全的。 参考资料# Java核心技术36讲 The Java™ Tutorials Java Doc Service Provider Interface: Creating Extensible Java Applications Service provider interface Java ServiceLoader使用和解析 Java基础之SPI机制 Java中SPI机制深入及源码解析 SPI机制简介 示例项目# https://github.com/eugenp/tutorials/tree/master/java-spi 原文链接：https://www.jianshu.com/p/46b42f7f593c","content":"<p>本文通过探析JDK提供的，在开源项目中比较常用的Java SPI机制，希望给大家在实际开发实践、学习开源项目提供参考。SPI全称Service Provider Interface，是Java提供的一套用来被第三方实现或者扩展的API，它可以用来启用框架扩展和替换组件。</p>\n<span id=\"more\"></span>\n<p>整体机制图如下：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5618238-5d8948367cb9b18e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/848/format/webp\" alt></p>\n<p>Java SPI 实际上是“<strong>基于接口的编程＋策略模式＋配置文件</strong>”组合实现的动态加载机制。</p>\n<p>系统设计的各个抽象，往往有很多不同的实现方案，在面向的对象的设计里，一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。<br>\nJava SPI就是提供这样的一个机制：为某个接口寻找服务实现的机制。有点类似IOC的思想，就是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要。所以SPI的核心思想就是<strong>解耦</strong>。</p>\n<p>概括地说，适用于：<strong>调用者根据实际使用需要，启用、扩展、或者替换框架的实现策略</strong></p>\n<p>比较常见的例子：</p>\n<ul>\n<li>数据库驱动加载接口实现类的加载<br>\nJDBC加载不同类型数据库的驱动</li>\n<li>日志门面接口实现类加载<br>\nSLF4J加载不同提供商的日志实现类</li>\n<li>Spring<br>\nSpring中大量使用了SPI,比如：对servlet3.0规范对ServletContainerInitializer的实现、自动类型转换Type Conversion SPI(Converter SPI、Formatter SPI)等</li>\n<li>Dubbo<br>\nDubbo中也大量使用SPI的方式实现框架的扩展, 不过它对Java提供的原生SPI做了封装，允许用户扩展实现Filter接口</li>\n</ul>\n<p>要使用Java SPI，需要遵循如下约定：</p>\n<ul>\n<li>1、当服务提供者提供了接口的一种具体实现后，在jar包的META-INF/services目录下创建一个以“接口全限定名”为命名的文件，内容为实现类的全限定名；</li>\n<li>2、接口实现类所在的jar包放在主程序的classpath中；</li>\n<li>3、主程序通过java.util.ServiceLoder动态装载实现模块，它通过扫描META-INF/services目录下的配置文件找到实现类的全限定名，把类加载到JVM；</li>\n<li>4、SPI的实现类必须携带一个不带参数的构造方法；</li>\n</ul>\n<h2><span id=\"shi-li-dai-ma\">示例代码</span><a href=\"#shi-li-dai-ma\" class=\"header-anchor\">#</a></h2>\n<p><strong>步骤1</strong>、定义一组接口 (假设是org.foo.demo.IShout)，并写出接口的一个或多个实现，(假设是org.foo.demo.animal.Dog、org.foo.demo.animal.Cat)。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IShout</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shout</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> <span class=\"keyword\">implements</span> <span class=\"title\">IShout</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">shout</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;miao miao&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> <span class=\"keyword\">implements</span> <span class=\"title\">IShout</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">shout</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;wang wang&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>步骤2</strong>、在 src/main/resources/ 下建立 /META-INF/services 目录， 新增一个以接口命名的文件 (org.foo.demo.IShout文件)，内容是要应用的实现类（这里是org.foo.demo.animal.Dog和org.foo.demo.animal.Cat，每行一个类）。</p>\n<p>文件位置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- src</span><br><span class=\"line\">    -main</span><br><span class=\"line\">        -resources</span><br><span class=\"line\">            - META-INF</span><br><span class=\"line\">                - services</span><br><span class=\"line\">                    - org.foo.demo.IShout</span><br></pre></td></tr></table></figure>\n<p>文件内容</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">org.foo.demo.animal.Dog</span><br><span class=\"line\">org.foo.demo.animal.Cat</span><br></pre></td></tr></table></figure>\n<p><strong>步骤3</strong>、使用 ServiceLoader 来加载配置文件中指定的实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SPIMain</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ServiceLoader&lt;IShout&gt; shouts = ServiceLoader.load(IShout.class);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (IShout s : shouts) &#123;</span><br><span class=\"line\">            s.shout();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码输出：</p>\n<p>首先看ServiceLoader类的签名类的成员变量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServiceLoader</span>&lt;<span class=\"title\">S</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Iterable</span>&lt;<span class=\"title\">S</span>&gt;</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String PREFIX = <span class=\"string\">&quot;META-INF/services/&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Class&lt;S&gt; service;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ClassLoader loader;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AccessControlContext acc;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> LinkedHashMap&lt;String,S&gt; providers = <span class=\"keyword\">new</span> LinkedHashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> LazyIterator lookupIterator;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>参考具体ServiceLoader具体源码，代码量不多，加上注释一共587行，梳理了一下，实现的流程如下：</p>\n<ul>\n<li>\n<p>1 应用程序调用ServiceLoader.load方法<br>\nServiceLoader.load方法内先创建一个新的ServiceLoader，并实例化该类中的成员变量，包括：</p>\n<ul>\n<li>loader(ClassLoader类型，类加载器)</li>\n<li>acc(AccessControlContext类型，访问控制器)</li>\n<li>providers(LinkedHashMap&lt;String,S&gt;类型，用于缓存加载成功的类)</li>\n<li>lookupIterator(实现迭代器功能)</li>\n</ul>\n</li>\n<li>\n<p>2 应用程序通过迭代器接口获取对象实例<br>\nServiceLoader先判断成员变量providers对象中(LinkedHashMap&lt;String,S&gt;类型)是否有缓存实例对象，如果有缓存，直接返回。<br>\n如果没有缓存，执行类的装载，实现如下：</p>\n</li>\n<li>\n<p>(1) 读取META-INF/services/下的配置文件，获得所有能被实例化的类的名称，值得注意的是，ServiceLoader<strong>可以跨越jar包获取META-INF下的配置文件</strong>，具体加载配置的实现代码如下：</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try &#123;</span><br><span class=\"line\">    String fullName = PREFIX + service.getName();</span><br><span class=\"line\">    if (loader == null)</span><br><span class=\"line\">        configs = ClassLoader.getSystemResources(fullName);</span><br><span class=\"line\">    else</span><br><span class=\"line\">        configs = loader.getResources(fullName);</span><br><span class=\"line\">&#125; catch (IOException x) &#123;</span><br><span class=\"line\">    fail(service, &quot;Error locating configuration files&quot;, x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>(2) 通过反射方法Class.forName()加载类对象，并用instance()方法将类实例化。</li>\n<li>(3) 把实例化后的类缓存到providers对象中，(LinkedHashMap&lt;String,S&gt;类型）<br>\n然后返回实例对象。</li>\n</ul>\n<p><strong>优点</strong>：<br>\n使用Java SPI机制的优势是实现解耦，使得第三方服务模块的装配控制的逻辑与调用者的业务代码分离，而不是耦合在一起。应用程序可以根据实际业务情况启用框架扩展或替换框架组件。</p>\n<p>相比使用提供接口jar包，供第三方服务模块实现接口的方式，SPI的方式使得源框架，不必关心接口的实现类的路径，可以不用通过下面的方式获取接口实现类：</p>\n<ul>\n<li>代码硬编码import 导入实现类</li>\n<li>指定类全路径反射获取：例如在JDBC4.0之前，JDBC中获取数据库驱动类需要通过<strong>Class.forName(“com.mysql.jdbc.Driver”)</strong>，类似语句先动态加载数据库相关的驱动，然后再进行获取连接等的操作</li>\n<li>第三方服务模块把接口实现类实例注册到指定地方，源框架从该处访问实例</li>\n</ul>\n<p>通过SPI的方式，第三方服务模块实现接口后，在第三方的项目代码的META-INF/services目录下的配置文件指定实现类的全路径名，源码框架即可找到实现类</p>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>虽然ServiceLoader也算是使用的延迟加载，但是基本只能通过遍历全部获取，也就是接口的实现类全部加载并实例化一遍。如果你并不想用某些实现类，它也被加载并实例化了，这就造成了浪费。获取某个实现类的方式不够灵活，只能通过Iterator形式获取，不能根据某个参数来获取对应的实现类。</li>\n<li>多个并发多线程使用ServiceLoader类的实例是不安全的。</li>\n</ul>\n<h3><span id=\"can-kao-zi-liao\">参考资料</span><a href=\"#can-kao-zi-liao\" class=\"header-anchor\">#</a></h3>\n<p><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Ftime.geekbang.org%2Fcolumn%2Fintro%2F82%3Fcode%3Dw8EZ6RGOQApZJ5tpAzP8dRzeVHxZ4q%252FfOdSbSZzbkhc%253D\">Java核心技术36讲</a><br>\n<a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fdocs.oracle.com%2Fjavase%2Ftutorial%2Fext%2Fbasics%2Fspi.html\">The Java™ Tutorials</a><br>\n<a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fdocs.oracle.com%2Fjavase%2F8%2Fdocs%2Fapi%2Fjava%2Futil%2FServiceLoader.html\">Java Doc</a><br>\n<a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.developer.com%2Fjava%2Farticle.php%2F3848881%2FService-Provider-Interface-Creating-Extensible-Java-Applications.htm\">Service Provider Interface: Creating Extensible Java Applications</a><br>\n<a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FService_provider_interface\">Service provider interface</a><br>\n<a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2Flovesqcc%2Fp%2F5229353.html\">Java ServiceLoader使用和解析</a><br>\n<a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fyangguosb%2Farticle%2Fdetails%2F78772730\">Java基础之SPI机制</a><br>\n<a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fcxis.me%2F2017%2F04%2F17%2FJava%25E4%25B8%25ADSPI%25E6%259C%25BA%25E5%2588%25B6%25E6%25B7%25B1%25E5%2585%25A5%25E5%258F%258A%25E6%25BA%2590%25E7%25A0%2581%25E8%25A7%25A3%25E6%259E%2590%2F\">Java中SPI机制深入及源码解析</a><br>\n<a href=\"https://links.jianshu.com/go?to=http%3A%2F%2Fwww.spring4all.com%2Farticle%2F260\">SPI机制简介</a></p>\n<h3><span id=\"shi-li-xiang-mu\">示例项目</span><a href=\"#shi-li-xiang-mu\" class=\"header-anchor\">#</a></h3>\n<p><a href=\"https://github.com/eugenp/tutorials/tree/master/java-spi\">https://github.com/eugenp/tutorials/tree/master/java-spi</a></p>\n<p>原文链接：<a href=\"https://www.jianshu.com/p/46b42f7f593c\">https://www.jianshu.com/p/46b42f7f593c</a></p>\n<link rel=\"stylesheet\" href=\"/css/markmap.css\" type=\"text/css\">","tags":[{"name":"java","slug":"java","permalink":"https://blog.beyhub.com/tags/java/"}]},{"title":"关系型数据库的单列索引与联合索引","path":"post/关系型数据库的单列索引与联合索引/","text":"数据库只做两件事情：存储数据、检索数据。而索引是在你存储的数据之外，额外保存一些路标（一般是B+树），以减少检索数据的时间。所以索引是主数据衍生的附加结构。一张表可以建立任意多个索引，每个索引可以是任意多个字段的组合。索引可能会提高查询速度（如果查询时使用了索引），但一定会减慢写入速度，因为每次写入时都需要更新索引，所以索引只应该加在经常需要搜索的列上，不要加在写多读少的列上。 使用单列索引和组合索引的时机# 在关系数据库中，索引是一种提升检索速度的数据结构，但是它会带来写入速度的损失，以及更多的存储空间占用。 通过一个字段而不是主键查询一张n条记录的数据表，需要扫描O(n)条记录（从技术上讲，n意味着该表使用的磁盘块的数量，但是为了便于理解我们简单的假设它是记录的条数）。举例来说，假设ssn是一个唯一字段，下面这条SQL查询平均需要读取n/2条记录才能找到匹配的记录。 1SELECT \\* FROM users WHERE users.ssn = &#x27;1234&#x27;; 因为ssn是唯一的，所以在第一次找到这条记录时就会停止；然而如果查询字段不是唯一的，类似下面这条SQL语句会扫描n条数据（全表扫描）来找到所有的匹配记录： 1SELECT \\* FROM users WHERE users.first\\_name = &#x27;Teemo&#x27;; 全表扫描是缓慢的，尤其当表的记录非常多的时候，这个时候可以创建索引来提升查询性能。 索引，或者更具体一些，单列索引是通过一种额外的数据结构B-Tree来对指定的特定的列进行排序。索引中的每一条记录包含一个指向数据表的指针，所以在索引中查找数据等价于在原始数据表中查询。举例，假设现在有下面这张users表： ID first_name last_name Class Position ssn 1 Teemo Shroomer Specialist Top 2345 2 Cecil Heimerdinger Specialist Mid 5461 3 Annie Hastur Mage Mid 8784 4 Fiora Laurent Slayer Top 7867 5 Garen Crownguard Fighter Top 4579 6 Malcolm Graves Specialist ADC 4578 7 Irelia Lito Figher Top 5689 8 Janna Windforce Controller Support 4580 9 Jarvan Lightshield Figher Top 4579 10 Katarina DuCouteau Assassin Mid 5608 11 Kayle Hex Specialist Top 4794 12 Emilia LeBlanc Mage Mid 3468 13 Lee Sin Fighter Jungle 8085 14 Lux Crownguard Mage Mid 4567 15 Sarah Fortune Marksman ADC 6560 16 Morgana Hex Controller Support 3457 17 Orianna Reveck Mage Mid 9282 18 Sona Buvelle Controller Support 4722 19 Jericho Swain Mage Mid 5489 20 Shauna Vayne Marksman ADC 2352 21 Xin Zhao Fighter Jungle 6902 22 Yorick Mori Tank Top 4840 23 Wu Kong Fighter Jungle 4933 我们在users.first_name字段创建一个普通索引： 1CREATE INDEX first_name_index ON users (first_name) USING BTREE; 这时会创建一个基于first_name字段的排序，并使用指针指向users表的主键，类似于下面这样： first_name Primary Key Annie 3 Cecil 2 Emilia 12 Fiora 4 Garen 5 Irelia 7 Janna 8 Jarvan 9 Jericho 19 Katarina 10 Kayle 11 Lee 13 Lux 14 Malcolm 6 Morgana 16 Orianna 17 Sarah 15 Shauna 20 Sona 18 Teemo 1 Wu 23 Xin 21 Yorick 22 执行下面这条查询： 1SELECT * FROM users WHERE first_name = &#x27;Teemo&#x27;; 此时，first_name字段已建立有顺序的索引，数据库在执行查询时，通过二分法查找将算法复杂度降到O(log_2(n))。 唯一索引# 除了性能方面的收益，索引也会被用于优化具有唯一性的字段。举例，假设我们不希望多个用户使用同一个手机号码，这是就可以在创建索引时添加UNIQUE修饰符。 1CREATE UNIQUE INDEX ssn\\_index ON users (ssn); 创建上述唯一索引后，如果users表中已经存在了一条对应字段值相同记录，则会引起一个错误。 避免必要的索引# 正如有一句谚语所说：“天下没有免费的午餐”，索引能提高性能但也是有成本的： 额外的空间用于存储索引 执行CREATE、UPDATE、DELETE等数据修改操作时，索引也会被更新 因此，事实上不必要的索引会导致性能整体性的降低，接下来是使用索引的几条准则： 不要在读少写多的表上创建索引，正如上面所说，索引提升了读性能但是降低了写性能 不要在大多数值都相同字段上使用索引，查询复杂度能达到O(log_2(n))的原因是二分法查找，但这只有在多数字段值都不同的情况下才有效 不要在确定大小的小表上使用索引，因为这并不会明显的提升性能。但要注意，有些表（例如users）虽然现在很小，但它未来可能会不断增长；但也有的表一直很小，冰激凌的口味毕竟是有限的。 单列索引和组合索引也是对字段排序的数据结构，但是与单列索引不同的是，联合索引中组合了多个字段。举例，再看下这张users表： ID first_name last_name class position 1 Teemo Shroomer Specialist Top 2 Cecil Heimerdinger Specialist Mid 3 Annie Hastur Mage Mid 4 Fiora Laurent Slayer Top 5 Garen Crownguard Fighter Top 6 Malcolm Graves Specialist ADC 7 Irelia Lito Figher Top 8 Janna Windforce Controller Support 9 Jarvan Lightshield Figher Top 10 Katarina DuCouteau Assassin Mid 11 Kayle Hex Specialist Top 12 Emilia LeBlanc Mage Mid 13 Lee Sin Fighter Jungle 14 Lux Crownguard Mage Mid 15 Sarah Fortune Marksman ADC 16 Morgana Hex Controller Support 17 Orianna Reveck Mage Mid 18 Sona Buvelle Controller Support 19 Jericho Swain Mage Mid 20 Shauna Vayne Marksman ADC 21 Xin Zhao Fighter Jungle 22 Yorick Mori Tank Top 23 Wu Kong Fighter Jungle 在class和position两列上创建一个联合索引： 1CREATE INDEX class_pos_index ON users (class, position); 这时候创建了一个组合索引，对两个字段拼接进行排序，如下所示： class-position Primary Key AssassinMid 10 ControllerSupport 16 ControllerSupport 18 ControllerSupport 8 FigherTop 7 FigherTop 9 FighterJungle 13 FighterJungle 21 FighterJungle 23 FighterTop 5 MageMid 12 MageMid 14 MageMid 17 MageMid 19 MageMid 3 MarksmanADC 15 MarksmanADC 20 SlayerTop 4 SpecialistADC 6 SpecialistMid 2 SpecialistTop 1 SpecialistTop 11 TankTop 22 下面是一个对联合索引的查询： 1SELECT * FROM users WHERE class = &#x27;Specialist&#x27; AND position = &#x27;Top&#x27;; 经过上面一通操作，我们减少了检索时间，因为联合索引基于class-position排序，数据库可以在时间复杂度O(log_2(n))下查找到值SpecialistTop，而不是全表扫描。 受益于上述组合索引将class作为联合索引的第一个字段，基于class列的查询性能也会提升。因为基于class字段的索引基本上等同于联合索引class-position，所以我们不需要再单独为class建立索引。 1SELECT * FROM users WHERE class = &#x27;Specialist&#x27;; 然而，对字段position的查询性能并不会有所变化，因为它是联合索引中的第二个字段。基于class-position排序的联合索引，不能用于快速检索position列的值 1SELECT \\* FROM users WHERE position = &#x27;Top&#x27;; 基于以上，联合索引组成字段的顺序是非常重要的，一个对column1 , column2 , column3 ,…, columnN若干字段的组合索引，对以下SQL语句是有效的： 1234SELECT * FROM table WHERE column1 = &#x27;value&#x27;;SELECT * FROM table WHERE column1 = &#x27;value1&#x27; AND column2 = &#x27;value2&#x27;;SELECT * FROM table WHERE column1 = &#x27;value1&#x27; AND column2 = &#x27;value2&#x27; AND column3 = &#x27;value3&#x27;...SELECT * FROM table WHERE column1 = &#x27;value1&#x27; AND column2 = &#x27;value2&#x27; AND column3 = &#x27;value3&#x27;... AND columnN = &#x27;valueN&#x27; 联合索引建立指南# 和单列索引一样，联合索引也会降低写入速度，同时增加存储空间的占用量。建立联合索引时，选择字段以及字段顺序排列应当考虑以下几个原则： 如果一些字段倾向于在查询中同时出现，这时，为他们创建一个联合是一个不错的主意。例如，在上述users表中，建立一个(last_name, first_name)组合的联合主键是不错的选择 如果需要对字段field1创建索引，同时也需要创建联合索引(field1, field2)，此时只需要创建后者即可 与单列索引类似，组合字段值的重复度会影响联合索引的查询效率。很显然，如果两个字段重复度不高，联合索引组成的索引值重复度也不高，但我们仍然可以将高重复度的字段和低重复度的几个字段组合起来建立联合索引。 唯一组合索引和组合索引# 联合索引也可以将字段值组合设置为强制唯一。 通常，单个字段值不是唯一的，但组合后的字段是唯一的。例如，addresses表中有street,address_number,city，3个字段。我们不需要将street或house_number或city设置为唯一，因为不同的地址可能使用相同的上述值，但我们可能会希望street-house_number-city这个组合是唯一的。这时，我们可以使用联合索引，并添加UNIQUE修饰符： 1CREATE UNIQUE INDEX index_st_no_city ON addresses (street, house_number, city); 原文地址：https://user3141592.medium.com/single-vs-composite-indexes-in-relational-databases-58d0eb045cbe","content":"<p>数据库只做两件事情：存储数据、检索数据。而索引是在你存储的数据之外，额外保存一些路标（一般是B+树），以减少检索数据的时间。所以索引是主数据衍生的附加结构。一张表可以建立任意多个索引，每个索引可以是任意多个字段的组合。索引可能会提高查询速度（如果查询时使用了索引），但一定会减慢写入速度，因为每次写入时都需要更新索引，所以索引只应该加在经常需要搜索的列上，不要加在写多读少的列上。</p>\n<span id=\"more\"></span>\n<h2><span id=\"shi-yong-dan-lie-suo-yin-he-zu-he-suo-yin-de-shi-ji\">使用单列索引和组合索引的时机</span><a href=\"#shi-yong-dan-lie-suo-yin-he-zu-he-suo-yin-de-shi-ji\" class=\"header-anchor\">#</a></h2>\n<p>在关系数据库中，索引是一种提升检索速度的数据结构，但是它会带来写入速度的损失，以及更多的存储空间占用。</p>\n<p>通过一个字段而不是主键查询一张<code>n</code>条记录的数据表，需要扫描O(n)条记录（从技术上讲，<code>n</code>意味着该表使用的<a href=\"https://en.wikipedia.org/wiki/Block_(data_storage)\"><strong>磁盘块</strong></a>的数量，但是为了便于理解我们简单的假设它是记录的条数）。举例来说，假设<code>ssn</code>是一个唯一字段，下面这条SQL查询平均需要读取<code>n/2</code>条记录才能找到匹配的记录。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> \\<span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> users <span class=\"keyword\">WHERE</span> users.ssn <span class=\"operator\">=</span> <span class=\"string\">&#x27;1234&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p>因为<code>ssn</code>是唯一的，所以在第一次找到这条记录时就会停止；然而如果查询字段不是唯一的，类似下面这条SQL语句会扫描<code>n</code>条数据（全表扫描）来找到所有的匹配记录：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> \\<span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> users <span class=\"keyword\">WHERE</span> users.first\\_name <span class=\"operator\">=</span> <span class=\"string\">&#x27;Teemo&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p>全表扫描是缓慢的，尤其当表的记录非常多的时候，这个时候可以创建索引来提升查询性能。</p>\n<p>索引，或者更具体一些，单列索引是通过一种额外的数据结构<code>B-Tree</code>来对指定的特定的列进行排序。索引中的每一条记录包含一个指向数据表的指针，所以在索引中查找数据等价于在原始数据表中查询。举例，假设现在有下面这张<code>users</code>表：</p>\n<table>\n<thead>\n<tr>\n<th>ID</th>\n<th>first_name</th>\n<th>last_name</th>\n<th>Class</th>\n<th>Position</th>\n<th>ssn</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>Teemo</td>\n<td>Shroomer</td>\n<td>Specialist</td>\n<td>Top</td>\n<td>2345</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Cecil</td>\n<td>Heimerdinger</td>\n<td>Specialist</td>\n<td>Mid</td>\n<td>5461</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Annie</td>\n<td>Hastur</td>\n<td>Mage</td>\n<td>Mid</td>\n<td>8784</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Fiora</td>\n<td>Laurent</td>\n<td>Slayer</td>\n<td>Top</td>\n<td>7867</td>\n</tr>\n<tr>\n<td>5</td>\n<td>Garen</td>\n<td>Crownguard</td>\n<td>Fighter</td>\n<td>Top</td>\n<td>4579</td>\n</tr>\n<tr>\n<td>6</td>\n<td>Malcolm</td>\n<td>Graves</td>\n<td>Specialist</td>\n<td>ADC</td>\n<td>4578</td>\n</tr>\n<tr>\n<td>7</td>\n<td>Irelia</td>\n<td>Lito</td>\n<td>Figher</td>\n<td>Top</td>\n<td>5689</td>\n</tr>\n<tr>\n<td>8</td>\n<td>Janna</td>\n<td>Windforce</td>\n<td>Controller</td>\n<td>Support</td>\n<td>4580</td>\n</tr>\n<tr>\n<td>9</td>\n<td>Jarvan</td>\n<td>Lightshield</td>\n<td>Figher</td>\n<td>Top</td>\n<td>4579</td>\n</tr>\n<tr>\n<td>10</td>\n<td>Katarina</td>\n<td>DuCouteau</td>\n<td>Assassin</td>\n<td>Mid</td>\n<td>5608</td>\n</tr>\n<tr>\n<td>11</td>\n<td>Kayle</td>\n<td>Hex</td>\n<td>Specialist</td>\n<td>Top</td>\n<td>4794</td>\n</tr>\n<tr>\n<td>12</td>\n<td>Emilia</td>\n<td>LeBlanc</td>\n<td>Mage</td>\n<td>Mid</td>\n<td>3468</td>\n</tr>\n<tr>\n<td>13</td>\n<td>Lee</td>\n<td>Sin</td>\n<td>Fighter</td>\n<td>Jungle</td>\n<td>8085</td>\n</tr>\n<tr>\n<td>14</td>\n<td>Lux</td>\n<td>Crownguard</td>\n<td>Mage</td>\n<td>Mid</td>\n<td>4567</td>\n</tr>\n<tr>\n<td>15</td>\n<td>Sarah</td>\n<td>Fortune</td>\n<td>Marksman</td>\n<td>ADC</td>\n<td>6560</td>\n</tr>\n<tr>\n<td>16</td>\n<td>Morgana</td>\n<td>Hex</td>\n<td>Controller</td>\n<td>Support</td>\n<td>3457</td>\n</tr>\n<tr>\n<td>17</td>\n<td>Orianna</td>\n<td>Reveck</td>\n<td>Mage</td>\n<td>Mid</td>\n<td>9282</td>\n</tr>\n<tr>\n<td>18</td>\n<td>Sona</td>\n<td>Buvelle</td>\n<td>Controller</td>\n<td>Support</td>\n<td>4722</td>\n</tr>\n<tr>\n<td>19</td>\n<td>Jericho</td>\n<td>Swain</td>\n<td>Mage</td>\n<td>Mid</td>\n<td>5489</td>\n</tr>\n<tr>\n<td>20</td>\n<td>Shauna</td>\n<td>Vayne</td>\n<td>Marksman</td>\n<td>ADC</td>\n<td>2352</td>\n</tr>\n<tr>\n<td>21</td>\n<td>Xin</td>\n<td>Zhao</td>\n<td>Fighter</td>\n<td>Jungle</td>\n<td>6902</td>\n</tr>\n<tr>\n<td>22</td>\n<td>Yorick</td>\n<td>Mori</td>\n<td>Tank</td>\n<td>Top</td>\n<td>4840</td>\n</tr>\n<tr>\n<td>23</td>\n<td>Wu</td>\n<td>Kong</td>\n<td>Fighter</td>\n<td>Jungle</td>\n<td>4933</td>\n</tr>\n</tbody>\n</table>\n<p>我们在<code>users.first_name</code>字段创建一个普通索引：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> INDEX first_name_index <span class=\"keyword\">ON</span> users (first_name) <span class=\"keyword\">USING</span> BTREE;</span><br></pre></td></tr></table></figure>\n<p>这时会创建一个基于<code>first_name</code>字段的排序，并使用指针指向<code>users</code>表的主键，类似于下面这样：</p>\n<table>\n<thead>\n<tr>\n<th>first_name</th>\n<th>Primary Key</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Annie</td>\n<td>3</td>\n</tr>\n<tr>\n<td>Cecil</td>\n<td>2</td>\n</tr>\n<tr>\n<td>Emilia</td>\n<td>12</td>\n</tr>\n<tr>\n<td>Fiora</td>\n<td>4</td>\n</tr>\n<tr>\n<td>Garen</td>\n<td>5</td>\n</tr>\n<tr>\n<td>Irelia</td>\n<td>7</td>\n</tr>\n<tr>\n<td>Janna</td>\n<td>8</td>\n</tr>\n<tr>\n<td>Jarvan</td>\n<td>9</td>\n</tr>\n<tr>\n<td>Jericho</td>\n<td>19</td>\n</tr>\n<tr>\n<td>Katarina</td>\n<td>10</td>\n</tr>\n<tr>\n<td>Kayle</td>\n<td>11</td>\n</tr>\n<tr>\n<td>Lee</td>\n<td>13</td>\n</tr>\n<tr>\n<td>Lux</td>\n<td>14</td>\n</tr>\n<tr>\n<td>Malcolm</td>\n<td>6</td>\n</tr>\n<tr>\n<td>Morgana</td>\n<td>16</td>\n</tr>\n<tr>\n<td>Orianna</td>\n<td>17</td>\n</tr>\n<tr>\n<td>Sarah</td>\n<td>15</td>\n</tr>\n<tr>\n<td>Shauna</td>\n<td>20</td>\n</tr>\n<tr>\n<td>Sona</td>\n<td>18</td>\n</tr>\n<tr>\n<td>Teemo</td>\n<td>1</td>\n</tr>\n<tr>\n<td>Wu</td>\n<td>23</td>\n</tr>\n<tr>\n<td>Xin</td>\n<td>21</td>\n</tr>\n<tr>\n<td>Yorick</td>\n<td>22</td>\n</tr>\n</tbody>\n</table>\n<p>执行下面这条查询：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> users <span class=\"keyword\">WHERE</span> first_name <span class=\"operator\">=</span> <span class=\"string\">&#x27;Teemo&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p>此时，<code>first_name</code>字段已建立有顺序的索引，数据库在执行查询时，通过二分法查找将算法复杂度降到<code>O(log_2(n))</code>。</p>\n<h2><span id=\"wei-yi-suo-yin\">唯一索引</span><a href=\"#wei-yi-suo-yin\" class=\"header-anchor\">#</a></h2>\n<p>除了性能方面的收益，索引也会被用于优化具有唯一性的字段。举例，假设我们不希望多个用户使用同一个手机号码，这是就可以在创建索引时添加<code>UNIQUE</code>修饰符。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">UNIQUE</span> INDEX ssn\\_index <span class=\"keyword\">ON</span> users (ssn);</span><br></pre></td></tr></table></figure>\n<p>创建上述唯一索引后，如果<code>users</code>表中已经存在了一条对应字段值相同记录，则会引起一个错误。</p>\n<h2><span id=\"bi-mian-bi-yao-de-suo-yin\">避免必要的索引</span><a href=\"#bi-mian-bi-yao-de-suo-yin\" class=\"header-anchor\">#</a></h2>\n<p>正如有一句谚语所说：“天下没有免费的午餐”，索引能提高性能但也是有成本的：</p>\n<ol>\n<li>额外的空间用于存储索引</li>\n<li>执行<code>CREATE</code>、<code>UPDATE</code>、<code>DELETE</code>等数据修改操作时，索引也会被更新</li>\n</ol>\n<p>因此，事实上不必要的索引会导致性能整体性的降低，接下来是使用索引的几条准则：</p>\n<ul>\n<li>不要在读少写多的表上创建索引，正如上面所说，索引提升了读性能但是降低了写性能</li>\n<li>不要在大多数值都相同字段上使用索引，查询复杂度能达到<code>O(log_2(n))</code>的原因是二分法查找，但这只有在多数字段值都不同的情况下才有效</li>\n<li>不要在确定大小的小表上使用索引，因为这并不会明显的提升性能。但要注意，有些表（例如<code>users</code>）虽然现在很小，但它未来可能会不断增长；但也有的表一直很小，冰激凌的口味毕竟是有限的。</li>\n</ul>\n<p>单列索引和组合索引也是对字段排序的数据结构，但是与单列索引不同的是，联合索引中组合了多个字段。举例，再看下这张<code>users</code>表：</p>\n<table>\n<thead>\n<tr>\n<th>ID</th>\n<th>first_name</th>\n<th>last_name</th>\n<th>class</th>\n<th>position</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>Teemo</td>\n<td>Shroomer</td>\n<td>Specialist</td>\n<td>Top</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Cecil</td>\n<td>Heimerdinger</td>\n<td>Specialist</td>\n<td>Mid</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Annie</td>\n<td>Hastur</td>\n<td>Mage</td>\n<td>Mid</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Fiora</td>\n<td>Laurent</td>\n<td>Slayer</td>\n<td>Top</td>\n</tr>\n<tr>\n<td>5</td>\n<td>Garen</td>\n<td>Crownguard</td>\n<td>Fighter</td>\n<td>Top</td>\n</tr>\n<tr>\n<td>6</td>\n<td>Malcolm</td>\n<td>Graves</td>\n<td>Specialist</td>\n<td>ADC</td>\n</tr>\n<tr>\n<td>7</td>\n<td>Irelia</td>\n<td>Lito</td>\n<td>Figher</td>\n<td>Top</td>\n</tr>\n<tr>\n<td>8</td>\n<td>Janna</td>\n<td>Windforce</td>\n<td>Controller</td>\n<td>Support</td>\n</tr>\n<tr>\n<td>9</td>\n<td>Jarvan</td>\n<td>Lightshield</td>\n<td>Figher</td>\n<td>Top</td>\n</tr>\n<tr>\n<td>10</td>\n<td>Katarina</td>\n<td>DuCouteau</td>\n<td>Assassin</td>\n<td>Mid</td>\n</tr>\n<tr>\n<td>11</td>\n<td>Kayle</td>\n<td>Hex</td>\n<td>Specialist</td>\n<td>Top</td>\n</tr>\n<tr>\n<td>12</td>\n<td>Emilia</td>\n<td>LeBlanc</td>\n<td>Mage</td>\n<td>Mid</td>\n</tr>\n<tr>\n<td>13</td>\n<td>Lee</td>\n<td>Sin</td>\n<td>Fighter</td>\n<td>Jungle</td>\n</tr>\n<tr>\n<td>14</td>\n<td>Lux</td>\n<td>Crownguard</td>\n<td>Mage</td>\n<td>Mid</td>\n</tr>\n<tr>\n<td>15</td>\n<td>Sarah</td>\n<td>Fortune</td>\n<td>Marksman</td>\n<td>ADC</td>\n</tr>\n<tr>\n<td>16</td>\n<td>Morgana</td>\n<td>Hex</td>\n<td>Controller</td>\n<td>Support</td>\n</tr>\n<tr>\n<td>17</td>\n<td>Orianna</td>\n<td>Reveck</td>\n<td>Mage</td>\n<td>Mid</td>\n</tr>\n<tr>\n<td>18</td>\n<td>Sona</td>\n<td>Buvelle</td>\n<td>Controller</td>\n<td>Support</td>\n</tr>\n<tr>\n<td>19</td>\n<td>Jericho</td>\n<td>Swain</td>\n<td>Mage</td>\n<td>Mid</td>\n</tr>\n<tr>\n<td>20</td>\n<td>Shauna</td>\n<td>Vayne</td>\n<td>Marksman</td>\n<td>ADC</td>\n</tr>\n<tr>\n<td>21</td>\n<td>Xin</td>\n<td>Zhao</td>\n<td>Fighter</td>\n<td>Jungle</td>\n</tr>\n<tr>\n<td>22</td>\n<td>Yorick</td>\n<td>Mori</td>\n<td>Tank</td>\n<td>Top</td>\n</tr>\n<tr>\n<td>23</td>\n<td>Wu</td>\n<td>Kong</td>\n<td>Fighter</td>\n<td>Jungle</td>\n</tr>\n</tbody>\n</table>\n<p>在<code>class</code>和<code>position</code>两列上创建一个联合索引：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> INDEX class_pos_index <span class=\"keyword\">ON</span> users (class, position);</span><br></pre></td></tr></table></figure>\n<p>这时候创建了一个组合索引，对两个字段拼接进行排序，如下所示：</p>\n<table>\n<thead>\n<tr>\n<th>class-position</th>\n<th>Primary Key</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>AssassinMid</td>\n<td>10</td>\n</tr>\n<tr>\n<td>ControllerSupport</td>\n<td>16</td>\n</tr>\n<tr>\n<td>ControllerSupport</td>\n<td>18</td>\n</tr>\n<tr>\n<td>ControllerSupport</td>\n<td>8</td>\n</tr>\n<tr>\n<td>FigherTop</td>\n<td>7</td>\n</tr>\n<tr>\n<td>FigherTop</td>\n<td>9</td>\n</tr>\n<tr>\n<td>FighterJungle</td>\n<td>13</td>\n</tr>\n<tr>\n<td>FighterJungle</td>\n<td>21</td>\n</tr>\n<tr>\n<td>FighterJungle</td>\n<td>23</td>\n</tr>\n<tr>\n<td>FighterTop</td>\n<td>5</td>\n</tr>\n<tr>\n<td>MageMid</td>\n<td>12</td>\n</tr>\n<tr>\n<td>MageMid</td>\n<td>14</td>\n</tr>\n<tr>\n<td>MageMid</td>\n<td>17</td>\n</tr>\n<tr>\n<td>MageMid</td>\n<td>19</td>\n</tr>\n<tr>\n<td>MageMid</td>\n<td>3</td>\n</tr>\n<tr>\n<td>MarksmanADC</td>\n<td>15</td>\n</tr>\n<tr>\n<td>MarksmanADC</td>\n<td>20</td>\n</tr>\n<tr>\n<td>SlayerTop</td>\n<td>4</td>\n</tr>\n<tr>\n<td>SpecialistADC</td>\n<td>6</td>\n</tr>\n<tr>\n<td>SpecialistMid</td>\n<td>2</td>\n</tr>\n<tr>\n<td>SpecialistTop</td>\n<td>1</td>\n</tr>\n<tr>\n<td>SpecialistTop</td>\n<td>11</td>\n</tr>\n<tr>\n<td>TankTop</td>\n<td>22</td>\n</tr>\n</tbody>\n</table>\n<p>下面是一个对联合索引的查询：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> users <span class=\"keyword\">WHERE</span>  class <span class=\"operator\">=</span> <span class=\"string\">&#x27;Specialist&#x27;</span> <span class=\"keyword\">AND</span> position <span class=\"operator\">=</span> <span class=\"string\">&#x27;Top&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p>经过上面一通操作，我们减少了检索时间，因为联合索引基于<code>class-position</code>排序，数据库可以在时间复杂度<code>O(log_2(n))</code>下查找到值<code>SpecialistTop</code>，而不是全表扫描。</p>\n<p>受益于上述组合索引将<code>class</code>作为联合索引的第一个字段，基于<code>class</code>列的查询性能也会提升。因为基于<code>class</code>字段的索引基本上等同于联合索引<code>class-position</code>，所以我们不需要再单独为<code>class</code>建立索引。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> users <span class=\"keyword\">WHERE</span> class <span class=\"operator\">=</span> <span class=\"string\">&#x27;Specialist&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p>然而，对字段<code>position</code>的查询性能并不会有所变化，因为它是联合索引中的第二个字段。基于<code>class-position</code>排序的联合索引，不能用于快速检索<code>position</code>列的值</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> \\<span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> users <span class=\"keyword\">WHERE</span> position <span class=\"operator\">=</span> <span class=\"string\">&#x27;Top&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p>基于以上，联合索引组成字段的顺序是非常重要的，一个对<code>column1</code> , <code>column2</code> , <code>column3</code> ,…, <code>columnN</code>若干字段的组合索引，对以下SQL语句是有效的：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> <span class=\"keyword\">table</span> <span class=\"keyword\">WHERE</span> column1 <span class=\"operator\">=</span> <span class=\"string\">&#x27;value&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> <span class=\"keyword\">table</span> <span class=\"keyword\">WHERE</span> column1 <span class=\"operator\">=</span> <span class=\"string\">&#x27;value1&#x27;</span> <span class=\"keyword\">AND</span> column2 <span class=\"operator\">=</span> <span class=\"string\">&#x27;value2&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> <span class=\"keyword\">table</span> <span class=\"keyword\">WHERE</span> column1 <span class=\"operator\">=</span> <span class=\"string\">&#x27;value1&#x27;</span> <span class=\"keyword\">AND</span> column2 <span class=\"operator\">=</span> <span class=\"string\">&#x27;value2&#x27;</span> <span class=\"keyword\">AND</span> column3 <span class=\"operator\">=</span> <span class=\"string\">&#x27;value3&#x27;</span>...</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> <span class=\"keyword\">table</span> <span class=\"keyword\">WHERE</span> column1 <span class=\"operator\">=</span> <span class=\"string\">&#x27;value1&#x27;</span> <span class=\"keyword\">AND</span> column2 <span class=\"operator\">=</span> <span class=\"string\">&#x27;value2&#x27;</span> <span class=\"keyword\">AND</span> column3 <span class=\"operator\">=</span> <span class=\"string\">&#x27;value3&#x27;</span>... <span class=\"keyword\">AND</span> columnN <span class=\"operator\">=</span> <span class=\"string\">&#x27;valueN&#x27;</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"lian-he-suo-yin-jian-li-zhi-nan\">联合索引建立指南</span><a href=\"#lian-he-suo-yin-jian-li-zhi-nan\" class=\"header-anchor\">#</a></h2>\n<p>和单列索引一样，联合索引也会降低写入速度，同时增加存储空间的占用量。建立联合索引时，选择字段以及字段顺序排列应当考虑以下几个原则：</p>\n<ul>\n<li>如果一些字段倾向于在查询中同时出现，这时，为他们创建一个联合是一个不错的主意。例如，在上述<code>users</code>表中，建立一个<code>(last_name, first_name)</code>组合的联合主键是不错的选择</li>\n<li>如果需要对字段<code>field1</code>创建索引，同时也需要创建联合索引<code>(field1, field2)</code>，此时只需要创建后者即可</li>\n<li>与单列索引类似，组合字段值的重复度会影响联合索引的查询效率。很显然，如果两个字段重复度不高，联合索引组成的索引值重复度也不高，但我们仍然可以将高重复度的字段和低重复度的几个字段组合起来建立联合索引。</li>\n</ul>\n<h2><span id=\"wei-yi-zu-he-suo-yin-he-zu-he-suo-yin\">唯一组合索引和组合索引</span><a href=\"#wei-yi-zu-he-suo-yin-he-zu-he-suo-yin\" class=\"header-anchor\">#</a></h2>\n<p>联合索引也可以将字段值组合设置为强制唯一。</p>\n<p>通常，单个字段值不是唯一的，但组合后的字段是唯一的。例如，<code>addresses</code>表中有<code>street</code>,<code>address_number</code>,<code>city</code>，3个字段。我们不需要将<code>street</code>或<code>house_number</code>或<code>city</code>设置为唯一，因为不同的地址可能使用相同的上述值，但我们可能会希望<code>street-house_number-city</code>这个组合是唯一的。这时，我们可以使用联合索引，并添加<code>UNIQUE</code>修饰符：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">UNIQUE</span> INDEX index_st_no_city <span class=\"keyword\">ON</span> addresses (street, house_number, city);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>原文地址：<a href=\"https://user3141592.medium.com/single-vs-composite-indexes-in-relational-databases-58d0eb045cbe\">https://user3141592.medium.com/single-vs-composite-indexes-in-relational-databases-58d0eb045cbe</a></p>\n</blockquote>\n<link rel=\"stylesheet\" href=\"/css/markmap.css\" type=\"text/css\">","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.beyhub.com/tags/MySQL/"},{"name":"面试题","slug":"面试题","permalink":"https://blog.beyhub.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"HashMap、Hashtable等Map接口的实现和原理","path":"post/hashmap、hashtable等map接口的实现和原理/","text":"Map 集合和 Collection 集合不同，Map 集合是基于键（key）/值（value）的映射，Collection中的集合，元素是孤立存在的，向集合中存储元素采用一个个元素的方式存储；Map中的集合，元素是成对存在的，每个元素由键与值两部分组成，通过键可以找对所对应的值。 Collection中的集合称为单列集合，Map中的集合称为双列集合。需要注意的是，Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。 比较# HashMap TreeMap HashTable 实现 基于哈希散列表实现 SortMap接口，基于红黑树 继承自Dictionary 存储 随机存储 默认按键的升序排序 随机存储 遍历 Iterator遍历是随机的 Iterator遍历是排序的 Enumeration和Iterator 性能损耗 几乎无 插入、删除 几乎无 键值对 只允许键、值均为null 键、值都不能为null 不允许null 线程安全 否 否 是 效率 高 低 高 一般情况下我们选用HashMap，因为HashMap的键值对在取出时是随机的，其依据键的hashCode和键的equals方法存取数据，具有很快的访问速度，所以在Map中插入、删除及索引元素时其是效率最高的实现。而TreeMap的键值对在取出时是排过序的，所以效率会低点。 HashTable# 散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存储存位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。 HashMap和hashtable的区别# HashMap允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许 HashMap 把 Hashtable 的 contains 方法去掉了，改成 containsValue 和 containsKey。因为 contains 方法容易让人引起误解。 HashTable 继承自 Dictionary 类，而HashMap是Java1.2 引进的 Map interface 的一个实现 HashTable 的方法是 Synchronize 的，而HashMap不是，在多个线程访问 Hashtable 时，不需要自己为它的方法实现同步，而 HashMap 就必须为之提供外同步 Hashtable 和 HashMap 采用的 hash/rehash 算法都大概一样，所以性能不会有很大的差异 HashMap 不是线程安全的（没有锁）# HashMap 是 map 接口的实现类，是将键映射到值的对象，其中键和值都是对象，并且不能包含重复键，但可以包含重复值。HashMap 允许 null key 和 null value，而 HashTable 不允许。 LinkedHashMap# 大多数情况下，只要不涉及线程安全问题，Map基本都可以使用HashMap，不过HashMap有一个问题，就是迭代HashMap的顺序并不是HashMap放置的顺序，也就是无序。HashMap的这一缺点往往会带来困扰，因为有些场景，我们期待一个有序的Map.这就是我们的LinkedHashMap, Hashtable 是线程安全 （有锁-同步机制）# HashMap 是 HashTable 的轻量级实现，他们都完成了Map 接口，主要区别在于 HashMap 允许 null key 和 null value,由于非线程安全，效率上可能高于 Hashtable。 123456789101112//get它搞成了同步方法，保证了get的安全性public synchronized V get(Object key) &#123;&#125;//synchronized,同样public synchronized V put(K key, V value) &#123;&#125;//也是搞成了同步方法public synchronized V remove(Object key) &#123;&#125; ConcurrentHashMap和Hashtable的区别# ConcurrentHashMap基于内存屏障（Volatile）实现，而HashTable基于同步锁性能相对较低 它们都可以用于多线程的环境，但是当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。因为ConcurrentHashMap引入了分割(segmentation)，不论它变得多么大，仅仅需要锁定map的某个部分，而其它的线程不需要等到迭代完成才能访问map。简而言之，在迭代的过程中，ConcurrentHashMap仅仅锁定map的某个部分，而Hashtable则会锁定整个map。 扩展阅读# IBM 探索 ConcurrentHashMap 高并发性的实现机制","content":"<p>Map 集合和 Collection 集合不同，Map 集合是基于键（key）/值（value）的映射，Collection中的集合，元素是孤立存在的，向集合中存储元素采用一个个元素的方式存储；Map中的集合，元素是成对存在的，每个元素由键与值两部分组成，通过键可以找对所对应的值。</p>\n<p>Collection中的集合称为单列集合，Map中的集合称为双列集合。需要注意的是，Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。<br>\n<img src=\"/images/posts/2020/map-interface-1.png\" alt></p>\n<span id=\"more\"></span>\n<h2><span id=\"bi-jiao\">比较</span><a href=\"#bi-jiao\" class=\"header-anchor\">#</a></h2>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>HashMap</th>\n<th>TreeMap</th>\n<th>HashTable</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>实现</td>\n<td>基于哈希散列表实现</td>\n<td>SortMap接口，基于红黑树</td>\n<td>继承自Dictionary</td>\n</tr>\n<tr>\n<td>存储</td>\n<td>随机存储</td>\n<td>默认按键的升序排序</td>\n<td>随机存储</td>\n</tr>\n<tr>\n<td>遍历</td>\n<td>Iterator遍历是随机的</td>\n<td>Iterator遍历是排序的</td>\n<td>Enumeration和Iterator</td>\n</tr>\n<tr>\n<td>性能损耗</td>\n<td>几乎无</td>\n<td>插入、删除</td>\n<td>几乎无</td>\n</tr>\n<tr>\n<td>键值对</td>\n<td>只允许键、值均为null</td>\n<td>键、值都不能为null</td>\n<td>不允许null</td>\n</tr>\n<tr>\n<td>线程安全</td>\n<td>否</td>\n<td>否</td>\n<td>是</td>\n</tr>\n<tr>\n<td>效率</td>\n<td>高</td>\n<td>低</td>\n<td>高</td>\n</tr>\n</tbody>\n</table>\n<p>一般情况下我们选用HashMap，因为HashMap的键值对在取出时是随机的，其依据键的hashCode和键的equals方法存取数据，具有很快的访问速度，所以在Map中插入、删除及索引元素时其是效率最高的实现。而TreeMap的键值对在取出时是排过序的，所以效率会低点。</p>\n<h2><span id=\"hashtable\">HashTable</span><a href=\"#hashtable\" class=\"header-anchor\">#</a></h2>\n<p>散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存储存位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。</p>\n<h3><span id=\"hashmap-he-hashtable-de-qu-bie\">HashMap和hashtable的区别</span><a href=\"#hashmap-he-hashtable-de-qu-bie\" class=\"header-anchor\">#</a></h3>\n<ul>\n<li>HashMap允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许</li>\n<li>HashMap 把 Hashtable 的 contains 方法去掉了，改成 containsValue 和 containsKey。因为 contains 方法容易让人引起误解。</li>\n<li>HashTable 继承自 Dictionary 类，而HashMap是Java1.2 引进的 Map interface 的一个实现</li>\n<li>HashTable 的方法是 Synchronize 的，而HashMap不是，在多个线程访问 Hashtable 时，不需要自己为它的方法实现同步，而 HashMap 就必须为之提供外同步</li>\n<li>Hashtable 和 HashMap 采用的 hash/rehash 算法都大概一样，所以性能不会有很大的差异</li>\n</ul>\n<h3><span id=\"hashmap-bu-shi-xian-cheng-an-quan-de-mei-you-suo\">HashMap 不是线程安全的（没有锁）</span><a href=\"#hashmap-bu-shi-xian-cheng-an-quan-de-mei-you-suo\" class=\"header-anchor\">#</a></h3>\n<p>HashMap 是 map 接口的实现类，是将键映射到值的对象，其中键和值都是对象，并且不能包含重复键，但可以包含重复值。HashMap 允许 null key 和 null value，而 HashTable 不允许。</p>\n<h3><span id=\"linkedhashmap\">LinkedHashMap</span><a href=\"#linkedhashmap\" class=\"header-anchor\">#</a></h3>\n<p>大多数情况下，只要不涉及线程安全问题，Map基本都可以使用HashMap，不过HashMap有一个问题，就是迭代HashMap的顺序并不是HashMap放置的顺序，也就是无序。HashMap的这一缺点往往会带来困扰，因为有些场景，我们期待一个有序的Map.这就是我们的LinkedHashMap,</p>\n<h3><span id=\"hashtable-shi-xian-cheng-an-quan-you-suo-tong-bu-ji-zhi\">Hashtable 是线程安全 （有锁-同步机制）</span><a href=\"#hashtable-shi-xian-cheng-an-quan-you-suo-tong-bu-ji-zhi\" class=\"header-anchor\">#</a></h3>\n<p>HashMap 是 HashTable 的轻量级实现，他们都完成了Map 接口，主要区别在于 HashMap 允许 null key 和 null value,由于非线程安全，效率上可能高于 Hashtable。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//get它搞成了同步方法，保证了get的安全性</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//synchronized,同样</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//也是搞成了同步方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> V <span class=\"title\">remove</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"concurrenthashmap-he-hashtable-de-qu-bie\">ConcurrentHashMap和Hashtable的区别</span><a href=\"#concurrenthashmap-he-hashtable-de-qu-bie\" class=\"header-anchor\">#</a></h3>\n<p>ConcurrentHashMap基于内存屏障（Volatile）实现，而HashTable基于同步锁性能相对较低</p>\n<p>它们都可以用于多线程的环境，但是当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。因为ConcurrentHashMap引入了分割(segmentation)，不论它变得多么大，仅仅需要锁定map的某个部分，而其它的线程不需要等到迭代完成才能访问map。简而言之，在迭代的过程中，ConcurrentHashMap仅仅锁定map的某个部分，而Hashtable则会锁定整个map。</p>\n<h2><span id=\"kuo-zhan-yue-du\">扩展阅读</span><a href=\"#kuo-zhan-yue-du\" class=\"header-anchor\">#</a></h2>\n<ol>\n<li><a href=\"https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/index.html\">IBM 探索 ConcurrentHashMap 高并发性的实现机制</a></li>\n</ol>\n<link rel=\"stylesheet\" href=\"/css/markmap.css\" type=\"text/css\">","tags":[{"name":"原理","slug":"原理","permalink":"https://blog.beyhub.com/tags/%E5%8E%9F%E7%90%86/"}]},{"title":"JDBC ORM模型基于JAVA操作数据库","path":"post/jdbc-orm模型基于java操作数据库/","text":"在我们日常的开发过程中，肯定不可避免的会使用到数据库以及 SQL 语句。比如，刚开始学习 Java 的时候可能会遇到 JDBC，它是连接 Java 和数据库的桥梁，我们可以使用 JDBC 来建立与数据库之间的连接并且执行相应的 SQL 语句。虽然 JDBC 的执行效率很高，但是其开发效率比较低。正是如此，市面上出现了一大批 ORM（对象关系映射）框架，例如 Hibernate，iBATIS 以及本文将要介绍的 MyBatis。 JDBC# JDBC (Java Database Connectivity) API，即Java数据库编程接口，是一组标准的Java语言中的接口和类，使用这些接口和类，Java客户端程序可以访问各种不同类型的数据库。比如建立数据库连接、执行SQL语句进行数据的存取操作。 实现步骤 使用JDBC编程需要连接数据库，注册驱动和数据库信息 操作Connection，打开 Statement 对象 通过Statement执行SQL， 返回结果到ResultSet对象 使用ResultSet读取数据，然后通过代码转化为具体的POJO对象 关闭数据库的相关资源 优点 直接底层操作，提供了很简单、便捷的访问数据库的方法，跨平台性比较强。 灵活性比较强。可以写很复杂的SQL语句。 缺点 工作量相对较大。我们需要先连接，然后处理JDBC底层事务，处理数据类型。 我们还需要操作Connection对象、Statement对象和ResultSet对象去拿到数据，并准确的关闭它们。 ORM# 由于JDBC存在的缺陷，所以我们在实际工作中很少使用JDBC进行操作数据库的编程。于是我们就提出了对象关系映射（Object Relational Mapping）简称 ORM，或者O/RM，或者 O/R mapping。 ORM模型就是数据库的表和简单Java对象（Plain Ordinary Java Object，简称POJO）的映射关系模型。 它主要解决数据库数据和POJO对象的相互映射。我们通过这层映射就可以简单的把数据库表的数据转化为POJO。以便程序员更加容易的理解和应用Java程序.而且程序员一般只需要了解Java应用而无需对数据库进行深入的了解。此外，ORM模型提供了统一的规则使得数据库的数据通过配置便可轻易的映射到POJO上。常用的ORM框架 Java ORM# MyBatis# MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 优点 易于上手和掌握。 sql写在xml里，便于统一管理和优化。 解除sql与程序代码的耦合。 提供映射标签，支持对象与数据库的orm字段关系映射提供对象关系映射标签，支持对象关系组建维护提供xml标签，支持编写动态sql。 缺点 sql工作量很大，尤其是字段多、关联表多时，更是如此。 sql依赖于数据库，导致数据库移植性差。 由于xml里标签id必须唯一，导致DAO中方法不支持方法重载。 字段映射标签和对象关系映射标签仅仅是对映射关系的描述，具体实现仍然依赖于sql。（比如配置了一对多Collection标签，如果sql里没有join子表或查询子表的话，查询后返回的对象是不具备对象关系的，即Collection的对象为null） DAO层过于简单，对象组装的工作量较大。 不支持级联更新、级联删除。 编写动态sql时,不方便调试，尤其逻辑复杂时。 提供的写动态sql的xml标签功能简单（连struts都比不上），编写动态sql仍然受限，且可读性低。 若不查询主键字段，容易造成查询出的对象有“覆盖”现象。参数的数据类型支持不完善。（如参数为Date类型时，容易报没有get、set方法，需在参数上加@param） 多参数时，使用不方便，功能不够强大。（目前支持的方法有map、对象、注解@param以及默认采用012索引位的方式） 缓存使用不当，容易产生脏数据。 Hibernate# Hibernate是一种Java语言下的对象关系映射(ORM)解决方案。它是使用GNU宽通用公共许可证发行的自由、开源的软件。它为面向对象的领域模型到传统的关系型数据库的映射，提供了一个使用方便的持久化框架。 优点 消除了代码的映射规则，它全部被分离到XML或者注解里面去配置。 无需再管理数据库连接，它也配置到XML里面。 一个会话中，不要操作多个对象，只要操作Sesison即可。 关闭资源只需要关闭一个Session即可。 缺点 全表映射带来的不便，比如更新时需要发送所有的字段。 无法根据不同的条件组装不同的SQL。 对多表关联和复杂的SQL查询支持较差。 需要自己写SQL，返回后，需要自己将数据组装到POJO中。 不能有效支持存储过程。虽然有HQL，但是性能较差，大型互联网往往需要优化SQL，而Hibernate做不到。 框架选择# Hibernate作为Java ORM框架，它确实编程简易，需要我们提供映射的规则，完全可以通过IDE生成。同时无需编写SQL确实开发效率优于MyBatis。而且，它也提供了缓存、日志、级联、等强大的功能，但是Hibernate的缺陷也是十分的明显的。就是在多表关联复杂的SQL时，数据系统权限限制时，根据条件变化的SQL时。存储过程等使用场景。Hibernate十分不便。而性能又难以通过SQL来优化。所以Hibernate一般只适用于场景不太复杂的、性能要求不太苛刻的时候使用。 MyBatis 是一个灵活的、可以动态生成映射关系的框架，它几乎可以替代JDBC。拥有动态列、动态表名，存储过程都支持。同时提供了简易的缓存（如(默认)一级缓存，还有二级缓存）、日志、级联。但是它的缺陷是需要你提供映射规则和SQL，所以它的开发工作量一般要比Hibernate略大一些。 但总体来说，MyBatis具有高度灵活、可优化、易维护等特点, 所以目前还是myBatis比较合适我们。","content":"<p>在我们日常的开发过程中，肯定不可避免的会使用到数据库以及 SQL 语句。比如，刚开始学习 Java 的时候可能会遇到 JDBC，它是连接 Java 和数据库的桥梁，我们可以使用 JDBC 来建立与数据库之间的连接并且执行相应的 SQL 语句。虽然 JDBC 的执行效率很高，但是其开发效率比较低。正是如此，市面上出现了一大批 ORM（对象关系映射）框架，例如 Hibernate，iBATIS 以及本文将要介绍的 MyBatis。</p>\n<span id=\"more\"></span>\n<h2><span id=\"jdbc\">JDBC</span><a href=\"#jdbc\" class=\"header-anchor\">#</a></h2>\n<p>JDBC (Java Database Connectivity) API，即Java数据库编程接口，是一组标准的Java语言中的接口和类，使用这些接口和类，Java客户端程序可以访问各种不同类型的数据库。比如建立数据库连接、执行SQL语句进行数据的存取操作。</p>\n<p><strong>实现步骤</strong></p>\n<ol>\n<li>使用JDBC编程需要连接数据库，注册驱动和数据库信息</li>\n<li>操作Connection，打开 Statement 对象</li>\n<li>通过Statement执行SQL， 返回结果到ResultSet对象</li>\n<li>使用ResultSet读取数据，然后通过代码转化为具体的POJO对象</li>\n<li>关闭数据库的相关资源</li>\n</ol>\n<p><strong>优点</strong></p>\n<ol>\n<li>直接底层操作，提供了很简单、便捷的访问数据库的方法，跨平台性比较强。</li>\n<li>灵活性比较强。可以写很复杂的SQL语句。</li>\n</ol>\n<p><strong>缺点</strong></p>\n<ol>\n<li>工作量相对较大。我们需要先连接，然后处理JDBC底层事务，处理数据类型。</li>\n<li>我们还需要操作Connection对象、Statement对象和ResultSet对象去拿到数据，并准确的关闭它们。</li>\n</ol>\n<h2><span id=\"orm\">ORM</span><a href=\"#orm\" class=\"header-anchor\">#</a></h2>\n<p>由于JDBC存在的缺陷，所以我们在实际工作中很少使用JDBC进行操作数据库的编程。于是我们就提出了对象关系映射（Object Relational Mapping）简称 ORM，或者O/RM，或者 O/R mapping。</p>\n<p>ORM模型就是数据库的表和简单Java对象（Plain Ordinary Java Object，简称POJO）的映射关系模型。   它主要解决数据库数据和POJO对象的相互映射。我们通过这层映射就可以简单的把数据库表的数据转化为POJO。以便程序员更加容易的理解和应用Java程序.而且程序员一般只需要了解Java应用而无需对数据库进行深入的了解。此外，ORM模型提供了统一的规则使得数据库的数据通过配置便可轻易的映射到POJO上。常用的ORM框架</p>\n<h3><span id=\"java-orm\">Java ORM</span><a href=\"#java-orm\" class=\"header-anchor\">#</a></h3>\n<h4><span id=\"mybatis\">MyBatis</span><a href=\"#mybatis\" class=\"header-anchor\">#</a></h4>\n<p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p>\n<p><strong>优点</strong></p>\n<ol>\n<li>易于上手和掌握。</li>\n<li>sql写在xml里，便于统一管理和优化。</li>\n<li>解除sql与程序代码的耦合。</li>\n<li>提供映射标签，支持对象与数据库的orm字段关系映射提供对象关系映射标签，支持对象关系组建维护提供xml标签，支持编写动态sql。</li>\n</ol>\n<p><strong>缺点</strong></p>\n<ol>\n<li>sql工作量很大，尤其是字段多、关联表多时，更是如此。</li>\n<li>sql依赖于数据库，导致数据库移植性差。</li>\n<li>由于xml里标签id必须唯一，导致DAO中方法不支持方法重载。</li>\n<li>字段映射标签和对象关系映射标签仅仅是对映射关系的描述，具体实现仍然依赖于sql。（比如配置了一对多Collection标签，如果sql里没有join子表或查询子表的话，查询后返回的对象是不具备对象关系的，即Collection的对象为null）</li>\n<li>DAO层过于简单，对象组装的工作量较大。</li>\n<li>不支持级联更新、级联删除。</li>\n<li>编写动态sql时,不方便调试，尤其逻辑复杂时。</li>\n<li>提供的写动态sql的xml标签功能简单（连struts都比不上），编写动态sql仍然受限，且可读性低。</li>\n<li>若不查询主键字段，容易造成查询出的对象有“覆盖”现象。参数的数据类型支持不完善。（如参数为Date类型时，容易报没有get、set方法，需在参数上加@param）</li>\n<li>多参数时，使用不方便，功能不够强大。（目前支持的方法有map、对象、注解@param以及默认采用012索引位的方式）</li>\n<li>缓存使用不当，容易产生脏数据。</li>\n</ol>\n<h4><span id=\"hibernate\">Hibernate</span><a href=\"#hibernate\" class=\"header-anchor\">#</a></h4>\n<p>Hibernate是一种Java语言下的对象关系映射(ORM)解决方案。它是使用GNU宽通用公共许可证发行的自由、开源的软件。它为面向对象的领域模型到传统的关系型数据库的映射，提供了一个使用方便的持久化框架。</p>\n<p><strong>优点</strong></p>\n<ol>\n<li>消除了代码的映射规则，它全部被分离到XML或者注解里面去配置。</li>\n<li>无需再管理数据库连接，它也配置到XML里面。</li>\n<li>一个会话中，不要操作多个对象，只要操作Sesison即可。</li>\n<li>关闭资源只需要关闭一个Session即可。</li>\n</ol>\n<p><strong>缺点</strong></p>\n<ol>\n<li>全表映射带来的不便，比如更新时需要发送所有的字段。</li>\n<li>无法根据不同的条件组装不同的SQL。</li>\n<li>对多表关联和复杂的SQL查询支持较差。</li>\n<li>需要自己写SQL，返回后，需要自己将数据组装到POJO中。</li>\n<li>不能有效支持存储过程。虽然有HQL，但是性能较差，大型互联网往往需要优化SQL，而Hibernate做不到。</li>\n</ol>\n<h3><span id=\"kuang-jia-xuan-ze\">框架选择</span><a href=\"#kuang-jia-xuan-ze\" class=\"header-anchor\">#</a></h3>\n<p>Hibernate作为Java ORM框架，它确实编程简易，需要我们提供映射的规则，完全可以通过IDE生成。同时无需编写SQL确实开发效率优于MyBatis。而且，它也提供了缓存、日志、级联、等强大的功能，但是Hibernate的缺陷也是十分的明显的。就是在多表关联复杂的SQL时，数据系统权限限制时，根据条件变化的SQL时。存储过程等使用场景。Hibernate十分不便。而性能又难以通过SQL来优化。所以Hibernate一般只适用于场景不太复杂的、性能要求不太苛刻的时候使用。</p>\n<p>MyBatis 是一个灵活的、可以动态生成映射关系的框架，它几乎可以替代JDBC。拥有动态列、动态表名，存储过程都支持。同时提供了简易的缓存（如(默认)一级缓存，还有二级缓存）、日志、级联。但是它的缺陷是需要你提供映射规则和SQL，所以它的开发工作量一般要比Hibernate略大一些。</p>\n<p>但总体来说，MyBatis具有高度灵活、可优化、易维护等特点, 所以目前还是myBatis比较合适我们。</p>\n<link rel=\"stylesheet\" href=\"/css/markmap.css\" type=\"text/css\">","tags":[{"name":"数据库","slug":"数据库","permalink":"https://blog.beyhub.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"MySQL","permalink":"https://blog.beyhub.com/tags/MySQL/"}]},{"title":"Hadoop基础知识","path":"post/hadoop基础知识/","text":"Apache Hadoop是一款支持数据密集型分布式应用程序并以Apache 2.0许可协议发布的开源软件框架。它支持在商品硬件构建的大型集群上运行的应用程序。Hadoop是根据谷歌公司发表的MapReduce和Google文件系统的论文自行实现而成。所有的Hadoop模块都有一个基本假设，即硬件故障是常见情况，应该由框架自动处理。 Hadoop框架透明地为应用提供可靠性和数据移动。它实现了名为MapReduce的编程范式：应用程序被分割成许多小部分，而每个部分都能在集群中的任意节点上运行或重新运行。此外，Hadoop还提供了分布式文件系统，用以存储所有计算节点的数据，这为整个集群带来了非常高的带宽。MapReduce和分布式文件系统的设计，使得整个框架能够自动处理节点故障。它使应用程序与成千上万的独立计算的电脑和PB级的数据连接起来。现在普遍认为整个Apache Hadoop“平台”包括Hadoop内核、MapReduce、Hadoop分布式文件系统（HDFS）以及一些相关项目，有Apache Hive和Apache HBase等等。 MapReduce# MapReduce是一种编程模型，用于大规模数据集（大于1TB）的并行运算。 概念&quot;Map（映射）“和&quot;Reduce（归约）”，是它们的主要思想，都是从函数式编程语言里借来的，还有从矢量编程语言里借来的特性。 它极大地方便了编程人员在不会分布式并行编程的情况下，将自己的程序运行在分布式系统上。开发人员必须基于MapReduce编程模型进行编程开发，然后将程序通过MapReduce计算框架分发到Hadoop集群中运行。 ETL（Extract-Transform-Load）# ETL，Extraction-Transformation-Loading的缩写，中文名为数据抽取、转换和加载。ETL负责将分布的、异构数据源中的数据如关系数据、平面数据文件等抽取到临时中间层后进行清洗、转换、集成，最后加载到数据仓库或数据集市中，成为联机分析处理、数据挖掘的基础。ETL是BI项目最重要的一个环节，通常情况下ETL会花掉整个项目的1/3的时间，ETL设计的好坏直接关接到BI项目的成败。ETL也是一个长期的过程，只有不断的发现问题并解决问题，才能使ETL运行效率更高，为项目后期开发提供准确的数据。 相关项目# Apache HBase：分布式NoSQL列数据库，类似谷歌公司BigTable。 Apache Hive：构建于hadoop之上的数据仓库，通过一种类SQL语言HiveQL为用户提供数据的归纳、查询和分析等功能。Hive最初由Facebook贡献。 Apache Mahout：机器学习算法软件包。 Apache Sqoop：结构化数据（如关系数据库）与Apache Hadoop之间的数据转换工具。 Apache ZooKeeper：分布式锁设施，提供类似Google Chubby的功能，由Facebook贡献。 Apache Avro：新的数据序列化格式与传输工具，将逐步取代Hadoop原有的IPC机制。 Hive 和 HBase的联系和区别# 区别# Apache Hive是一个构建在Hadoop基础设施之上的数据仓库。通过Hive可以使用HQL语言查询存放在HDFS上的数据。HQL是一种类SQL语言，这种语言最终被转化为Map/Reduce. 虽然Hive提供了SQL查询功能，但是Hive不能够进行交互查询–因为它只能够在Haoop上批量的执行Hadoop。 Apache HBase是一种Key/Value系统，它运行在HDFS之上。和Hive不一样，Hbase的能够在它的数据库上实时运行，而不是运行MapReduce任务。Hive被分区为表格，表格又被进一步分割为列簇。列簇必须使用schema定义，列簇将某一类型列集合起来（列不要求schema定义）。例如，“message”列簇可能包含：“to”, ”from” “date”, “subject”, 和”body”. 每一个 key/value对在Hbase中被定义为一个cell，每一个key由row-key，列簇、列和时间戳。在Hbase中，行是key/value映射的集合，这个映射通过row-key来唯一标识。Hbase利用Hadoop的基础设施，可以利用通用的设备进行水平的扩展。 Hive和Hbase是两种基于Hadoop的不同技术–Hive是一种类SQL的引擎，并且运行MapReduce任务，Hbase是一种在Hadoop之上的NoSQL 的Key/vale数据库。当然，这两种工具是可以同时使用的。就像用Google来搜索，用FaceBook进行社交一样，Hive可以用来进行统计查询，HBase可以用来进行实时查询，数据也可以从Hive写到Hbase，设置再从Hbase写回Hive。 可以用Google搜索引擎的爬虫和实时数据库索引来理解。 特点# Hive帮助熟悉SQL的人运行MapReduce任务。因为它是JDBC兼容的，同时，它也能够和现存的SQL工具整合在一起。运行Hive查询会花费很长时间，因为它会默认遍历表中所有的数据。虽然有这样的缺点，一次遍历的数据量可以通过Hive的分区机制来控制。分区允许在数据集上运行过滤查询，这些数据集存储在不同的文件夹内，查询的时候只遍历指定文件夹（分区）中的数据。这种机制可以用来，例如，只处理在某一个时间范围内的文件，只要这些文件名中包括了时间格式。 HBase通过存储key/value来工作。它支持四种主要的操作：增加或者更新行，查看一个范围内的cell，获取指定的行，删除指定的行、列或者是列的版本。版本信息用来获取历史数据（每一行的历史数据可以被删除，然后通过Hbase compactions就可以释放出空间）。虽然HBase包括表格，但是schema仅仅被表格和列簇所要求，列不需要schema。Hbase的表格包括增加/计数功能。 场景# Hive适合用来对一段时间内的数据进行分析查询，例如，用来计算趋势或者网站的日志。Hive不应该用来进行实时的查询。因为它需要很长时间才可以返回结果。Hbase非常适合用来进行大数据的实时查询。Facebook用Hbase进行消息和实时的分析。它也可以用来统计Facebook的连接数。 扩展阅读# 官方网站：https://hadoop.apache.org/","content":"<p>Apache Hadoop是一款支持数据密集型分布式应用程序并以Apache 2.0许可协议发布的开源软件框架。它支持在商品硬件构建的大型集群上运行的应用程序。Hadoop是根据谷歌公司发表的MapReduce和Google文件系统的论文自行实现而成。所有的Hadoop模块都有一个基本假设，即硬件故障是常见情况，应该由框架自动处理。</p>\n<p><img src=\"/images/posts/2020/hadoop-eco.jpg\" alt></p>\n<span id=\"more\"></span>\n<p>Hadoop框架透明地为应用提供可靠性和数据移动。它实现了名为MapReduce的编程范式：应用程序被分割成许多小部分，而每个部分都能在集群中的任意节点上运行或重新运行。此外，Hadoop还提供了分布式文件系统，用以存储所有计算节点的数据，这为整个集群带来了非常高的带宽。MapReduce和分布式文件系统的设计，使得整个框架能够自动处理节点故障。它使应用程序与成千上万的独立计算的电脑和PB级的数据连接起来。现在普遍认为整个Apache Hadoop“平台”包括Hadoop内核、MapReduce、Hadoop分布式文件系统（HDFS）以及一些相关项目，有Apache Hive和Apache HBase等等。</p>\n<h2><span id=\"mapreduce\">MapReduce</span><a href=\"#mapreduce\" class=\"header-anchor\">#</a></h2>\n<p>MapReduce是一种编程模型，用于大规模数据集（大于1TB）的并行运算。 概念&quot;Map（映射）“和&quot;Reduce（归约）”，是它们的主要思想，都是从函数式编程语言里借来的，还有从矢量编程语言里借来的特性。 它极大地方便了编程人员在不会分布式并行编程的情况下，将自己的程序运行在分布式系统上。开发人员必须基于MapReduce编程模型进行编程开发，然后将程序通过MapReduce计算框架分发到Hadoop集群中运行。</p>\n<h2><span id=\"etl-extract-transform-load\">ETL（Extract-Transform-Load）</span><a href=\"#etl-extract-transform-load\" class=\"header-anchor\">#</a></h2>\n<p>ETL，Extraction-Transformation-Loading的缩写，中文名为数据抽取、转换和加载。ETL负责将分布的、异构数据源中的数据如关系数据、平面数据文件等抽取到临时中间层后进行清洗、转换、集成，最后加载到数据仓库或数据集市中，成为联机分析处理、数据挖掘的基础。ETL是BI项目最重要的一个环节，通常情况下ETL会花掉整个项目的1/3的时间，ETL设计的好坏直接关接到BI项目的成败。ETL也是一个长期的过程，只有不断的发现问题并解决问题，才能使ETL运行效率更高，为项目后期开发提供准确的数据。</p>\n<h2><span id=\"xiang-guan-xiang-mu\">相关项目</span><a href=\"#xiang-guan-xiang-mu\" class=\"header-anchor\">#</a></h2>\n<ul>\n<li>Apache HBase：分布式NoSQL列数据库，类似谷歌公司BigTable。</li>\n<li>Apache Hive：构建于hadoop之上的数据仓库，通过一种类SQL语言HiveQL为用户提供数据的归纳、查询和分析等功能。Hive最初由Facebook贡献。</li>\n<li>Apache Mahout：机器学习算法软件包。</li>\n<li>Apache Sqoop：结构化数据（如关系数据库）与Apache Hadoop之间的数据转换工具。</li>\n<li>Apache ZooKeeper：分布式锁设施，提供类似Google Chubby的功能，由Facebook贡献。</li>\n<li>Apache Avro：新的数据序列化格式与传输工具，将逐步取代Hadoop原有的IPC机制。</li>\n</ul>\n<h3><span id=\"hive-he-hbase-de-lian-xi-he-qu-bie\">Hive 和 HBase的联系和区别</span><a href=\"#hive-he-hbase-de-lian-xi-he-qu-bie\" class=\"header-anchor\">#</a></h3>\n<h4><span id=\"qu-bie\">区别</span><a href=\"#qu-bie\" class=\"header-anchor\">#</a></h4>\n<p>Apache Hive是一个构建在Hadoop基础设施之上的数据仓库。通过Hive可以使用HQL语言查询存放在HDFS上的数据。HQL是一种类SQL语言，这种语言最终被转化为Map/Reduce. 虽然Hive提供了SQL查询功能，但是Hive不能够进行交互查询–因为它只能够在Haoop上批量的执行Hadoop。</p>\n<p>Apache HBase是一种Key/Value系统，它运行在HDFS之上。和Hive不一样，Hbase的能够在它的数据库上实时运行，而不是运行MapReduce任务。Hive被分区为表格，表格又被进一步分割为列簇。列簇必须使用schema定义，列簇将某一类型列集合起来（列不要求schema定义）。例如，“message”列簇可能包含：“to”, ”from” “date”, “subject”, 和”body”. 每一个 key/value对在Hbase中被定义为一个cell，每一个key由row-key，列簇、列和时间戳。在Hbase中，行是key/value映射的集合，这个映射通过row-key来唯一标识。Hbase利用Hadoop的基础设施，可以利用通用的设备进行水平的扩展。</p>\n<p>Hive和Hbase是两种基于Hadoop的不同技术–Hive是一种类SQL的引擎，并且运行MapReduce任务，Hbase是一种在Hadoop之上的NoSQL 的Key/vale数据库。当然，这两种工具是可以同时使用的。就像用Google来搜索，用FaceBook进行社交一样，Hive可以用来进行统计查询，HBase可以用来进行实时查询，数据也可以从Hive写到Hbase，设置再从Hbase写回Hive。</p>\n<p>可以用Google搜索引擎的爬虫和实时数据库索引来理解。</p>\n<h4><span id=\"te-dian\">特点</span><a href=\"#te-dian\" class=\"header-anchor\">#</a></h4>\n<p>Hive帮助熟悉SQL的人运行MapReduce任务。因为它是JDBC兼容的，同时，它也能够和现存的SQL工具整合在一起。运行Hive查询会花费很长时间，因为它会默认遍历表中所有的数据。虽然有这样的缺点，一次遍历的数据量可以通过Hive的分区机制来控制。分区允许在数据集上运行过滤查询，这些数据集存储在不同的文件夹内，查询的时候只遍历指定文件夹（分区）中的数据。这种机制可以用来，例如，只处理在某一个时间范围内的文件，只要这些文件名中包括了时间格式。</p>\n<p>HBase通过存储key/value来工作。它支持四种主要的操作：增加或者更新行，查看一个范围内的cell，获取指定的行，删除指定的行、列或者是列的版本。版本信息用来获取历史数据（每一行的历史数据可以被删除，然后通过Hbase compactions就可以释放出空间）。虽然HBase包括表格，但是schema仅仅被表格和列簇所要求，列不需要schema。Hbase的表格包括增加/计数功能。</p>\n<h4><span id=\"chang-jing\">场景</span><a href=\"#chang-jing\" class=\"header-anchor\">#</a></h4>\n<p>Hive适合用来对一段时间内的数据进行分析查询，例如，用来计算趋势或者网站的日志。Hive不应该用来进行实时的查询。因为它需要很长时间才可以返回结果。Hbase非常适合用来进行大数据的实时查询。Facebook用Hbase进行消息和实时的分析。它也可以用来统计Facebook的连接数。</p>\n<h2><span id=\"kuo-zhan-yue-du\">扩展阅读</span><a href=\"#kuo-zhan-yue-du\" class=\"header-anchor\">#</a></h2>\n<ol>\n<li>官方网站：<a href=\"https://hadoop.apache.org/\">https://hadoop.apache.org/</a></li>\n</ol>\n<link rel=\"stylesheet\" href=\"/css/markmap.css\" type=\"text/css\">","tags":[{"name":"大数据","slug":"大数据","permalink":"https://blog.beyhub.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"分布式","slug":"分布式","permalink":"https://blog.beyhub.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"}]},{"title":"MySQL索引底层的数据结构与算法","path":"post/mysql索引底层的数据结构与算法/","text":"索引是帮助MySQL高效获取数据的排好序的数据结构，由于以上实现的数据结构与数据库中索引相关，关于索引，有以下知识： 唯一索引：唯一索引不允许两行具有相同的索引值 主键索引：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。 主键索引要求主键中的每个值是唯一的，并且不能为空 聚集索引（Clustered)：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有一个 非聚集索引（Non-clustered)：非聚集索引指定表的逻辑顺序。 数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针可以有多个（小于 249 个） 索引数据结构# 二叉树# 左边子节点的数据小于父节点数据，右边子节点的数据大于父节点数据。如果col2是索引，查找索引为89的行元素，那么只需要查找两次，就可以获取到行元素所在的磁盘指针地址。 如果col1是索引，查找索引为6的行元素，那么需要查找六次，就可以获取到行元素所在的磁盘指针地址，即得到了该索引为6的行元素。因此二叉树不适合存储单边增长的序列字段，近乎全表扫描获取数据。 红黑树# 本质二叉树，属于二叉平衡树，jdk1.8 hashmap的底层实现；存储大数据量，树的高度不可控， 数量越大，树的高度越高；500w行数据，2的n次方=500w数据量， n是树的高度，也就是查询次数； hash表# 通过散列可以快速获取磁盘文件指针，对于指定索引查找文件非常快，但是对于范围查找没法支持。 B树# 本质是多路二叉树；叶节点具有相同的深度，叶节点的指针为空；所有索引元素不重复；节点中数据索引从左到右依次递增的； B+树（B树的变种）# 非叶子节点不存储数据，只存储索引(冗余)和指针，可以放更多的索引，树高降低 ；叶子节点包含所有索引字段；叶子节点比b树增加了指针连接；叶子节点有双向指针链接(首尾子节点还通过指针连接)，提高区间访问的性能，范围查找； 为什么mysql页文件默认16K？ MySQL每个B+树节点最大存储容量：16KB （指针+数据+索引）。假设我们一行数据大小为1K，那么一页就能存16条数据，也就是一个叶子节点能存16条数据；再看非叶子节点，假设主键ID为bigint类型，那么长度为8B，指针大小在Innodb源码中为6B，一共就是14B，那么一页里就可以存储16K/14=1170个(主键+指针)那么一颗高度为2的B+树能存储的数据为：117016=18720条，一颗高度为3的B+树能存储的数据为：11701170*16=21902400（千万级条） 1show global status like `Innodb_page_size` 因此，B+树存储大数据量的表也可以非常高效的获取数据，MySQL使用B+树作为索引的数据结构。 存储引擎# InnoDB（聚集）# 表数据文件本身是按照B+tree组织的一个索引结构文件frm文件：存储这张表的表结构ibd文件：存储这张表的所有数据行和索引字段聚集(聚簇)索引----叶节点包含完整数据记录 为什么InnoDB表必须有主键，并且推荐使用整型的自增主键？ 首先，为了满足MySQL的索引数据结构B+树的特性，必须要有索引作为主键，可以有效提高查询效率，因此InnoDB必须要有主键。如果不手动指定主键，InnoDB会从插入的数据中找出不重复的一列作为主键索引，如果没找到不重复的一列，InnoDB会在后台增加一列rowId做为主键索引。 其次，索引的数据类型是整型，一方面整型占有的磁盘空间或内存空间相比字符串更少，另一方面整型比较比字符串比较更快速，字符串比较是先转换为ASCII码，然后再比较的。 最后，B+树本质是多路多叉树，如果主键索引不是自增的，那么后续插入的索引就会引起B+树的其他节点的分裂和重新平衡，影响数据插入的效率，如果是自增主键，只用在尾节点做增加就可以。 为什么非主键索引结构叶子节点存储的是主键值？ 主键索引和非主键索引维护各自的B+树结构，当插入的数据的时候，由于数据只有一份，通过非主键索引获取到主键值，然后再去主键索引的B+树数据结构中找到对应的行数据，节省了内存空间； 如果非主键索引的叶子节点也存储一份数据，如果通过非主键索引插入数据，那么要向主键索引对应的行数据进行同步，那么会带来数据一致性问题。可以通过事务的方式解决，我们都知道使用事务后，就会对性能有所消耗。 联合索引 两个或更多个列上的索引被称作联合索引，联合索引又叫复合索引。对于复合索引:Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。 例如索引是key index (a,b,c). 可以支持a | a,b| a,b,c 3种组合进行查找，但不支持 b,c进行查找 .当最左侧字段是常量引用时，索引就十分有效。 MyISAM和InnoDB的9大区别# InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务； InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败； InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。也就是说：InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。 InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快； Innodb不支持全文索引（5.7以后支持），而MyISAM支持全文索引，查询效率上MyISAM要高 MyISAM表格可以被压缩后进行查询操作 InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁InnoDB的行锁是实现在索引上的，而不是锁在物理行记录上。潜台词是，如果访问没有命中索引，也无法使用行锁，将要退化为表锁。 InnoDB表必须有主键（用户没有指定的话会自己找或生产一个主键），而Myisam可以没有 Innodb存储文件有frm、ibd，而Myisam是frm、MYD、MYIInnodb：frm是表定义文件，ibd是数据文件Myisam：frm是表定义文件，myd是数据文件，myi是索引文件 扩展阅读# MySQL索引背后的数据结构及算法原理 http://blog.codinglabs.org/articles/theory-of-mysql-index.html","content":"<p>索引是帮助MySQL高效获取数据的排好序的数据结构，由于以上实现的数据结构与数据库中索引相关，关于索引，有以下知识：</p>\n<ol>\n<li>唯一索引：唯一索引不允许两行具有相同的索引值</li>\n<li>主键索引：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。<br>\n主键索引要求主键中的每个值是唯一的，并且不能为空</li>\n<li>聚集索引（Clustered)：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有一个</li>\n<li>非聚集索引（Non-clustered)：非聚集索引指定表的逻辑顺序。<br>\n数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针可以有多个（小于 249 个）</li>\n</ol>\n<span id=\"more\"></span>\n<h2><span id=\"suo-yin-shu-ju-jie-gou\">索引数据结构</span><a href=\"#suo-yin-shu-ju-jie-gou\" class=\"header-anchor\">#</a></h2>\n<h3><span id=\"er-cha-shu\">二叉树</span><a href=\"#er-cha-shu\" class=\"header-anchor\">#</a></h3>\n<p>左边子节点的数据小于父节点数据，右边子节点的数据大于父节点数据。如果col2是索引，查找索引为89的行元素，那么只需要查找两次，就可以获取到行元素所在的磁盘指针地址。</p>\n<p><img src=\"/images/posts/2020/binarytree.png\" alt></p>\n<p>如果col1是索引，查找索引为6的行元素，那么需要查找六次，就可以获取到行元素所在的磁盘指针地址，即得到了该索引为6的行元素。因此二叉树不适合存储单边增长的序列字段，近乎全表扫描获取数据。</p>\n<h3><span id=\"hong-hei-shu\">红黑树</span><a href=\"#hong-hei-shu\" class=\"header-anchor\">#</a></h3>\n<p>本质二叉树，属于二叉平衡树，jdk1.8 hashmap的底层实现；存储大数据量，树的高度不可控， 数量越大，树的高度越高；500w行数据，2的n次方=500w数据量， n是树的高度，也就是查询次数；</p>\n<h3><span id=\"hash-biao\">hash表</span><a href=\"#hash-biao\" class=\"header-anchor\">#</a></h3>\n<p>通过散列可以快速获取磁盘文件指针，对于指定索引查找文件非常快，但是对于范围查找没法支持。</p>\n<h3><span id=\"b-shu\">B树</span><a href=\"#b-shu\" class=\"header-anchor\">#</a></h3>\n<p><img src=\"/images/posts/2020/btree.png\" alt></p>\n<p>本质是多路二叉树；叶节点具有相同的深度，叶节点的指针为空；所有索引元素不重复；节点中数据索引从左到右依次递增的；</p>\n<h3><span id=\"b-shu-b-shu-de-bian-chong\">B+树（B树的变种）</span><a href=\"#b-shu-b-shu-de-bian-chong\" class=\"header-anchor\">#</a></h3>\n<p>非叶子节点不存储数据，只存储索引(冗余)和指针，可以放更多的索引，树高降低 ；叶子节点包含所有索引字段；叶子节点比b树增加了指针连接；叶子节点有双向指针链接(首尾子节点还通过指针连接)，提高区间访问的性能，范围查找；</p>\n<p><img src=\"/images/posts/2020/bplustree.png\" alt></p>\n<p><strong>为什么mysql页文件默认16K？</strong></p>\n<p>MySQL每个B+树节点最大存储容量：16KB （指针+数据+索引）。假设我们一行数据大小为1K，那么一页就能存16条数据，也就是一个叶子节点能存16条数据；再看非叶子节点，假设主键ID为bigint类型，那么长度为8B，指针大小在Innodb源码中为6B，一共就是14B，那么一页里就可以存储16K/14=1170个(主键+指针)那么一颗高度为2的B+树能存储的数据为：117016=18720条，一颗高度为3的B+树能存储的数据为：11701170*16=21902400（千万级条）</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">global</span> status <span class=\"keyword\">like</span> `Innodb_page_size`</span><br></pre></td></tr></table></figure>\n<p>因此，B+树存储大数据量的表也可以非常高效的获取数据，<strong>MySQL使用B+树作为索引的数据结构</strong>。</p>\n<h3><span id=\"cun-chu-yin-qing\">存储引擎</span><a href=\"#cun-chu-yin-qing\" class=\"header-anchor\">#</a></h3>\n<h4><span id=\"innodb-ju-ji\">InnoDB（聚集）</span><a href=\"#innodb-ju-ji\" class=\"header-anchor\">#</a></h4>\n<p>表数据文件本身是按照B+tree组织的一个索引结构文件frm文件：存储这张表的表结构ibd文件：存储这张表的所有数据行和索引字段聚集(聚簇)索引----叶节点包含完整数据记录</p>\n<p><strong>为什么InnoDB表必须有主键，并且推荐使用整型的自增主键？</strong></p>\n<p>首先，为了满足MySQL的索引数据结构B+树的特性，必须要有索引作为主键，可以有效提高查询效率，因此InnoDB必须要有主键。如果不手动指定主键，InnoDB会从插入的数据中找出不重复的一列作为主键索引，如果没找到不重复的一列，InnoDB会在后台增加一列rowId做为主键索引。</p>\n<p>其次，索引的数据类型是整型，一方面整型占有的磁盘空间或内存空间相比字符串更少，另一方面整型比较比字符串比较更快速，字符串比较是先转换为ASCII码，然后再比较的。<br>\n最后，B+树本质是多路多叉树，如果主键索引不是自增的，那么后续插入的索引就会引起B+树的其他节点的分裂和重新平衡，影响数据插入的效率，如果是自增主键，只用在尾节点做增加就可以。</p>\n<p><strong>为什么非主键索引结构叶子节点存储的是主键值？</strong></p>\n<p>主键索引和非主键索引维护各自的B+树结构，当插入的数据的时候，由于数据只有一份，通过非主键索引获取到主键值，然后再去主键索引的B+树数据结构中找到对应的行数据，节省了内存空间；<br>\n如果非主键索引的叶子节点也存储一份数据，如果通过非主键索引插入数据，那么要向主键索引对应的行数据进行同步，那么会带来数据一致性问题。可以通过事务的方式解决，我们都知道使用事务后，就会对性能有所消耗。</p>\n<p><strong>联合索引</strong></p>\n<p>两个或更多个列上的索引被称作联合索引，联合索引又叫复合索引。对于复合索引:Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。</p>\n<p>例如索引是key index (a,b,c). 可以支持a | a,b| a,b,c 3种组合进行查找，但不支持 b,c进行查找 .当最左侧字段是常量引用时，索引就十分有效。</p>\n<h4><span id=\"myisam-he-innodb-de-9-da-qu-bie\">MyISAM和InnoDB的9大区别</span><a href=\"#myisam-he-innodb-de-9-da-qu-bie\" class=\"header-anchor\">#</a></h4>\n<ol>\n<li>InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</li>\n<li>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；</li>\n<li>InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。也就是说：InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。</li>\n<li>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</li>\n<li>Innodb不支持全文索引（5.7以后支持），而MyISAM支持全文索引，查询效率上MyISAM要高</li>\n<li>MyISAM表格可以被压缩后进行查询操作</li>\n<li>InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁InnoDB的行锁是实现在索引上的，而不是锁在物理行记录上。潜台词是，如果访问没有命中索引，也无法使用行锁，将要退化为表锁。</li>\n<li>InnoDB表必须有主键（用户没有指定的话会自己找或生产一个主键），而Myisam可以没有</li>\n<li>Innodb存储文件有frm、ibd，而Myisam是frm、MYD、MYIInnodb：frm是表定义文件，ibd是数据文件Myisam：frm是表定义文件，myd是数据文件，myi是索引文件</li>\n</ol>\n<h2><span id=\"kuo-zhan-yue-du\">扩展阅读</span><a href=\"#kuo-zhan-yue-du\" class=\"header-anchor\">#</a></h2>\n<ol>\n<li>MySQL索引背后的数据结构及算法原理 <a href=\"http://blog.codinglabs.org/articles/theory-of-mysql-index.html\">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></li>\n</ol>\n<link rel=\"stylesheet\" href=\"/css/markmap.css\" type=\"text/css\">","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.beyhub.com/tags/MySQL/"}]},{"title":"Mybatis 动态SQL","path":"post/mybatis-动态sql/","text":"动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。 使用动态 SQL 并非一件易事，但借助可用于任何 SQL 映射语句中的强大的动态 SQL 语言，MyBatis 显著地提升了这一特性的易用性。 如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。 if choose (when, otherwise) trim (where, set) foreach if 元素详解# if# 使用动态 SQL 最常见情景是根据条件包含 where 子句的一部分。比如： 12345678&lt;select id=&quot;findActiveBlogWithTitleLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;if test=&quot;title != null&quot;&gt; AND title like #&#123;title&#125; &lt;/if&gt;&lt;/select&gt; 这条语句提供了可选的查找文本功能。如果不传入 “title”，那么所有处于 “ACTIVE” 状态的 BLOG 都会返回；如果传入了 “title” 参数，那么就会对 “title” 一列进行模糊查找并返回对应的 BLOG 结果（细心的读者可能会发现，“title” 的参数值需要包含查找掩码或通配符字符）。 如果希望通过 “title” 和 “author” 两个参数进行可选搜索该怎么办呢？首先，我想先将语句名称修改成更名副其实的名称；接下来，只需要加入另一个条件即可。 12345678910&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;if test=&quot;title != null&quot;&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt;&lt;/select&gt; choose、when、otherwise# 有时候，我们不想使用所有的条件，而只是想从多个条件中选择一个使用。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。 还是上面的例子，但是策略变为：传入了 “title” 就按 “title” 查找，传入了 “author” 就按 “author” 查找的情形。若两者都没有传入，就返回标记为 featured 的 BLOG（这可能是管理员认为，与其返回大量的无意义随机 Blog，还不如返回一些由管理员挑选的 Blog）。 123456789101112131415&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;choose&gt; &lt;when test=&quot;title != null&quot;&gt; AND title like #&#123;title&#125; &lt;/when&gt; &lt;when test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #&#123;author.name&#125; &lt;/when&gt; &lt;otherwise&gt; AND featured = 1 &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; trim、where、set# 前面几个例子已经合宜地解决了一个臭名昭著的动态 SQL 问题。现在回到之前的 “if” 示例，这次我们将 “state = ‘ACTIVE’” 设置成动态条件，看看会发生什么。 1234567891011121314&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE &lt;if test=&quot;state != null&quot;&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;if test=&quot;title != null&quot;&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt;&lt;/select&gt; 如果没有匹配的条件会怎么样？最终这条 SQL 会变成这样： 12SELECT * FROM BLOGWHERE 这会导致查询失败。如果匹配的只是第二个条件又会怎样？这条 SQL 会是这样: 123SELECT * FROM BLOGWHEREAND title like ‘someTitle’ 这个查询也会失败。这个问题不能简单地用条件元素来解决。这个问题是如此的难以解决，以至于解决过的人不会再想碰到这种问题。 MyBatis 有一个简单且适合大多数场景的解决办法。而在其他场景中，可以对其进行自定义以符合需求。而这，只需要一处简单的改动： 123456789101112131415&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG &lt;where&gt; &lt;if test=&quot;state != null&quot;&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;if test=&quot;title != null&quot;&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; where 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，where 元素也会将它们去除。 如果 where 元素与你期望的不太一样，你也可以通过自定义 trim 元素来定制 where 元素的功能。比如，和 where 元素等价的自定义 trim 元素为： 123&lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND |OR &quot;&gt; ...&lt;/trim&gt; prefixOverrides 属性会忽略通过管道符分隔的文本序列（注意此例中的空格是必要的）。上述例子会移除所有 prefixOverrides 属性中指定的内容，并且插入 prefix 属性中指定的内容。 用于动态更新语句的类似解决方案叫做 set。set 元素可以用于动态包含需要更新的列，忽略其它不更新的列。比如： 12345678910&lt;update id=&quot;updateAuthorIfNecessary&quot;&gt; update Author &lt;set&gt; &lt;if test=&quot;username != null&quot;&gt;username=#&#123;username&#125;,&lt;/if&gt; &lt;if test=&quot;password != null&quot;&gt;password=#&#123;password&#125;,&lt;/if&gt; &lt;if test=&quot;email != null&quot;&gt;email=#&#123;email&#125;,&lt;/if&gt; &lt;if test=&quot;bio != null&quot;&gt;bio=#&#123;bio&#125;&lt;/if&gt; &lt;/set&gt; where id=#&#123;id&#125;&lt;/update&gt; 这个例子中，set 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。 来看看与 set 元素等价的自定义 trim 元素吧： 123&lt;trim prefix=&quot;SET&quot; suffixOverrides=&quot;,&quot;&gt; ...&lt;/trim&gt; 注意，我们覆盖了后缀值设置，并且自定义了前缀值。 foreach# 动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN 条件语句的时候）。比如： 123456789&lt;select id=&quot;selectPostIn&quot; resultType=&quot;domain.blog.Post&quot;&gt; SELECT * FROM POST P WHERE ID in &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;list&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt; #&#123;item&#125; &lt;/foreach&gt;&lt;/select&gt; foreach 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。这个元素也不会错误地添加多余的分隔符，看它多智能！ 提示 你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 foreach。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。 至此，我们已经完成了与 XML 配置及映射文件相关的讨论。下一章将详细探讨 Java API，以便你能充分利用已经创建的映射配置。 script# 要在带注解的映射器接口类中使用动态 SQL，可以使用 script 元素。比如: 1234567891011@Update(&#123;&quot;&lt;script&gt;&quot;, &quot;update Author&quot;, &quot; &lt;set&gt;&quot;, &quot; &lt;if test=&#x27;username != null&#x27;&gt;username=#&#123;username&#125;,&lt;/if&gt;&quot;, &quot; &lt;if test=&#x27;password != null&#x27;&gt;password=#&#123;password&#125;,&lt;/if&gt;&quot;, &quot; &lt;if test=&#x27;email != null&#x27;&gt;email=#&#123;email&#125;,&lt;/if&gt;&quot;, &quot; &lt;if test=&#x27;bio != null&#x27;&gt;bio=#&#123;bio&#125;&lt;/if&gt;&quot;, &quot; &lt;/set&gt;&quot;, &quot;where id=#&#123;id&#125;&quot;, &quot;&lt;/script&gt;&quot;&#125;) void updateAuthorValues(Author author); bind# bind 元素允许你在 OGNL 表达式以外创建一个变量，并将其绑定到当前的上下文。比如： 12345&lt;select id=&quot;selectBlogsLike&quot; resultType=&quot;Blog&quot;&gt; &lt;bind name=&quot;pattern&quot; value=&quot;&#x27;%&#x27; + _parameter.getTitle() + &#x27;%&#x27;&quot; /&gt; SELECT * FROM BLOG WHERE title LIKE #&#123;pattern&#125;&lt;/select&gt; 多数据库支持# 如果配置了 databaseIdProvider，你就可以在动态代码中使用名为 “_databaseId” 的变量来为不同的数据库构建特定的语句。比如下面的例子： 1234567891011&lt;insert id=&quot;insert&quot;&gt; &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;int&quot; order=&quot;BEFORE&quot;&gt; &lt;if test=&quot;_databaseId == &#x27;oracle&#x27;&quot;&gt; select seq_users.nextval from dual &lt;/if&gt; &lt;if test=&quot;_databaseId == &#x27;db2&#x27;&quot;&gt; select nextval for seq_users from sysibm.sysdummy1&quot; &lt;/if&gt; &lt;/selectKey&gt; insert into users values (#&#123;id&#125;, #&#123;name&#125;)&lt;/insert&gt; 动态 SQL 中的插入脚本语言# MyBatis 从 3.2 版本开始支持插入脚本语言，这允许你插入一种语言驱动，并基于这种语言来编写动态 SQL 查询语句。 可以通过实现以下接口来插入一种语言： 12345public interface LanguageDriver &#123; ParameterHandler createParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql); SqlSource createSqlSource(Configuration configuration, XNode script, Class&lt;?&gt; parameterType); SqlSource createSqlSource(Configuration configuration, String script, Class&lt;?&gt; parameterType);&#125; 实现自定义语言驱动后，你就可以在 mybatis-config.xml 文件中将它设置为默认语言： 123456&lt;typeAliases&gt; &lt;typeAlias type=&quot;org.sample.MyLanguageDriver&quot; alias=&quot;myLanguage&quot;/&gt;&lt;/typeAliases&gt;&lt;settings&gt; &lt;setting name=&quot;defaultScriptingLanguage&quot; value=&quot;myLanguage&quot;/&gt;&lt;/settings&gt; 或者，你也可以使用 lang 属性为特定的语句指定语言： 123&lt;select id=&quot;selectBlog&quot; lang=&quot;myLanguage&quot;&gt; SELECT * FROM BLOG&lt;/select&gt; 或者，在你的 mapper 接口上添加 @Lang 注解： 12345public interface Mapper &#123; @Lang(MyLanguageDriver.class) @Select(&quot;SELECT * FROM BLOG&quot;) List&lt;Blog&gt; selectBlog();&#125; Mybatis中$和#的区别# 在SQL中引用这些参数的时候，可以使用两种方式#{parameterName}或者${parameterName}，首先，我们说一下这两种引用参数时的区别，使用#{parameterName}引用参数的时候，Mybatis会把这个参数认为是一个字符串，例如传入参数是“Smith”，那么在SQL（Select * from emp where name = #{employeeName})使用的时候就会转换为Select * from emp where name = ‘Smith’; 同时在SQL（Select * from emp where name = ${employeeName}）使用的时候就会转换为Select * from emp where name = Smith。 123456789101. #将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。如：order by #user_id#，如果传入的值是111,那么解析成sql时的值为order by &quot;111&quot;, 如果传入的值是id，则解析成的sql为order by &quot;id&quot;.2. $将传入的数据直接显示生成在sql中。如：order by $user_id$，如果传入的值是111,那么解析成sql时的值为order by user_id, 如果传入的值是id，则解析成的sql为order by id.3. #方式能够很大程度防止sql注入。4. $方式无法防止Sql注入。5. $方式一般用于传入数据库对象，例如传入表名.6. 一般能用#的就别用$. 扩展阅读# Mybatis文档：https://mybatis.org/mybatis-3/zh/dynamic-sql.html","content":"<p>动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。</p>\n<p>使用动态 SQL 并非一件易事，但借助可用于任何 SQL 映射语句中的强大的动态 SQL 语言，MyBatis 显著地提升了这一特性的易用性。</p>\n<p><img src=\"/images/posts/2020/mybatis.png\" alt></p>\n<span id=\"more\"></span>\n<p>如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。</p>\n<ol>\n<li>if</li>\n<li>choose (when, otherwise)</li>\n<li>trim (where, set)</li>\n<li>foreach</li>\n<li>if</li>\n</ol>\n<h2><span id=\"yuan-su-xiang-jie\">元素详解</span><a href=\"#yuan-su-xiang-jie\" class=\"header-anchor\">#</a></h2>\n<h3><span id=\"if\">if</span><a href=\"#if\" class=\"header-anchor\">#</a></h3>\n<p>使用动态 SQL 最常见情景是根据条件包含 where 子句的一部分。比如：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;findActiveBlogWithTitleLike&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">resultType</span>=<span class=\"string\">&quot;Blog&quot;</span>&gt;</span></span><br><span class=\"line\">  SELECT * FROM BLOG</span><br><span class=\"line\">  WHERE state = ‘ACTIVE’</span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">if</span> <span class=\"attr\">test</span>=<span class=\"string\">&quot;title != null&quot;</span>&gt;</span></span><br><span class=\"line\">    AND title like #&#123;title&#125;</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">if</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这条语句提供了可选的查找文本功能。如果不传入 “title”，那么所有处于 “ACTIVE” 状态的 BLOG 都会返回；如果传入了 “title” 参数，那么就会对 “title” 一列进行模糊查找并返回对应的 BLOG 结果（细心的读者可能会发现，“title” 的参数值需要包含查找掩码或通配符字符）。</p>\n<p>如果希望通过 “title” 和 “author” 两个参数进行可选搜索该怎么办呢？首先，我想先将语句名称修改成更名副其实的名称；接下来，只需要加入另一个条件即可。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;findActiveBlogLike&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">resultType</span>=<span class=\"string\">&quot;Blog&quot;</span>&gt;</span></span><br><span class=\"line\">  SELECT * FROM BLOG WHERE state = ‘ACTIVE’</span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">if</span> <span class=\"attr\">test</span>=<span class=\"string\">&quot;title != null&quot;</span>&gt;</span></span><br><span class=\"line\">    AND title like #&#123;title&#125;</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">if</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">if</span> <span class=\"attr\">test</span>=<span class=\"string\">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class=\"line\">    AND author_name like #&#123;author.name&#125;</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">if</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"choose-when-otherwise\">choose、when、otherwise</span><a href=\"#choose-when-otherwise\" class=\"header-anchor\">#</a></h3>\n<p>有时候，我们不想使用所有的条件，而只是想从多个条件中选择一个使用。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。</p>\n<p>还是上面的例子，但是策略变为：传入了 “title” 就按 “title” 查找，传入了 “author” 就按 “author” 查找的情形。若两者都没有传入，就返回标记为 featured 的 BLOG（这可能是管理员认为，与其返回大量的无意义随机 Blog，还不如返回一些由管理员挑选的 Blog）。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;findActiveBlogLike&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">resultType</span>=<span class=\"string\">&quot;Blog&quot;</span>&gt;</span></span><br><span class=\"line\">  SELECT * FROM BLOG WHERE state = ‘ACTIVE’</span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">choose</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">when</span> <span class=\"attr\">test</span>=<span class=\"string\">&quot;title != null&quot;</span>&gt;</span></span><br><span class=\"line\">      AND title like #&#123;title&#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">when</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">when</span> <span class=\"attr\">test</span>=<span class=\"string\">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class=\"line\">      AND author_name like #&#123;author.name&#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">when</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">otherwise</span>&gt;</span></span><br><span class=\"line\">      AND featured = 1</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">otherwise</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">choose</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"trim-where-set\">trim、where、set</span><a href=\"#trim-where-set\" class=\"header-anchor\">#</a></h3>\n<p>前面几个例子已经合宜地解决了一个臭名昭著的动态 SQL 问题。现在回到之前的 “if” 示例，这次我们将 “state = ‘ACTIVE’” 设置成动态条件，看看会发生什么。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;findActiveBlogLike&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">resultType</span>=<span class=\"string\">&quot;Blog&quot;</span>&gt;</span></span><br><span class=\"line\">  SELECT * FROM BLOG</span><br><span class=\"line\">  WHERE</span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">if</span> <span class=\"attr\">test</span>=<span class=\"string\">&quot;state != null&quot;</span>&gt;</span></span><br><span class=\"line\">    state = #&#123;state&#125;</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">if</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">if</span> <span class=\"attr\">test</span>=<span class=\"string\">&quot;title != null&quot;</span>&gt;</span></span><br><span class=\"line\">    AND title like #&#123;title&#125;</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">if</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">if</span> <span class=\"attr\">test</span>=<span class=\"string\">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class=\"line\">    AND author_name like #&#123;author.name&#125;</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">if</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>如果没有匹配的条件会怎么样？最终这条 SQL 会变成这样：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> BLOG</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span></span><br></pre></td></tr></table></figure>\n<p>这会导致查询失败。如果匹配的只是第二个条件又会怎样？这条 SQL 会是这样:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM BLOG</span><br><span class=\"line\">WHERE</span><br><span class=\"line\">AND title like ‘someTitle’</span><br></pre></td></tr></table></figure>\n<p>这个查询也会失败。这个问题不能简单地用条件元素来解决。这个问题是如此的难以解决，以至于解决过的人不会再想碰到这种问题。</p>\n<p>MyBatis 有一个简单且适合大多数场景的解决办法。而在其他场景中，可以对其进行自定义以符合需求。而这，只需要一处简单的改动：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;findActiveBlogLike&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">resultType</span>=<span class=\"string\">&quot;Blog&quot;</span>&gt;</span></span><br><span class=\"line\">  SELECT * FROM BLOG</span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">where</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">if</span> <span class=\"attr\">test</span>=<span class=\"string\">&quot;state != null&quot;</span>&gt;</span></span><br><span class=\"line\">         state = #&#123;state&#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">if</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">if</span> <span class=\"attr\">test</span>=<span class=\"string\">&quot;title != null&quot;</span>&gt;</span></span><br><span class=\"line\">        AND title like #&#123;title&#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">if</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">if</span> <span class=\"attr\">test</span>=<span class=\"string\">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class=\"line\">        AND author_name like #&#123;author.name&#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">if</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">where</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>where 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，where 元素也会将它们去除。</p>\n<p>如果 where 元素与你期望的不太一样，你也可以通过自定义 trim 元素来定制 where 元素的功能。比如，和 where 元素等价的自定义 trim 元素为：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">trim</span> <span class=\"attr\">prefix</span>=<span class=\"string\">&quot;WHERE&quot;</span> <span class=\"attr\">prefixOverrides</span>=<span class=\"string\">&quot;AND |OR &quot;</span>&gt;</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">trim</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>prefixOverrides 属性会忽略通过管道符分隔的文本序列（注意此例中的空格是必要的）。上述例子会移除所有 prefixOverrides 属性中指定的内容，并且插入 prefix 属性中指定的内容。</p>\n<p>用于动态更新语句的类似解决方案叫做 set。set 元素可以用于动态包含需要更新的列，忽略其它不更新的列。比如：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">update</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;updateAuthorIfNecessary&quot;</span>&gt;</span></span><br><span class=\"line\">  update Author</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">set</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">if</span> <span class=\"attr\">test</span>=<span class=\"string\">&quot;username != null&quot;</span>&gt;</span>username=#&#123;username&#125;,<span class=\"tag\">&lt;/<span class=\"name\">if</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">if</span> <span class=\"attr\">test</span>=<span class=\"string\">&quot;password != null&quot;</span>&gt;</span>password=#&#123;password&#125;,<span class=\"tag\">&lt;/<span class=\"name\">if</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">if</span> <span class=\"attr\">test</span>=<span class=\"string\">&quot;email != null&quot;</span>&gt;</span>email=#&#123;email&#125;,<span class=\"tag\">&lt;/<span class=\"name\">if</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">if</span> <span class=\"attr\">test</span>=<span class=\"string\">&quot;bio != null&quot;</span>&gt;</span>bio=#&#123;bio&#125;<span class=\"tag\">&lt;/<span class=\"name\">if</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">set</span>&gt;</span></span><br><span class=\"line\">  where id=#&#123;id&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">update</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这个例子中，set 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。</p>\n<p>来看看与 set 元素等价的自定义 trim 元素吧：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">trim</span> <span class=\"attr\">prefix</span>=<span class=\"string\">&quot;SET&quot;</span> <span class=\"attr\">suffixOverrides</span>=<span class=\"string\">&quot;,&quot;</span>&gt;</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">trim</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>注意，我们覆盖了后缀值设置，并且自定义了前缀值。</p>\n<h3><span id=\"foreach\">foreach</span><a href=\"#foreach\" class=\"header-anchor\">#</a></h3>\n<p>动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN 条件语句的时候）。比如：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;selectPostIn&quot;</span> <span class=\"attr\">resultType</span>=<span class=\"string\">&quot;domain.blog.Post&quot;</span>&gt;</span></span><br><span class=\"line\">  SELECT *</span><br><span class=\"line\">  FROM POST P</span><br><span class=\"line\">  WHERE ID in</span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">foreach</span> <span class=\"attr\">item</span>=<span class=\"string\">&quot;item&quot;</span> <span class=\"attr\">index</span>=<span class=\"string\">&quot;index&quot;</span> <span class=\"attr\">collection</span>=<span class=\"string\">&quot;list&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">open</span>=<span class=\"string\">&quot;(&quot;</span> <span class=\"attr\">separator</span>=<span class=\"string\">&quot;,&quot;</span> <span class=\"attr\">close</span>=<span class=\"string\">&quot;)&quot;</span>&gt;</span></span><br><span class=\"line\">        #&#123;item&#125;</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">foreach</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>foreach 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。这个元素也不会错误地添加多余的分隔符，看它多智能！</p>\n<p>提示 你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 foreach。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。</p>\n<p>至此，我们已经完成了与 XML 配置及映射文件相关的讨论。下一章将详细探讨 Java API，以便你能充分利用已经创建的映射配置。</p>\n<h3><span id=\"script\">script</span><a href=\"#script\" class=\"header-anchor\">#</a></h3>\n<p>要在带注解的映射器接口类中使用动态 SQL，可以使用 script 元素。比如:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Update(&#123;&quot;&lt;script&gt;&quot;,</span></span><br><span class=\"line\"><span class=\"meta\">     &quot;update Author&quot;,</span></span><br><span class=\"line\"><span class=\"meta\">     &quot;  &lt;set&gt;&quot;,</span></span><br><span class=\"line\"><span class=\"meta\">     &quot;    &lt;if test=&#x27;username != null&#x27;&gt;username=#&#123;username&#125;,&lt;/if&gt;&quot;,</span></span><br><span class=\"line\"><span class=\"meta\">     &quot;    &lt;if test=&#x27;password != null&#x27;&gt;password=#&#123;password&#125;,&lt;/if&gt;&quot;,</span></span><br><span class=\"line\"><span class=\"meta\">     &quot;    &lt;if test=&#x27;email != null&#x27;&gt;email=#&#123;email&#125;,&lt;/if&gt;&quot;,</span></span><br><span class=\"line\"><span class=\"meta\">     &quot;    &lt;if test=&#x27;bio != null&#x27;&gt;bio=#&#123;bio&#125;&lt;/if&gt;&quot;,</span></span><br><span class=\"line\"><span class=\"meta\">     &quot;  &lt;/set&gt;&quot;,</span></span><br><span class=\"line\"><span class=\"meta\">     &quot;where id=#&#123;id&#125;&quot;,</span></span><br><span class=\"line\"><span class=\"meta\">     &quot;&lt;/script&gt;&quot;&#125;)</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">updateAuthorValues</span><span class=\"params\">(Author author)</span></span>;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"bind\">bind</span><a href=\"#bind\" class=\"header-anchor\">#</a></h3>\n<p>bind 元素允许你在 OGNL 表达式以外创建一个变量，并将其绑定到当前的上下文。比如：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;selectBlogsLike&quot;</span> <span class=\"attr\">resultType</span>=<span class=\"string\">&quot;Blog&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">bind</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;pattern&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;&#x27;%&#x27; + _parameter.getTitle() + &#x27;%&#x27;&quot;</span> /&gt;</span></span><br><span class=\"line\">  SELECT * FROM BLOG</span><br><span class=\"line\">  WHERE title LIKE #&#123;pattern&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"duo-shu-ju-ku-zhi-chi\">多数据库支持</span><a href=\"#duo-shu-ju-ku-zhi-chi\" class=\"header-anchor\">#</a></h2>\n<p>如果配置了 databaseIdProvider，你就可以在动态代码中使用名为 “_databaseId” 的变量来为不同的数据库构建特定的语句。比如下面的例子：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">insert</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;insert&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">selectKey</span> <span class=\"attr\">keyProperty</span>=<span class=\"string\">&quot;id&quot;</span> <span class=\"attr\">resultType</span>=<span class=\"string\">&quot;int&quot;</span> <span class=\"attr\">order</span>=<span class=\"string\">&quot;BEFORE&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">if</span> <span class=\"attr\">test</span>=<span class=\"string\">&quot;_databaseId == &#x27;oracle&#x27;&quot;</span>&gt;</span></span><br><span class=\"line\">      select seq_users.nextval from dual</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">if</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">if</span> <span class=\"attr\">test</span>=<span class=\"string\">&quot;_databaseId == &#x27;db2&#x27;&quot;</span>&gt;</span></span><br><span class=\"line\">      select nextval for seq_users from sysibm.sysdummy1&quot;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">if</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">selectKey</span>&gt;</span></span><br><span class=\"line\">  insert into users values (#&#123;id&#125;, #&#123;name&#125;)</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"dong-tai-sql-zhong-de-cha-ru-jiao-ben-yu-yan\">动态 SQL 中的插入脚本语言</span><a href=\"#dong-tai-sql-zhong-de-cha-ru-jiao-ben-yu-yan\" class=\"header-anchor\">#</a></h3>\n<p>MyBatis 从 3.2 版本开始支持插入脚本语言，这允许你插入一种语言驱动，并基于这种语言来编写动态 SQL 查询语句。</p>\n<p>可以通过实现以下接口来插入一种语言：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">LanguageDriver</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">ParameterHandler <span class=\"title\">createParameterHandler</span><span class=\"params\">(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql)</span></span>;</span><br><span class=\"line\">  <span class=\"function\">SqlSource <span class=\"title\">createSqlSource</span><span class=\"params\">(Configuration configuration, XNode script, Class&lt;?&gt; parameterType)</span></span>;</span><br><span class=\"line\">  <span class=\"function\">SqlSource <span class=\"title\">createSqlSource</span><span class=\"params\">(Configuration configuration, String script, Class&lt;?&gt; parameterType)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现自定义语言驱动后，你就可以在 mybatis-config.xml 文件中将它设置为默认语言：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">typeAliases</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">typeAlias</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;org.sample.MyLanguageDriver&quot;</span> <span class=\"attr\">alias</span>=<span class=\"string\">&quot;myLanguage&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">typeAliases</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">settings</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">setting</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;defaultScriptingLanguage&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;myLanguage&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>或者，你也可以使用 lang 属性为特定的语句指定语言：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;selectBlog&quot;</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;myLanguage&quot;</span>&gt;</span></span><br><span class=\"line\">  SELECT * FROM BLOG</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>或者，在你的 mapper 接口上添加 @Lang 注解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Mapper</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Lang(MyLanguageDriver.class)</span></span><br><span class=\"line\">  <span class=\"meta\">@Select(&quot;SELECT * FROM BLOG&quot;)</span></span><br><span class=\"line\">  <span class=\"function\">List&lt;Blog&gt; <span class=\"title\">selectBlog</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"mybatis-zhong-he-de-qu-bie\">Mybatis中$和#的区别</span><a href=\"#mybatis-zhong-he-de-qu-bie\" class=\"header-anchor\">#</a></h3>\n<p>在SQL中引用这些参数的时候，可以使用两种方式#{parameterName}或者${parameterName}，首先，我们说一下这两种引用参数时的区别，使用#{parameterName}引用参数的时候，Mybatis会把这个参数认为是一个字符串，例如传入参数是“Smith”，那么在SQL（Select * from emp where name = #{employeeName})使用的时候就会转换为Select * from emp where name = ‘Smith’; 同时在SQL（Select * from emp where name = ${employeeName}）使用的时候就会转换为Select * from emp where name = Smith。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. #将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。如：</span><br><span class=\"line\">order by #user_id#，如果传入的值是111,那么解析成sql时的值为order by &quot;111&quot;,</span><br><span class=\"line\"> 如果传入的值是id，则解析成的sql为order by &quot;id&quot;.</span><br><span class=\"line\">2. $将传入的数据直接显示生成在sql中。如：order by $user_id$，</span><br><span class=\"line\">如果传入的值是111,那么解析成sql时的值为order by user_id, </span><br><span class=\"line\"> 如果传入的值是id，则解析成的sql为order by id.</span><br><span class=\"line\">3. #方式能够很大程度防止sql注入。</span><br><span class=\"line\">4. $方式无法防止Sql注入。</span><br><span class=\"line\">5. $方式一般用于传入数据库对象，例如传入表名.</span><br><span class=\"line\">6. 一般能用#的就别用$.</span><br></pre></td></tr></table></figure>\n<h2><span id=\"kuo-zhan-yue-du\">扩展阅读</span><a href=\"#kuo-zhan-yue-du\" class=\"header-anchor\">#</a></h2>\n<ol>\n<li>Mybatis文档：<a href=\"https://mybatis.org/mybatis-3/zh/dynamic-sql.html\">https://mybatis.org/mybatis-3/zh/dynamic-sql.html</a></li>\n</ol>\n<link rel=\"stylesheet\" href=\"/css/markmap.css\" type=\"text/css\">","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.beyhub.com/tags/MySQL/"}]},{"title":"BPM工作流引擎Activiti","path":"post/bpm工作流引擎activiti/","text":"Activiti 是一个业务流程管理的开源框架，支持BPMN2.0流程定义协议。其主要功能有流程定义、流程部署、流程执行、用户群组管理、历史记录查询等功能。越是复杂的业务越是需要流程管理的工具，activiti就是很好的选择，从oa系统的审批到电商系统的购物，这些复杂的业务场景都能看到Activiti的身影。硬编码复杂的业务时，每一步的流转判断充满了风险，稍有不慎就得不到想要的结果，而问题追踪起来也非常麻烦。而基于activiti编写复杂的业务时，按照规范画出流程定义文件，业务可见即可得一目了然，大大降低了复杂业务出错的概率，剩下的事情就交给activiti去执行，它会严格按照流程的定义去执行。 BPM（Business Process Management）# BPMN(Business Process Model and Notation)，业务流程建模和标注。 Notation是BPMN的核心，即使用图形来表达业务流程。另外，BPMN是由OMG组织维护的一个公开的标准，与任何特定商业组织或工具是没有关系，无需为此付费。BPMN和传统的流程图的区别如下： BPMN是一个正式的规范，各种图标、元件是有准确的含义和使用规范 BPMN可以描述基于事件触发的行为，比如响应超时、外部系统无法提供服务等 下图为一个订单流程的描述： 特点# actitvti支持BPMN2.0流程定义协议。 activiti与Spring集成非常方便，甚至实现了Starter，集成SpringBoot更为方便。 activiti的社区活跃，github提交记录频繁，不断的有开发者给他添砖加瓦。 activiti的提供的api非常丰富，能够满足绝大部分的业务场景。 核心API# activiti给使用者提供了大量的接口，这些接口能够完成从流程部署、流程运行以及历史流程记录查询的所有操作。主要的api有一下七个： RepositoryService，部署流程定义文件，管理流程定义实例。 RuntimeService，启动流程，管理流程实例，设置获取流程变量。 TaskService，处理任务、设置任务候选人（组）、指定任务处理人（组）、设置附件等。 FormService，获取任务的表单数据、提交完成一个任务、启动流程。 HistoryService，查询流程历史记录、事件记录、变量记录。 IdentityService，创建用户、创建组、查询用户（组）。 ManagementService，执行自定义命令、查询底层实体、数据表、提供更多的扩展功能。 参考# 官方网站：https://www.activiti.org/ BPMN 官网：http://www.bpmn.org/","content":"<p>Activiti 是一个业务流程管理的开源框架，支持BPMN2.0流程定义协议。其主要功能有流程定义、流程部署、流程执行、用户群组管理、历史记录查询等功能。越是复杂的业务越是需要流程管理的工具，activiti就是很好的选择，从oa系统的审批到电商系统的购物，这些复杂的业务场景都能看到Activiti的身影。硬编码复杂的业务时，每一步的流转判断充满了风险，稍有不慎就得不到想要的结果，而问题追踪起来也非常麻烦。而基于activiti编写复杂的业务时，按照规范画出流程定义文件，业务可见即可得一目了然，大大降低了复杂业务出错的概率，剩下的事情就交给activiti去执行，它会严格按照流程的定义去执行。</p>\n<span id=\"more\"></span>\n<h2><span id=\"bpm-business-process-management\">BPM（Business Process Management）</span><a href=\"#bpm-business-process-management\" class=\"header-anchor\">#</a></h2>\n<p>BPMN(Business Process Model and Notation)，业务流程建模和标注。 Notation是BPMN的核心，即使用图形来表达业务流程。另外，BPMN是由OMG组织维护的一个公开的标准，与任何特定商业组织或工具是没有关系，无需为此付费。BPMN和传统的流程图的区别如下：</p>\n<ul>\n<li>BPMN是一个正式的规范，各种图标、元件是有准确的含义和使用规范</li>\n<li>BPMN可以描述基于事件触发的行为，比如响应超时、外部系统无法提供服务等</li>\n</ul>\n<p>下图为一个订单流程的描述：</p>\n<p><img src=\"/images/posts/2020/bpmn.png\" alt></p>\n<h2><span id=\"te-dian\">特点</span><a href=\"#te-dian\" class=\"header-anchor\">#</a></h2>\n<ol>\n<li>actitvti支持BPMN2.0流程定义协议。</li>\n<li>activiti与Spring集成非常方便，甚至实现了Starter，集成SpringBoot更为方便。</li>\n<li>activiti的社区活跃，github提交记录频繁，不断的有开发者给他添砖加瓦。</li>\n<li>activiti的提供的api非常丰富，能够满足绝大部分的业务场景。</li>\n</ol>\n<h2><span id=\"he-xin-api\">核心API</span><a href=\"#he-xin-api\" class=\"header-anchor\">#</a></h2>\n<p>activiti给使用者提供了大量的接口，这些接口能够完成从流程部署、流程运行以及历史流程记录查询的所有操作。主要的api有一下七个：</p>\n<ol>\n<li>RepositoryService，部署流程定义文件，管理流程定义实例。</li>\n<li>RuntimeService，启动流程，管理流程实例，设置获取流程变量。</li>\n<li>TaskService，处理任务、设置任务候选人（组）、指定任务处理人（组）、设置附件等。</li>\n<li>FormService，获取任务的表单数据、提交完成一个任务、启动流程。</li>\n<li>HistoryService，查询流程历史记录、事件记录、变量记录。</li>\n<li>IdentityService，创建用户、创建组、查询用户（组）。</li>\n<li>ManagementService，执行自定义命令、查询底层实体、数据表、提供更多的扩展功能。</li>\n</ol>\n<h2><span id=\"can-kao\">参考</span><a href=\"#can-kao\" class=\"header-anchor\">#</a></h2>\n<ol>\n<li>官方网站：<a href=\"https://www.activiti.org/\">https://www.activiti.org/</a></li>\n<li>BPMN 官网：<a href=\"http://www.bpmn.org/\">http://www.bpmn.org/</a></li>\n</ol>\n<link rel=\"stylesheet\" href=\"/css/markmap.css\" type=\"text/css\">","tags":[{"name":"BPMN","slug":"BPMN","permalink":"https://blog.beyhub.com/tags/BPMN/"}]},{"title":"Java CAS并发原语","path":"post/java-cas并发原语/","text":"在Java并发中，我们最初接触的应该就是synchronized关键字了，但是synchronized属于重量级锁，很多时候会引起性能问题，volatile也是个不错的选择，但是volatile不能保证原子性，只能在某些场合下使用。 对CAS的理解，CAS是一种无锁算法，CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。CAS比较与交换的伪代码可以表示为： 1234do&#123; 备份旧数据； 基于旧数据构造新数据； &#125;while(!CAS( 内存地址，备份的旧数据，新数据 )) 乐观锁与悲观锁# 像synchronized这种独占锁属于悲观锁，它是在假设一定会发生冲突的，那么加锁恰好有用，除此之外，还有乐观锁，乐观锁的含义就是假设没有发生冲突，那么我正好可以进行某项操作，如果要是发生冲突呢，那我就重试直到成功，乐观锁最常见的就是CAS。 我们在读Concurrent包下的类的源码时，发现无论是ReenterLock内部的AQS，还是各种Atomic开头的原子类，内部都应用到了CAS，最常见的就是我们在并发编程时遇到的i++这种情况。传统的方法肯定是在方法上加上synchronized关键字: 123456public class Test &#123; public volatile int i; public synchronized void add() &#123; i++; &#125;&#125; 但是这种方法在性能上可能会差一点，我们还可以使用AtomicInteger，就可以保证i原子的++了。 1234567public class Test &#123; public AtomicInteger i; public void add() &#123; i.getAndIncrement(); &#125;&#125; 我们来看getAndIncrement的内部： 123public final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1);&#125; 再深入到getAndAddInt(): 1234567public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125; 这里我们见到compareAndSwapInt这个函数，它也是CAS缩写的由来。那么仔细分析下这个函数做了什么呢？ 首先我们发现compareAndSwapInt前面的this，那么它属于哪个类呢，我们看上一步getAndAddInt，前面是unsafe。这里我们进入的Unsafe类。这里要对Unsafe类做个说明。结合AtomicInteger的定义来说： 12345678910111213public class AtomicInteger extends Number implements java.io.Serializable &#123; private static final long serialVersionUID = 6214790243416807050L; // setup to use Unsafe.compareAndSwapInt for updates private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(&quot;value&quot;)); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; private volatile int value; ... 在AtomicInteger数据定义的部分，我们可以看到，其实实际存储的值是放在value中的，除此之外我们还获取了unsafe实例，并且定义了valueOffset。再看到static块，懂类加载过程的都知道，static块的加载发生于类加载的时候，是最先初始化的，这时候我们调用unsafe的objectFieldOffset从Atomic类文件中获取value的偏移量，那么valueOffset其实就是记录value的偏移量的。 再回到上面一个函数getAndAddInt，我们看var5获取的是什么，通过调用unsafe的getIntVolatile(var1, var2)，这是个native方法，具体实现到JDK源码里去看了，其实就是获取var1中，var2偏移量处的值。var1就是AtomicInteger，var2就是我们前面提到的valueOffset,这样我们就从内存里获取到现在valueOffset处的值了。 现在重点来了，compareAndSwapInt（var1, var2, var5, var5 + var4）其实换成compareAndSwapInt（obj, offset, expect, update）比较清楚，意思就是如果obj内的value和expect相等，就证明没有其他线程改变过这个变量，那么就更新它为update，如果这一步的CAS没有成功，那就采用自旋的方式继续进行CAS操作，取出乍一看这也是两个步骤了啊，其实在JNI里是借助于一个CPU指令完成的。所以还是原子操作。 CAS底层原理# CAS底层使用JNI调用C代码实现的，如果你有Hotspot源码，那么在Unsafe.cpp里可以找到它的实现： 123456static JNINativeMethod methods_15[] = &#123; //省略一堆代码... &#123;CC&quot;compareAndSwapInt&quot;, CC&quot;(&quot;OBJ&quot;J&quot;&quot;I&quot;&quot;I&quot;&quot;)Z&quot;, FN_PTR(Unsafe_CompareAndSwapInt)&#125;, &#123;CC&quot;compareAndSwapLong&quot;, CC&quot;(&quot;OBJ&quot;J&quot;&quot;J&quot;&quot;J&quot;&quot;)Z&quot;, FN_PTR(Unsafe_CompareAndSwapLong)&#125;, //省略一堆代码...&#125;; 我们可以看到compareAndSwapInt实现是在Unsafe_CompareAndSwapInt里面，再深入到Unsafe_CompareAndSwapInt: 123456UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) UnsafeWrapper(&quot;Unsafe_CompareAndSwapInt&quot;); oop p = JNIHandles::resolve(obj); jint* addr = (jint *) index_oop_from_field_offset_long(p, offset); return (jint)(Atomic::cmpxchg(x, addr, e)) == e;UNSAFE_END p是取出的对象，addr是p中offset处的地址，最后调用了Atomic::cmpxchg(x, addr, e), 其中参数x是即将更新的值，参数e是原内存的值。代码中能看到cmpxchg有基于各个平台的实现，这里我选择Linux X86平台下的源码分析： 12345678inline jint Atomic::cmpxchg (jint exchange_value, volatile jint* dest, jint compare_value) &#123; int mp = os::is_MP(); __asm__ volatile (LOCK_IF_MP(%4) &quot;cmpxchgl %1,(%3)&quot; : &quot;=a&quot; (exchange_value) : &quot;r&quot; (exchange_value), &quot;a&quot; (compare_value), &quot;r&quot; (dest), &quot;r&quot; (mp) : &quot;cc&quot;, &quot;memory&quot;); return exchange_value;&#125; 这是一段小汇编，__asm__说明是ASM汇编，__volatile__禁止编译器优化 12// Adding a lock prefix to an instruction on MP machine#define LOCK_IF_MP(mp) &quot;cmp $0, &quot; #mp &quot;; je 1f; lock; 1: &quot; os::is_MP判断当前系统是否为多核系统，如果是就给总线加锁，所以同一芯片上的其他处理器就暂时不能通过总线访问内存，保证了该指令在多处理器环境下的原子性。 在正式解读这段汇编前，我们来了解下嵌入汇编的基本格式： 12345asm ( assembler template : output operands /* optional */ : input operands /* optional */ : list of clobbered registers /* optional */); template就是cmpxchgl %1,(%3)表示汇编模板 output operands表示输出操作数,=a对应eax寄存器 input operand 表示输入参数，%1 就是exchange_value, %3是dest, %4就是mp， r表示任意寄存器，a还是eax寄存器 list of clobbered registers就是些额外参数，cc表示编译器cmpxchgl的执行将影响到标志寄存器, memory告诉编译器要重新从内存中读取变量的最新值，这点实现了volatile的感觉。 那么表达式其实就是cmpxchgl exchange_value ,dest，我们会发现%2也就是compare_value没有用上，这里就要分析cmpxchgl的语义了。cmpxchgl末尾l表示操作数长度为4，上面已经知道了。cmpxchgl会默认比较eax寄存器的值即compare_value和exchange_value的值，如果相等，就把dest的值赋值给exchange_value,否则，将exchange_value赋值给eax。具体汇编指令可以查看Intel手册CMPXCHG 最终，JDK通过CPU的cmpxchgl指令的支持，实现AtomicInteger的CAS操作的原子性。 CAS 的问题# ABA问题# CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。这就是CAS的ABA问题。 常见的解决思路是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A-B-A 就会变成1A-2B-3A。 目前在JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。 循环时间长开销大# 上面我们说过如果CAS不成功，则会原地自旋，如果长时间自旋会给CPU带来非常大的执行开销。","content":"<p>在Java并发中，我们最初接触的应该就是synchronized关键字了，但是synchronized属于重量级锁，很多时候会引起性能问题，volatile也是个不错的选择，但是volatile不能保证原子性，只能在某些场合下使用。</p>\n<p>对CAS的理解，CAS是一种无锁算法，CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。CAS比较与交换的伪代码可以表示为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span>&#123;   </span><br><span class=\"line\">       备份旧数据；  </span><br><span class=\"line\">       基于旧数据构造新数据；  </span><br><span class=\"line\">&#125;<span class=\"keyword\">while</span>(!CAS( 内存地址，备份的旧数据，新数据 ))  </span><br></pre></td></tr></table></figure>\n<h2><span id=\"le-guan-suo-yu-bei-guan-suo\">乐观锁与悲观锁</span><a href=\"#le-guan-suo-yu-bei-guan-suo\" class=\"header-anchor\">#</a></h2>\n<p>像synchronized这种独占锁属于悲观锁，它是在假设一定会发生冲突的，那么加锁恰好有用，除此之外，还有乐观锁，乐观锁的含义就是假设没有发生冲突，那么我正好可以进行某项操作，如果要是发生冲突呢，那我就重试直到成功，乐观锁最常见的就是CAS。</p>\n<p>我们在读Concurrent包下的类的源码时，发现无论是ReenterLock内部的AQS，还是各种Atomic开头的原子类，内部都应用到了CAS，最常见的就是我们在并发编程时遇到的i++这种情况。传统的方法肯定是在方法上加上synchronized关键字:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是这种方法在性能上可能会差一点，我们还可以使用AtomicInteger，就可以保证i原子的++了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> AtomicInteger i;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        i.getAndIncrement();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>我们来看getAndIncrement的内部：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getAndIncrement</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.getAndAddInt(<span class=\"keyword\">this</span>, valueOffset, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再深入到getAndAddInt():</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getAndAddInt</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">int</span> var4)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> var5;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        var5 = <span class=\"keyword\">this</span>.getIntVolatile(var1, var2);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span>(!<span class=\"keyword\">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> var5;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们见到compareAndSwapInt这个函数，它也是CAS缩写的由来。那么仔细分析下这个函数做了什么呢？<br>\n首先我们发现compareAndSwapInt前面的this，那么它属于哪个类呢，我们看上一步getAndAddInt，前面是unsafe。这里我们进入的Unsafe类。这里要对Unsafe类做个说明。结合AtomicInteger的定义来说：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AtomicInteger</span> <span class=\"keyword\">extends</span> <span class=\"title\">Number</span> <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">6214790243416807050L</span>;</span><br><span class=\"line\">    <span class=\"comment\">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> valueOffset;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            valueOffset = unsafe.objectFieldOffset</span><br><span class=\"line\">                (AtomicInteger.class.getDeclaredField(<span class=\"string\">&quot;value&quot;</span>));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception ex) &#123; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(ex); &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> value;</span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n<p>在AtomicInteger数据定义的部分，我们可以看到，其实实际存储的值是放在value中的，除此之外我们还获取了unsafe实例，并且定义了valueOffset。再看到static块，懂类加载过程的都知道，static块的加载发生于类加载的时候，是最先初始化的，这时候我们调用unsafe的objectFieldOffset从Atomic类文件中获取value的偏移量，那么valueOffset其实就是记录value的偏移量的。</p>\n<p>再回到上面一个函数getAndAddInt，我们看var5获取的是什么，通过调用unsafe的getIntVolatile(var1, var2)，这是个native方法，具体实现到JDK源码里去看了，其实就是获取var1中，var2偏移量处的值。var1就是AtomicInteger，var2就是我们前面提到的valueOffset,这样我们就从内存里获取到现在valueOffset处的值了。</p>\n<p>现在重点来了，compareAndSwapInt（var1, var2, var5, var5 + var4）其实换成compareAndSwapInt（obj, offset, expect, update）比较清楚，意思就是如果obj内的value和expect相等，就证明没有其他线程改变过这个变量，那么就更新它为update，如果这一步的CAS没有成功，那就采用自旋的方式继续进行CAS操作，取出乍一看这也是两个步骤了啊，其实在JNI里是借助于一个CPU指令完成的。所以还是原子操作。</p>\n<h2><span id=\"cas-di-ceng-yuan-li\">CAS底层原理</span><a href=\"#cas-di-ceng-yuan-li\" class=\"header-anchor\">#</a></h2>\n<p>CAS底层使用JNI调用C代码实现的，如果你有Hotspot源码，那么在Unsafe.cpp里可以找到它的实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static JNINativeMethod methods_15[] = &#123;</span><br><span class=\"line\">    //省略一堆代码...</span><br><span class=\"line\">    &#123;CC&quot;compareAndSwapInt&quot;,  CC&quot;(&quot;OBJ&quot;J&quot;&quot;I&quot;&quot;I&quot;&quot;)Z&quot;,      FN_PTR(Unsafe_CompareAndSwapInt)&#125;,</span><br><span class=\"line\">    &#123;CC&quot;compareAndSwapLong&quot;, CC&quot;(&quot;OBJ&quot;J&quot;&quot;J&quot;&quot;J&quot;&quot;)Z&quot;,      FN_PTR(Unsafe_CompareAndSwapLong)&#125;,</span><br><span class=\"line\">    //省略一堆代码...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>我们可以看到compareAndSwapInt实现是在Unsafe_CompareAndSwapInt里面，再深入到Unsafe_CompareAndSwapInt:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class=\"line\">  UnsafeWrapper(&quot;Unsafe_CompareAndSwapInt&quot;);</span><br><span class=\"line\">  oop p = JNIHandles::resolve(obj);</span><br><span class=\"line\">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class=\"line\">  return (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class=\"line\">UNSAFE_END</span><br></pre></td></tr></table></figure>\n<p>p是取出的对象，addr是p中offset处的地址，最后调用了Atomic::cmpxchg(x, addr, e), 其中参数x是即将更新的值，参数e是原内存的值。代码中能看到cmpxchg有基于各个平台的实现，这里我选择Linux X86平台下的源码分析：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inline jint     Atomic::cmpxchg    (jint     exchange_value, volatile jint*     dest, jint     compare_value) &#123;</span><br><span class=\"line\">  int mp = os::is_MP();</span><br><span class=\"line\">  __asm__ volatile (LOCK_IF_MP(%4) &quot;cmpxchgl %1,(%3)&quot;</span><br><span class=\"line\">                    : &quot;=a&quot; (exchange_value)</span><br><span class=\"line\">                    : &quot;r&quot; (exchange_value), &quot;a&quot; (compare_value), &quot;r&quot; (dest), &quot;r&quot; (mp)</span><br><span class=\"line\">                    : &quot;cc&quot;, &quot;memory&quot;);</span><br><span class=\"line\">  return exchange_value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是一段小汇编，__asm__说明是ASM汇编，__volatile__禁止编译器优化</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Adding a lock prefix to an instruction on MP machine</span><br><span class=\"line\">#define LOCK_IF_MP(mp) &quot;cmp $0, &quot; #mp &quot;; je 1f; lock; 1: &quot;</span><br></pre></td></tr></table></figure>\n<p>os::is_MP判断当前系统是否为多核系统，如果是就给总线加锁，所以同一芯片上的其他处理器就暂时不能通过总线访问内存，保证了该指令在多处理器环境下的原子性。</p>\n<p>在正式解读这段汇编前，我们来了解下嵌入汇编的基本格式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">asm ( assembler template</span><br><span class=\"line\">    : output operands                  /* optional */</span><br><span class=\"line\">    : input operands                   /* optional */</span><br><span class=\"line\">    : list of clobbered registers      /* optional */</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>template就是cmpxchgl %1,(%3)表示汇编模板</li>\n<li>output operands表示输出操作数,=a对应eax寄存器</li>\n<li>input operand 表示输入参数，%1 就是exchange_value, %3是dest, %4就是mp， r表示任意寄存器，a还是eax寄存器</li>\n<li>list of clobbered registers就是些额外参数，cc表示编译器cmpxchgl的执行将影响到标志寄存器, memory告诉编译器要重新从内存中读取变量的最新值，这点实现了volatile的感觉。</li>\n</ul>\n<p>那么表达式其实就是cmpxchgl exchange_value ,dest，我们会发现%2也就是compare_value没有用上，这里就要分析cmpxchgl的语义了。cmpxchgl末尾l表示操作数长度为4，上面已经知道了。cmpxchgl会默认比较eax寄存器的值即compare_value和exchange_value的值，如果相等，就把dest的值赋值给exchange_value,否则，将exchange_value赋值给eax。具体汇编指令可以查看Intel手册CMPXCHG<br>\n最终，JDK通过CPU的cmpxchgl指令的支持，实现AtomicInteger的CAS操作的原子性。</p>\n<h2><span id=\"cas-de-wen-ti\">CAS 的问题</span><a href=\"#cas-de-wen-ti\" class=\"header-anchor\">#</a></h2>\n<h3><span id=\"aba-wen-ti\">ABA问题</span><a href=\"#aba-wen-ti\" class=\"header-anchor\">#</a></h3>\n<p>CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。这就是CAS的ABA问题。</p>\n<p>常见的解决思路是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A-B-A 就会变成1A-2B-3A。<br>\n目前在JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>\n<h3><span id=\"xun-huan-shi-jian-chang-kai-xiao-da\">循环时间长开销大</span><a href=\"#xun-huan-shi-jian-chang-kai-xiao-da\" class=\"header-anchor\">#</a></h3>\n<p>上面我们说过如果CAS不成功，则会原地自旋，如果长时间自旋会给CPU带来非常大的执行开销。</p>\n<link rel=\"stylesheet\" href=\"/css/markmap.css\" type=\"text/css\">","tags":[{"name":"Java","slug":"Java","permalink":"https://blog.beyhub.com/tags/Java/"},{"name":"锁","slug":"锁","permalink":"https://blog.beyhub.com/tags/%E9%94%81/"}]},{"title":"JVM 类的加载机制","path":"post/jvm-类的加载机制/","text":"从类被加载到虚拟机内存中开始，到卸御出内存为止，它的整个生命周期分为7个阶段，加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)、卸御(Unloading)。其中验证、准备、解析三个部分统称为连接。 Java类加载机制的七个阶段# 当我们的Java代码编译完成后，会生成对应的 class 文件。接着我们运行java Demo命令的时候，我们其实是启动了JVM 虚拟机执行 class 字节码文件的内容。而 JVM 虚拟机执行 class 字节码的过程可以分为七个阶段：加载、验证、准备、解析、初始化、使用、卸载。 加载# 下面是对于加载过程最为官方的描述。 加载阶段是类加载过程的第一个阶段。在这个阶段，JVM 的主要目的是将字节码从各个位置（网络、磁盘等）转化为二进制字节流加载到内存中，接着会为这个类在 JVM 的方法区创建一个对应的 Class 对象，这个 Class 对象就是这个类各种数据的访问入口。 其实加载阶段用一句话来说就是：把代码数据加载到内存中。这个过程对于我们解答这道问题没有直接的关系，但这是类加载机制的一个过程，所以必须要提一下。 验证# 当 JVM 加载完 Class 字节码文件并在方法区创建对应的 Class 对象之后，JVM 便会启动对该字节码流的校验，只有符合 JVM 字节码规范的文件才能被 JVM 正确执行。这个校验过程大致可以分为下面几个类型： JVM规范校验。JVM 会对字节流进行文件格式校验，判断其是否符合 JVM 规范，是否能被当前版本的虚拟机处理。例如：文件是否是以 0x cafe bene开头，主次版本号是否在当前虚拟机处理范围之内等。 代码逻辑校验。JVM 会对代码组成的数据流和控制流进行校验，确保 JVM 运行该字节码文件后不会出现致命错误。例如一个方法要求传入 int 类型的参数，但是使用它的时候却传入了一个 String 类型的参数。一个方法要求返回 String 类型的结果，但是最后却没有返回结果。代码中引用了一个名为 Apple 的类，但是你实际上却没有定义 Apple 类。 当代码数据被加载到内存中后，虚拟机就会对代码数据进行校验，看看这份代码是不是真的按照JVM规范去写的。这个过程对于我们解答问题也没有直接的关系，但是了解类加载机制必须要知道有这个过程。 准备（重点）# 当完成字节码文件的校验之后，JVM 便会开始为类变量分配内存并初始化。这里需要注意两个关键点，即内存分配的对象以及初始化的类型。 内存分配的对象。Java 中的变量有「类变量」和「类成员变量」两种类型，「类变量」指的是被 static 修饰的变量，而其他所有类型的变量都属于「类成员变量」。在准备阶段，JVM 只会为「类变量」分配内存，而不会为「类成员变量」分配内存。「类成员变量」的内存分配需要等到初始化阶段才开始。 例如下面的代码在准备阶段，只会为 factor 属性分配内存，而不会为 website 属性分配内存。 12public static int factor = 3;public String website = &quot;www.cnblogs.com/chanshuyi&quot;; 初始化的类型。在准备阶段，JVM 会为类变量分配内存，并为其初始化。但是这里的初始化指的是为变量赋予 Java 语言中该数据类型的零值，而不是用户代码里初始化的值。 例如下面的代码在准备阶段之后，sector 的值将是 0，而不是 3。 1public static int sector = 3; 但如果一个变量是常量（被 static final 修饰）的话，那么在准备阶段，属性便会被赋予用户希望的值。例如下面的代码在准备阶段之后，number 的值将是 3，而不是 0。 1public static final int number = 3; 之所以 static final 会直接被复制，而 static 变量会被赋予零值。其实我们稍微思考一下就能想明白了。 两个语句的区别是一个有 final 关键字修饰，另外一个没有。而 final 关键字在 Java 中代表不可改变的意思，意思就是说 number 的值一旦赋值就不会在改变了。既然一旦赋值就不会再改变，那么就必须一开始就给其赋予用户想要的值，因此被 final 修饰的类变量在准备阶段就会被赋予想要的值。而没有被 final 修饰的类变量，其可能在初始化阶段或者运行阶段发生变化，所以就没有必要在准备阶段对它赋予用户想要的值。 解析# 当通过准备阶段之后，JVM 针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类引用进行解析。这个阶段的主要任务是将其在常量池中的符号引用替换成直接其在内存中的直接引用。 其实这个阶段对于我们来说也是几乎透明的，了解一下就好。 初始化（重点）# 到了初始化阶段，用户定义的 Java 程序代码才真正开始执行。在这个阶段，JVM 会根据语句执行顺序对类对象进行初始化，一般来说当 JVM 遇到下面 5 种情况的时候会触发初始化： 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。 当使用 JDK1.7 动态语言支持时，如果一个 java.lang.invoke.MethodHandle实例最后的解析结果 REF_getstatic,REF_putstatic,REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。 使用# 当 JVM 完成初始化阶段之后，JVM 便开始从入口方法开始执行用户的程序代码。这个阶段也只是了解一下就可以。 卸载# 当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存。这个阶段也只是了解一下就可以。 看完了Java的类加载机智之后，是不是有点懵呢。不怕，我们先通过一个小例子来醒醒神。 12345678910111213141516171819202122232425public class Book &#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello ShuYi.&quot;); &#125; Book() &#123; System.out.println(&quot;书的构造方法&quot;); System.out.println(&quot;price=&quot; + price +&quot;,amount=&quot; + amount); &#125; &#123; System.out.println(&quot;书的普通代码块&quot;); &#125; int price = 110; static &#123; System.out.println(&quot;书的静态代码块&quot;); &#125; static int amount = 112;&#125; 思考一下上面这段代码输出什么？ 书的静态代码块 Hello ShuYi. 怎么样，你答对了吗？是不是和你想得有点不一样呢。 下面我们来简单分析一下，首先根据上面说到的触发初始化的5种情况的第4种（当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类），我们会进行类的初始化。 那么类的初始化顺序到底是怎么样的呢？ 在我们代码中，我们只知道有一个构造方法，但实际上Java代码编译成字节码之后，是没有构造方法的概念的，只有类初始化方法 和 对象初始化方法 。 那么这两个方法是怎么来的呢？ 类初始化方法。编译器会按照其出现顺序，收集类变量的赋值语句、静态代码块，最终组成类初始化方法。类初始化方法一般在类初始化的时候执行。 上面的这个例子，其类初始化方法就是下面这段代码了： 123456static&#123; System.out.println(&quot;书的静态代码块&quot;);&#125;static int amount = 112; 对象初始化方法。编译器会按照其出现顺序，收集成员变量的赋值语句、普通代码块，最后收集构造函数的代码，最终组成对象初始化方法。对象初始化方法一般在实例化类对象的时候执行。 上面这个例子，其对象初始化方法就是下面这段代码了： 123456&#123; System.out.println(&quot;书的普通代码块&quot;);&#125;int price = 110;System.out.println(&quot;书的构造方法&quot;);System.out.println(&quot;price=&quot; + price +&quot;,amount=&quot; + amount); 类初始化方法 和 对象初始化方法 之后，我们再来看这个例子，我们就不难得出上面的答案了。 但细心的朋友一定会发现，其实上面的这个例子其实没有执行对象初始化方法。 因为我们确实没有进行 Book 类对象的实例化。如果你在 main 方法中增加 new Book() 语句，你会发现对象的初始化方法执行了！ 什么是类装载器ClassLoader# ClassLoader是一个抽象类 ClassLoader的实例将读入Java字节码将类装载到JVM中 ClassLoader可以定制，满足不同的字节码流获取方式 ClassLoader负责类装载过程中的加载阶段。 JVM中的类加载器# 启动类加载器（BootStrap ClassLoader）：引导类装入器是用本地代码实现的类装入器，它负责将 jdk中jre/lib下面的核心类库或-Xbootclasspath选项指定的jar包加载到内存中。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。 扩展类加载器（Extension ClassLoader）：扩展类加载器是由Sun的ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将jdk中jre/lib/ext或者由系统变量-Djava.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。 系统类加载器（System ClassLoader）：系统类加载器是由 Sun的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。它负责将系统类路径java -classpath或-Djava.class.path变量所指的目录下的类库加载到内存中。开发者可以直接使用系统类加载器。 下图中展示了类加载器直接的关系和双亲委派模型 从图中我们发现除启动类加载器外，每个加载器都有父的类加载器。 双亲委派机制：如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。 从类的继承关系来看，ExtClassLoader和AppClassLoader都是继承URLClassLoader，都是ClassLoader的子类。而BootStrapClassLoader是有C++写的，不再java的ClassLoader子类中。 自定义类加载器# 前面提到了 Java 自带的加载器 BootstrapClassLoader、AppClassLoader和ExtClassLoader，这些都是 Java 已经提供好的。 而真正有意思的，是 自定义类加载器，它允许我们在运行时可以从本地磁盘或网络上动态加载自定义类。这使得开发者可以动态修复某些有问题的类，热更新代码。 下面来实现一个网络类加载器，这个加载器可以从网络上动态下载 .class 文件并加载到虚拟机中使用。 后面我还会写作与 热修复／动态更新 相关的文章，这里先学习 Java 层 NetworkClassLoader 相关的原理。 作为一个 NetworkClassLoader，它首先要继承 ClassLoader； 然后它要实现ClassLoader内的 findClass() 方法。注意，不是loadClass()方法，因为ClassLoader提供了loadClass()（如上面的源码），它会基于双亲委托机制去搜索某个 class，直到搜索不到才会调用自身的findClass()，如果直接复写loadClass()，那还要实现双亲委托机制； 在 findClass() 方法里，要从网络上下载一个 .class 文件，然后转化成 Class 对象供虚拟机使用。 具体实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Load class from network */public class NetworkClassLoader extends ClassLoader &#123; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; byte[] classData = downloadClassData(name); // 从远程下载 if (classData == null) &#123; super.findClass(name); // 未找到，抛异常 &#125; else &#123; return defineClass(name, classData, 0, classData.length); // convert class byte data to Class&lt;?&gt; object &#125; return null; &#125; private byte[] downloadClassData(String name) &#123; // 从 localhost 下载 .class 文件 String path = &quot;http://localhost&quot; + File.separatorChar + &quot;java&quot; + File.separatorChar + name.replace(&#x27;.&#x27;, File.separatorChar) + &quot;.class&quot;; try &#123; URL url = new URL(path); InputStream ins = url.openStream(); ByteArrayOutputStream baos = new ByteArrayOutputStream(); int bufferSize = 4096; byte[] buffer = new byte[bufferSize]; int bytesNumRead = 0; while ((bytesNumRead = ins.read(buffer)) != -1) &#123; baos.write(buffer, 0, bytesNumRead); // 把下载的二进制数据存入 ByteArrayOutputStream &#125; return baos.toByteArray(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; public String getName() &#123; System.out.printf(&quot;Real NetworkClassLoader\\n&quot;); return &quot;networkClassLoader&quot;; &#125;&#125; 这个类的作用是从网络上（这里是本人的 local apache 服务器 http://localhost/java 上）目录里去下载对应的 .class 文件，并转换成 Class&lt;?&gt; 返回回去使用。 下面我们来利用这个 NetworkClassLoader 去加载 localhost 上的 MusicPlayer 类： 首先把 MusicPlayer.class 放置于 /Library/WebServer/Documents/java （MacOS）目录下，由于 MacOS 自带 apache 服务器，这里是服务器的默认目录；执行下面一段代码： 123String className = &quot;classloader.NetworkClass&quot;;NetworkClassLoader networkClassLoader = new NetworkClassLoader();Class&lt;?&gt; clazz = networkClassLoader.loadClass(className); 正常运行，加载 http://localhost/java/classloader/MusicPlayer.class成功。可以看出 NetworkClassLoader 可以正常工作，如果读者要用的话，只要稍微修改 url 的拼接方式即可自行使用。 小结# 类加载方式是 Java 上非常创新的一项技术，给未来的热修复技术提供了可能。本文力求通过简单的语言和合适的例子来讲解其中双亲委托机制、自定义加载器等，并开发了自定义的NetworkClassLoader。当然，类加载是很有意思的技术，很难覆盖所有知识点，比如不同类加载器加载同一个类，得到的实例却不是同一个等等。 双亲委派模型的好处# Java类随着加载它的类加载器一起具备了一种带有优先级的层次关系。比如，Java中的Object类，它存放在rt.jar之中,无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object在各种类加载环境中都是同一个类。如果不采用双亲委派模型，那么由各个类加载器自己取加载的话，那么系统中会存在多种不同的Object类。 参考# 深入探讨 Java 类加载器","content":"<p>从类被加载到虚拟机内存中开始，到卸御出内存为止，它的整个生命周期分为7个阶段，加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)、卸御(Unloading)。其中验证、准备、解析三个部分统称为连接。</p>\n<p><img src=\"/images/posts/2020/jvm-classloader.webp\" alt></p>\n<span id=\"more\"></span>\n<h2><span id=\"java-lei-jia-zai-ji-zhi-de-qi-ge-jie-duan\">Java类加载机制的七个阶段</span><a href=\"#java-lei-jia-zai-ji-zhi-de-qi-ge-jie-duan\" class=\"header-anchor\">#</a></h2>\n<p>当我们的Java代码编译完成后，会生成对应的 class 文件。接着我们运行java Demo命令的时候，我们其实是启动了JVM 虚拟机执行 class 字节码文件的内容。而 JVM 虚拟机执行 class 字节码的过程可以分为七个阶段：加载、验证、准备、解析、初始化、使用、卸载。</p>\n<h3><span id=\"jia-zai\">加载</span><a href=\"#jia-zai\" class=\"header-anchor\">#</a></h3>\n<p>下面是对于加载过程最为官方的描述。</p>\n<p>加载阶段是类加载过程的第一个阶段。在这个阶段，JVM 的主要目的是将字节码从各个位置（网络、磁盘等）转化为二进制字节流加载到内存中，接着会为这个类在 JVM 的方法区创建一个对应的 Class 对象，这个 Class 对象就是这个类各种数据的访问入口。</p>\n<p>其实加载阶段用一句话来说就是：把代码数据加载到内存中。这个过程对于我们解答这道问题没有直接的关系，但这是类加载机制的一个过程，所以必须要提一下。</p>\n<h3><span id=\"yan-zheng\">验证</span><a href=\"#yan-zheng\" class=\"header-anchor\">#</a></h3>\n<p>当 JVM 加载完 Class 字节码文件并在方法区创建对应的 Class 对象之后，JVM 便会启动对该字节码流的校验，只有符合 JVM 字节码规范的文件才能被 JVM 正确执行。这个校验过程大致可以分为下面几个类型：</p>\n<p>JVM规范校验。JVM 会对字节流进行文件格式校验，判断其是否符合 JVM 规范，是否能被当前版本的虚拟机处理。例如：文件是否是以 0x cafe bene开头，主次版本号是否在当前虚拟机处理范围之内等。<br>\n代码逻辑校验。JVM 会对代码组成的数据流和控制流进行校验，确保 JVM 运行该字节码文件后不会出现致命错误。例如一个方法要求传入 int 类型的参数，但是使用它的时候却传入了一个 String 类型的参数。一个方法要求返回 String 类型的结果，但是最后却没有返回结果。代码中引用了一个名为 Apple 的类，但是你实际上却没有定义 Apple 类。<br>\n当代码数据被加载到内存中后，虚拟机就会对代码数据进行校验，看看这份代码是不是真的按照JVM规范去写的。这个过程对于我们解答问题也没有直接的关系，但是了解类加载机制必须要知道有这个过程。</p>\n<h3><span id=\"zhun-bei-chong-dian\">准备（重点）</span><a href=\"#zhun-bei-chong-dian\" class=\"header-anchor\">#</a></h3>\n<p>当完成字节码文件的校验之后，JVM 便会开始为类变量分配内存并初始化。这里需要注意两个关键点，即内存分配的对象以及初始化的类型。</p>\n<p>内存分配的对象。Java 中的变量有「类变量」和「类成员变量」两种类型，「类变量」指的是被 static 修饰的变量，而其他所有类型的变量都属于「类成员变量」。在准备阶段，JVM 只会为「类变量」分配内存，而不会为「类成员变量」分配内存。「类成员变量」的内存分配需要等到初始化阶段才开始。<br>\n例如下面的代码在准备阶段，只会为 factor 属性分配内存，而不会为 website 属性分配内存。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> factor = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span> String website = <span class=\"string\">&quot;www.cnblogs.com/chanshuyi&quot;</span>;</span><br></pre></td></tr></table></figure>\n<p>初始化的类型。在准备阶段，JVM 会为类变量分配内存，并为其初始化。但是这里的初始化指的是为变量赋予 Java 语言中该数据类型的零值，而不是用户代码里初始化的值。<br>\n例如下面的代码在准备阶段之后，sector 的值将是 0，而不是 3。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> sector = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n<p>但如果一个变量是常量（被 static final 修饰）的话，那么在准备阶段，属性便会被赋予用户希望的值。例如下面的代码在准备阶段之后，number 的值将是 3，而不是 0。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> number = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n<p>之所以 static final 会直接被复制，而 static 变量会被赋予零值。其实我们稍微思考一下就能想明白了。</p>\n<p>两个语句的区别是一个有 final 关键字修饰，另外一个没有。而 final 关键字在 Java 中代表不可改变的意思，意思就是说 number 的值一旦赋值就不会在改变了。既然一旦赋值就不会再改变，那么就必须一开始就给其赋予用户想要的值，因此被 final 修饰的类变量在准备阶段就会被赋予想要的值。而没有被 final 修饰的类变量，其可能在初始化阶段或者运行阶段发生变化，所以就没有必要在准备阶段对它赋予用户想要的值。</p>\n<h3><span id=\"jie-xi\">解析</span><a href=\"#jie-xi\" class=\"header-anchor\">#</a></h3>\n<p>当通过准备阶段之后，JVM 针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类引用进行解析。这个阶段的主要任务是将其在常量池中的符号引用替换成直接其在内存中的直接引用。</p>\n<p>其实这个阶段对于我们来说也是几乎透明的，了解一下就好。</p>\n<h3><span id=\"chu-shi-hua-chong-dian\">初始化（重点）</span><a href=\"#chu-shi-hua-chong-dian\" class=\"header-anchor\">#</a></h3>\n<p>到了初始化阶段，用户定义的 Java 程序代码才真正开始执行。在这个阶段，JVM 会根据语句执行顺序对类对象进行初始化，一般来说当 JVM 遇到下面 5 种情况的时候会触发初始化：</p>\n<p>遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。<br>\n使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。<br>\n当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。<br>\n当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。<br>\n当使用 JDK1.7 动态语言支持时，如果一个 java.lang.invoke.MethodHandle实例最后的解析结果 REF_getstatic,REF_putstatic,REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。</p>\n<h3><span id=\"shi-yong\">使用</span><a href=\"#shi-yong\" class=\"header-anchor\">#</a></h3>\n<p>当 JVM 完成初始化阶段之后，JVM 便开始从入口方法开始执行用户的程序代码。这个阶段也只是了解一下就可以。</p>\n<h3><span id=\"xie-zai\">卸载</span><a href=\"#xie-zai\" class=\"header-anchor\">#</a></h3>\n<p>当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存。这个阶段也只是了解一下就可以。</p>\n<p>看完了Java的类加载机智之后，是不是有点懵呢。不怕，我们先通过一个小例子来醒醒神。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Book</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Hello ShuYi.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Book()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;书的构造方法&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;price=&quot;</span> + price +<span class=\"string\">&quot;,amount=&quot;</span> + amount);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;书的普通代码块&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> price = <span class=\"number\">110</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;书的静态代码块&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> amount = <span class=\"number\">112</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>思考一下上面这段代码输出什么？</p>\n<p>书的静态代码块<br>\nHello ShuYi.<br>\n怎么样，你答对了吗？是不是和你想得有点不一样呢。</p>\n<p>下面我们来简单分析一下，首先根据上面说到的触发初始化的5种情况的第4种（当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类），我们会进行类的初始化。</p>\n<p>那么类的初始化顺序到底是怎么样的呢？</p>\n<p>在我们代码中，我们只知道有一个构造方法，但实际上Java代码编译成字节码之后，是没有构造方法的概念的，只有类初始化方法 和 对象初始化方法 。</p>\n<p>那么这两个方法是怎么来的呢？</p>\n<p>类初始化方法。编译器会按照其出现顺序，收集类变量的赋值语句、静态代码块，最终组成类初始化方法。类初始化方法一般在类初始化的时候执行。<br>\n上面的这个例子，其类初始化方法就是下面这段代码了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;书的静态代码块&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> amount = <span class=\"number\">112</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>对象初始化方法。编译器会按照其出现顺序，收集成员变量的赋值语句、普通代码块，最后收集构造函数的代码，最终组成对象初始化方法。对象初始化方法一般在实例化类对象的时候执行。<br>\n上面这个例子，其对象初始化方法就是下面这段代码了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;书的普通代码块&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">int</span> price = <span class=\"number\">110</span>;</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;书的构造方法&quot;</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;price=&quot;</span> + price +<span class=\"string\">&quot;,amount=&quot;</span> + amount);</span><br></pre></td></tr></table></figure>\n<p>类初始化方法 和 对象初始化方法 之后，我们再来看这个例子，我们就不难得出上面的答案了。</p>\n<p>但细心的朋友一定会发现，其实上面的这个例子其实没有执行对象初始化方法。</p>\n<p>因为我们确实没有进行 Book 类对象的实例化。如果你在 main 方法中增加 new Book() 语句，你会发现对象的初始化方法执行了！</p>\n<h2><span id=\"shi-me-shi-lei-zhuang-zai-qi-classloader\">什么是类装载器ClassLoader</span><a href=\"#shi-me-shi-lei-zhuang-zai-qi-classloader\" class=\"header-anchor\">#</a></h2>\n<ol>\n<li>ClassLoader是一个抽象类</li>\n<li>ClassLoader的实例将读入Java字节码将类装载到JVM中</li>\n<li>ClassLoader可以定制，满足不同的字节码流获取方式</li>\n<li>ClassLoader负责类装载过程中的加载阶段。</li>\n</ol>\n<h2><span id=\"jvm-zhong-de-lei-jia-zai-qi\">JVM中的类加载器</span><a href=\"#jvm-zhong-de-lei-jia-zai-qi\" class=\"header-anchor\">#</a></h2>\n<ol>\n<li>\n<p>启动类加载器（BootStrap ClassLoader）：引导类装入器是用本地代码实现的类装入器，它负责将 jdk中jre/lib下面的核心类库或-Xbootclasspath选项指定的jar包加载到内存中。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。</p>\n</li>\n<li>\n<p>扩展类加载器（Extension ClassLoader）：扩展类加载器是由Sun的ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将jdk中jre/lib/ext或者由系统变量-Djava.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。</p>\n</li>\n<li>\n<p>系统类加载器（System ClassLoader）：系统类加载器是由 Sun的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。它负责将系统类路径java -classpath或-Djava.class.path变量所指的目录下的类库加载到内存中。开发者可以直接使用系统类加载器。</p>\n</li>\n</ol>\n<p>下图中展示了类加载器直接的关系和双亲委派模型</p>\n<p><img src=\"/images/posts/2020/classloader2.webp\" alt=\"双亲委派模型\"></p>\n<p>从图中我们发现除启动类加载器外，每个加载器都有父的类加载器。</p>\n<blockquote>\n<p>双亲委派机制：如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。</p>\n</blockquote>\n<p>从类的继承关系来看，ExtClassLoader和AppClassLoader都是继承URLClassLoader，都是ClassLoader的子类。而BootStrapClassLoader是有C++写的，不再java的ClassLoader子类中。</p>\n<h2><span id=\"zi-ding-yi-lei-jia-zai-qi\">自定义类加载器</span><a href=\"#zi-ding-yi-lei-jia-zai-qi\" class=\"header-anchor\">#</a></h2>\n<p>前面提到了 Java 自带的加载器 BootstrapClassLoader、AppClassLoader和ExtClassLoader，这些都是 Java 已经提供好的。<br>\n而真正有意思的，是 自定义类加载器，它允许我们在运行时可以从本地磁盘或网络上动态加载自定义类。这使得开发者可以动态修复某些有问题的类，热更新代码。<br>\n下面来实现一个网络类加载器，这个加载器可以从网络上动态下载 .class 文件并加载到虚拟机中使用。<br>\n后面我还会写作与 热修复／动态更新 相关的文章，这里先学习 Java 层 NetworkClassLoader 相关的原理。</p>\n<p>作为一个 NetworkClassLoader，它首先要继承 ClassLoader；<br>\n然后它要实现ClassLoader内的 findClass() 方法。注意，不是loadClass()方法，因为ClassLoader提供了loadClass()（如上面的源码），它会基于双亲委托机制去搜索某个 class，直到搜索不到才会调用自身的findClass()，如果直接复写loadClass()，那还要实现双亲委托机制；<br>\n在 findClass() 方法里，要从网络上下载一个 .class 文件，然后转化成 Class 对象供虚拟机使用。</p>\n<p>具体实现代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Load class from network</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NetworkClassLoader</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClassLoader</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Class&lt;?&gt; findClass(String name) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] classData = downloadClassData(name); <span class=\"comment\">// 从远程下载</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (classData == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>.findClass(name); <span class=\"comment\">// 未找到，抛异常</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> defineClass(name, classData, <span class=\"number\">0</span>, classData.length); <span class=\"comment\">// convert class byte data to Class&lt;?&gt; object</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">byte</span>[] downloadClassData(String name) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从 localhost 下载 .class 文件</span></span><br><span class=\"line\">        String path = <span class=\"string\">&quot;http://localhost&quot;</span> + File.separatorChar + <span class=\"string\">&quot;java&quot;</span> + File.separatorChar + name.replace(<span class=\"string\">&#x27;.&#x27;</span>, File.separatorChar) + <span class=\"string\">&quot;.class&quot;</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            URL url = <span class=\"keyword\">new</span> URL(path);</span><br><span class=\"line\">            InputStream ins = url.openStream();</span><br><span class=\"line\">            ByteArrayOutputStream baos = <span class=\"keyword\">new</span> ByteArrayOutputStream();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> bufferSize = <span class=\"number\">4096</span>;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[bufferSize];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> bytesNumRead = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                baos.write(buffer, <span class=\"number\">0</span>, bytesNumRead); <span class=\"comment\">// 把下载的二进制数据存入 ByteArrayOutputStream</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> baos.toByteArray();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;Real NetworkClassLoader\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;networkClassLoader&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个类的作用是从网络上（这里是本人的 local apache 服务器 <a href=\"http://localhost/java\">http://localhost/java</a> 上）目录里去下载对应的 .class 文件，并转换成 Class&lt;?&gt; 返回回去使用。</p>\n<p>下面我们来利用这个 NetworkClassLoader 去加载 localhost 上的 MusicPlayer 类：</p>\n<p>首先把 MusicPlayer.class 放置于 /Library/WebServer/Documents/java （MacOS）目录下，由于 MacOS 自带 apache 服务器，这里是服务器的默认目录；执行下面一段代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String className = <span class=\"string\">&quot;classloader.NetworkClass&quot;</span>;</span><br><span class=\"line\">NetworkClassLoader networkClassLoader = <span class=\"keyword\">new</span> NetworkClassLoader();</span><br><span class=\"line\">Class&lt;?&gt; clazz  = networkClassLoader.loadClass(className);</span><br></pre></td></tr></table></figure>\n<p>正常运行，加载 <a href=\"http://localhost/java/classloader/MusicPlayer.class%E6%88%90%E5%8A%9F%E3%80%82%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%87%BA\">http://localhost/java/classloader/MusicPlayer.class成功。可以看出</a> NetworkClassLoader 可以正常工作，如果读者要用的话，只要稍微修改 url 的拼接方式即可自行使用。</p>\n<h1><span id=\"xiao-jie\">小结</span><a href=\"#xiao-jie\" class=\"header-anchor\">#</a></h1>\n<p>类加载方式是 Java 上非常创新的一项技术，给未来的热修复技术提供了可能。本文力求通过简单的语言和合适的例子来讲解其中双亲委托机制、自定义加载器等，并开发了自定义的NetworkClassLoader。当然，类加载是很有意思的技术，很难覆盖所有知识点，比如不同类加载器加载同一个类，得到的实例却不是同一个等等。</p>\n<h2><span id=\"shuang-qin-wei-pai-mo-xing-de-hao-chu\">双亲委派模型的好处</span><a href=\"#shuang-qin-wei-pai-mo-xing-de-hao-chu\" class=\"header-anchor\">#</a></h2>\n<p>Java类随着加载它的类加载器一起具备了一种带有优先级的层次关系。比如，Java中的Object类，它存放在rt.jar之中,无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object在各种类加载环境中都是同一个类。如果不采用双亲委派模型，那么由各个类加载器自己取加载的话，那么系统中会存在多种不同的Object类。</p>\n<h1><span id=\"can-kao\">参考</span><a href=\"#can-kao\" class=\"header-anchor\">#</a></h1>\n<ol>\n<li><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html\">深入探讨 Java 类加载器</a></li>\n</ol>\n<link rel=\"stylesheet\" href=\"/css/markmap.css\" type=\"text/css\">","tags":[{"name":"JVM","slug":"JVM","permalink":"https://blog.beyhub.com/tags/JVM/"}]},{"title":"Synchronized修饰静态方法和非静态方法总结","path":"post/synchronized修饰静态方法和非静态方法总结/","text":"synchronized 的本质就是一个可重入锁，大致分为以下两类 有对象锁 synchronized(this),或者非静态方法上加synchronized修饰 类锁 synchronized(XX.class),或者静态方法上加synchronized修饰 Synchronized修饰非静态方法，实际上是对调用该方法的对象加锁，俗称“对象锁”# Java中每个对象都有一个锁，并且是唯一的。假设分配的一个对象空间，里面有多个方法，相当于空间里面有多个小房间，如果我们把所有的小房间都加锁，因为这个对象只有一把钥匙，因此同一时间只能有一个人打开一个小房间，然后用完了还回去，再由JVM 去分配下一个获得钥匙的人。 情况1：同一个对象在两个线程中分别访问该对象的两个同步方法 结果：会产生互斥。 解释：因为锁针对的是对象，当对象调用一个synchronized方法时，其他同步方法需要等待其执行结束并释放锁后才能执行。 情况2：不同对象在两个线程中调用同一个同步方法 结果：不会产生互斥。 解释：因为是两个对象，锁针对的是对象，并不是方法，所以可以并发执行，不会互斥。形象的来说就是因为我们每个线程在调用方法的时候都是new 一个对象，那么就会出现两个空间，两把钥匙， Synchronized修饰静态方法，实际上是对该类对象加锁，俗称“类锁”# 情况1：用类直接在两个线程中调用两个不同的同步方法 结果：会产生互斥。 解释：因为对静态对象加锁实际上对类（.class）加锁，类对象只有一个，可以理解为任何时候都只有一个空间，里面有N个房间，一把锁，因此房间（同步方法）之间一定是互斥的。 注：上述情况和用单例模式声明一个对象来调用非静态方法的情况是一样的，因为永远就只有这一个对象。所以访问同步方法之间一定是互斥的。 情况2：用一个类的静态对象在两个线程中调用静态方法或非静态方法 结果：会产生互斥。 解释：因为是一个对象调用，同上。 情况3：一个对象在两个线程中分别调用一个静态同步方法和一个非静态同步方法 结果：不会产生互斥。 解释：因为虽然是一个对象调用，但是两个方法的锁类型不同，调用的静态方法实际上是类对象在调用，即这两个方法产生的并不是同一个对象锁，因此不会互斥，会并发执行。 测试代码： 同步方法类：SynchronizedTest.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class SynchronizedTest &#123; /*private SynchronizedTest()&#123;&#125; private static SynchronizedTest st; //懒汉式单例模式，线程不安全，需要加synchronized同步 public static SynchronizedTest getInstance()&#123; if(st == null)&#123; st = new SynchronizedTest(); &#125; return st; &#125;*/ /*private SynchronizedTest()&#123;&#125; private static final SynchronizedTest st = new SynchronizedTest(); //饿汉式单利模式，天生线程安全 public static SynchronizedTest getInstance()&#123; return st; &#125;*/ public static SynchronizedTest staticIn = new SynchronizedTest(); //静态对象 public synchronized void method1()&#123; //非静态方法1 for(int i = 0;i &lt; 10;i++)&#123; System.out.println(&quot;method1 is running!&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; public synchronized void method2()&#123; //非静态方法2 for( int i = 0; i &lt; 10 ; i++)&#123; System.out.println(&quot;method2 is running!&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; public synchronized static void staticMethod1()&#123; //静态方法1 for( int i = 0; i &lt; 10 ; i++)&#123; System.out.println(&quot;static method1 is running!&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; public synchronized static void staticMethod2()&#123; //静态方法2 for( int i = 0; i &lt; 10 ; i++)&#123; System.out.println(&quot;static method2 is running!&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; 线程类1：Thread1.java（释放不同的注释可以测试不同的情况） 1234567891011121314public class Thread1 implements Runnable&#123; @Override public void run() &#123;// SynchronizedTest s = SynchronizedTest.getInstance();// s.method1();// SynchronizedTest s1 = new SynchronizedTest();// s1.method1(); SynchronizedTest.staticIn.method1(); // SynchronizedTest.staticMethod1();// SynchronizedTest.staticMethod2(); &#125;&#125; 12345678910111213141516线程类2：Thread2.Javapublic class Thread2 implements Runnable&#123; @Override public void run() &#123; // TODO Auto-generated method stub// SynchronizedTest s = SynchronizedTest.getInstance();// SynchronizedTest s2 = new SynchronizedTest();// s2.method1();// s.method2();// SynchronizedTest.staticMethod1();// SynchronizedTest.staticMethod2();// SynchronizedTest.staticIn.method2(); SynchronizedTest.staticIn.staticMethod1(); &#125;&#125; 主类：ThreadMain.java 1234567891011121314import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors; public class ThreadMain &#123; public static void main(String[] args) &#123; Thread t1 = new Thread(new Thread1()); Thread t2 = new Thread(new Thread2()); ExecutorService exec = Executors.newCachedThreadPool(); exec.execute(t1); exec.execute(t2); exec.shutdown(); &#125; &#125; 总结# 对象锁钥匙只能有一把才能互斥，才能保证共享变量的唯一性 在静态方法上的锁，和 实例方法上的锁，默认不是同样的，如果同步需要制定两把锁一样。 关于同一个类的方法上的锁，来自于调用该方法的对象，如果调用该方法的对象是相同的，那么锁必然相同，否则就不相同。比如 new A().x() 和 new A().x(),对象不同，锁不同，如果A的单利的，就能互斥。 静态方法加锁，能和所有其他静态方法加锁的 进行互斥 静态方法加锁，和xx.class 锁效果一样，直接属于类的","content":"<p>synchronized 的本质就是一个可重入锁，大致分为以下两类</p>\n<ol>\n<li>有对象锁 synchronized(this),或者非静态方法上加synchronized修饰</li>\n<li>类锁 synchronized(XX.class),或者静态方法上加synchronized修饰</li>\n</ol>\n<span id=\"more\"></span>\n<h2><span id=\"synchronized-xiu-shi-fei-jing-tai-fang-fa-shi-ji-shang-shi-dui-diao-yong-gai-fang-fa-de-dui-xiang-jia-suo-su-cheng-dui-xiang-suo\">Synchronized修饰非静态方法，实际上是对调用该方法的对象加锁，俗称“对象锁”</span><a href=\"#synchronized-xiu-shi-fei-jing-tai-fang-fa-shi-ji-shang-shi-dui-diao-yong-gai-fang-fa-de-dui-xiang-jia-suo-su-cheng-dui-xiang-suo\" class=\"header-anchor\">#</a></h2>\n<p>Java中每个对象都有一个锁，并且是唯一的。假设分配的一个对象空间，里面有多个方法，相当于空间里面有多个小房间，如果我们把所有的小房间都加锁，因为这个对象只有一把钥匙，因此同一时间只能有一个人打开一个小房间，然后用完了还回去，再由JVM 去分配下一个获得钥匙的人。</p>\n<p>情况1：同一个对象在两个线程中分别访问该对象的两个同步方法<br>\n结果：会产生互斥。<br>\n解释：因为锁针对的是对象，当对象调用一个synchronized方法时，其他同步方法需要等待其执行结束并释放锁后才能执行。</p>\n<p>情况2：不同对象在两个线程中调用同一个同步方法<br>\n结果：不会产生互斥。<br>\n解释：因为是两个对象，锁针对的是对象，并不是方法，所以可以并发执行，不会互斥。形象的来说就是因为我们每个线程在调用方法的时候都是new 一个对象，那么就会出现两个空间，两把钥匙，</p>\n<h2><span id=\"synchronized-xiu-shi-jing-tai-fang-fa-shi-ji-shang-shi-dui-gai-lei-dui-xiang-jia-suo-su-cheng-lei-suo\">Synchronized修饰静态方法，实际上是对该类对象加锁，俗称“类锁”</span><a href=\"#synchronized-xiu-shi-jing-tai-fang-fa-shi-ji-shang-shi-dui-gai-lei-dui-xiang-jia-suo-su-cheng-lei-suo\" class=\"header-anchor\">#</a></h2>\n<p>情况1：用类直接在两个线程中调用两个不同的同步方法<br>\n结果：会产生互斥。<br>\n解释：因为对静态对象加锁实际上对类（.class）加锁，类对象只有一个，可以理解为任何时候都只有一个空间，里面有N个房间，一把锁，因此房间（同步方法）之间一定是互斥的。</p>\n<p>注：上述情况和用单例模式声明一个对象来调用非静态方法的情况是一样的，因为永远就只有这一个对象。所以访问同步方法之间一定是互斥的。</p>\n<p>情况2：用一个类的静态对象在两个线程中调用静态方法或非静态方法<br>\n结果：会产生互斥。<br>\n解释：因为是一个对象调用，同上。</p>\n<p>情况3：一个对象在两个线程中分别调用一个静态同步方法和一个非静态同步方法<br>\n结果：不会产生互斥。<br>\n解释：因为虽然是一个对象调用，但是两个方法的锁类型不同，调用的静态方法实际上是类对象在调用，即这两个方法产生的并不是同一个对象锁，因此不会互斥，会并发执行。</p>\n<p>测试代码：<br>\n同步方法类：SynchronizedTest.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SynchronizedTest</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/*private SynchronizedTest()&#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\tprivate static SynchronizedTest st;           //懒汉式单例模式，线程不安全，需要加synchronized同步</span></span><br><span class=\"line\"><span class=\"comment\">\tpublic static SynchronizedTest getInstance()&#123;</span></span><br><span class=\"line\"><span class=\"comment\">\t\tif(st == null)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\tst = new SynchronizedTest();</span></span><br><span class=\"line\"><span class=\"comment\">\t\t&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t\treturn st;</span></span><br><span class=\"line\"><span class=\"comment\">\t&#125;*/</span></span><br><span class=\"line\">\t<span class=\"comment\">/*private SynchronizedTest()&#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\tprivate static final SynchronizedTest st = new SynchronizedTest();  //饿汉式单利模式，天生线程安全</span></span><br><span class=\"line\"><span class=\"comment\">\tpublic static SynchronizedTest getInstance()&#123;</span></span><br><span class=\"line\"><span class=\"comment\">\t\treturn st;</span></span><br><span class=\"line\"><span class=\"comment\">\t&#125;*/</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SynchronizedTest staticIn = <span class=\"keyword\">new</span> SynchronizedTest();   <span class=\"comment\">//静态对象</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">method1</span><span class=\"params\">()</span></span>&#123;                                      <span class=\"comment\">//非静态方法1</span></span><br><span class=\"line\">    \t <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; <span class=\"number\">10</span>;i++)&#123;  </span><br><span class=\"line\">    \t\t System.out.println(<span class=\"string\">&quot;method1 is running!&quot;</span>);</span><br><span class=\"line\">    \t\t <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// TODO Auto-generated catch block</span></span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">    \t &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">method2</span><span class=\"params\">()</span></span>&#123;                                   <span class=\"comment\">//非静态方法2</span></span><br><span class=\"line\">    \t <span class=\"keyword\">for</span>( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span> ; i++)&#123;</span><br><span class=\"line\">    \t\t System.out.println(<span class=\"string\">&quot;method2 is running!&quot;</span>);</span><br><span class=\"line\">    \t\t <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// TODO Auto-generated catch block</span></span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">    \t &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">staticMethod1</span><span class=\"params\">()</span></span>&#123;                     <span class=\"comment\">//静态方法1</span></span><br><span class=\"line\">    \t<span class=\"keyword\">for</span>( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span> ; i++)&#123;</span><br><span class=\"line\">   \t\t System.out.println(<span class=\"string\">&quot;static method1 is running!&quot;</span>);</span><br><span class=\"line\">   \t\t <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// TODO Auto-generated catch block</span></span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">   \t &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">staticMethod2</span><span class=\"params\">()</span></span>&#123;                      <span class=\"comment\">//静态方法2</span></span><br><span class=\"line\">    \t<span class=\"keyword\">for</span>( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span> ; i++)&#123;</span><br><span class=\"line\">   \t\t System.out.println(<span class=\"string\">&quot;static method2 is running!&quot;</span>);</span><br><span class=\"line\">   \t\t <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// TODO Auto-generated catch block</span></span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">   \t &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>线程类1：Thread1.java（释放不同的注释可以测试不同的情况）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Thread1</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//\t\tSynchronizedTest s = SynchronizedTest.getInstance();</span></span><br><span class=\"line\"><span class=\"comment\">//\t\ts.method1();</span></span><br><span class=\"line\"><span class=\"comment\">//\t\tSynchronizedTest s1 = new SynchronizedTest();</span></span><br><span class=\"line\"><span class=\"comment\">//\t\ts1.method1();</span></span><br><span class=\"line\">\t\tSynchronizedTest.staticIn.method1();</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//\t\tSynchronizedTest.staticMethod1();</span></span><br><span class=\"line\"><span class=\"comment\">//\t\tSynchronizedTest.staticMethod2();</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">线程类<span class=\"number\">2</span>：Thread2.Java</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Thread2</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\"><span class=\"comment\">//\t\tSynchronizedTest s = SynchronizedTest.getInstance();</span></span><br><span class=\"line\"><span class=\"comment\">//\t\tSynchronizedTest s2 = new SynchronizedTest();</span></span><br><span class=\"line\"><span class=\"comment\">//\t\ts2.method1();</span></span><br><span class=\"line\"><span class=\"comment\">//\t\ts.method2();</span></span><br><span class=\"line\"><span class=\"comment\">//\t\tSynchronizedTest.staticMethod1();</span></span><br><span class=\"line\"><span class=\"comment\">//\t\tSynchronizedTest.staticMethod2();</span></span><br><span class=\"line\"><span class=\"comment\">//\t\tSynchronizedTest.staticIn.method2();</span></span><br><span class=\"line\">\t\tSynchronizedTest.staticIn.staticMethod1();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>主类：ThreadMain.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ExecutorService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Executors;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadMain</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\tThread t1 = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Thread1());</span><br><span class=\"line\">        Thread t2 = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Thread2());</span><br><span class=\"line\">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class=\"line\">        exec.execute(t1);</span><br><span class=\"line\">        exec.execute(t2);</span><br><span class=\"line\">        exec.shutdown();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"zong-jie\">总结</span><a href=\"#zong-jie\" class=\"header-anchor\">#</a></h2>\n<ol>\n<li>对象锁钥匙只能有一把才能互斥，才能保证共享变量的唯一性</li>\n<li>在静态方法上的锁，和 实例方法上的锁，默认不是同样的，如果同步需要制定两把锁一样。</li>\n<li>关于同一个类的方法上的锁，来自于调用该方法的对象，如果调用该方法的对象是相同的，那么锁必然相同，否则就不相同。比如 new A().x() 和 new A().x(),对象不同，锁不同，如果A的单利的，就能互斥。</li>\n<li>静态方法加锁，能和所有其他静态方法加锁的 进行互斥</li>\n<li>静态方法加锁，和xx.class 锁效果一样，直接属于类的</li>\n</ol>\n<link rel=\"stylesheet\" href=\"/css/markmap.css\" type=\"text/css\">","tags":[{"name":"锁","slug":"锁","permalink":"https://blog.beyhub.com/tags/%E9%94%81/"}]},{"title":"Java中ArrayList和LinkedList的区别","path":"post/java中arraylist和linkedlist的区别/","text":"从数据结构上看，顾名思义，ArrayList是实现了基于动态数组的结构，而LinkedList则是基于实现链表的数据结构。而两种数据结构在程序上体现出来的优缺点在于增删和改查的速率，就此，我们分别作出说明。 数据的更新和查找# ArrayList的所有数据是在同一个地址上,而LinkedList的每个数据都拥有自己的地址。所以在对数据进行查找的时候，由于LinkedList的每个数据地址不一样，get数据的时候ArrayList的速度会优于LinkedList，而更新数据的时候，虽然都是通过循环循环到指定节点修改数据，但LinkedList的查询速度已经是慢的，而且对于LinkedList而言，更新数据时不像ArrayList只需要找到对应下标更新就好，LinkedList需要修改指针，速率不言而喻 数据的增加和删除# 对于数据的增加元素，ArrayList是通过移动该元素之后的元素位置，其后元素位置全部+1，所以耗时较长，而LinkedList只需要将该元素前的后续指针指向该元素并将该元素的后续指针指向之后的元素即可。与增加相同，删除元素时ArrayList需要将被删除元素之后的元素位置-1，而LinkedList只需要将之后的元素前置指针指向前一元素，前一元素的指针指向后一元素即可。当然，事实上，若是单一元素的增删，尤其是在List末端增删一个元素，二者效率不相上下。 下面我们通过程序检验结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public static final int N = 50000;static void getTime(List list) &#123; insertByPosition(list); readByPosition(list); updateByPosition(list); deleteByPosition(list);&#125;// 向list的指定位置插入N个元素，并统计时间private static void insertByPosition(List list) &#123; long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; N; i++) list.add(0, i); long endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println(getListName(list) + &quot;插入&quot; + N + &quot;条数据耗时：&quot; + interval + &quot; ms&quot;);&#125;//从list中读取元素，并统计时间private static void readByPosition(List list) &#123; long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; N; i++)&#123; list.get(i); &#125; long endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println(getListName(list) + &quot;查询&quot; + N + &quot;条数据耗时：&quot; + interval + &quot;ms&quot;);&#125;// 从list的随机位置修改元素，并统计时间private static void updateByPosition(List list) &#123; long startTime = System.currentTimeMillis(); int M = 40000; for(int i=0;i&lt;40000;i++)&#123; int j = (int)(1+Math.random()*(40000-1+1)); list.set(j, &quot;list&quot;); &#125; long endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println(getListName(list) + &quot;随机修改&quot; + M + &quot;条数据耗时&quot; + interval + &quot; ms&quot;);&#125;// 从list的指定位置删除N个元素，并统计时间private static void deleteByPosition(List list) &#123; long startTime = System.currentTimeMillis(); // 删除list第一个位置元素 for (int i = 0; i &lt; N; i++) list.remove(0); long endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println(getListName(list) + &quot;删除&quot; + N + &quot;条数据耗时&quot; + interval + &quot; ms&quot;);&#125;//获取list类型名称private static String getListName(List list) &#123; if (list instanceof LinkedList) &#123; return &quot;LinkedList&quot;; &#125; else if (list instanceof ArrayList) &#123; return &quot;ArrayList&quot;; &#125; else &#123; return &quot;error&quot;; &#125;&#125;public static void main(String[] args) &#123; getTime(new ArrayList()); getTime(new LinkedList());&#125; 然后在我本机的运行结果如下： 由此可见在程序执行过程中，对大量数据的增删改查时就会面临效率问题，所以对于ArrayList和LinkedList的选择，多数情况下如果查询操作较多ArrayList的效果更好.如果删除,插入较多LinkedList的效果较好.当然，具体怎么用还看具体的需求.","content":"<p>从数据结构上看，顾名思义，ArrayList是实现了基于动态数组的结构，而LinkedList则是基于实现链表的数据结构。而两种数据结构在程序上体现出来的优缺点在于增删和改查的速率，就此，我们分别作出说明。</p>\n<span id=\"more\"></span>\n<h2><span id=\"shu-ju-de-geng-xin-he-cha-zhao\">数据的更新和查找</span><a href=\"#shu-ju-de-geng-xin-he-cha-zhao\" class=\"header-anchor\">#</a></h2>\n<p>ArrayList的所有数据是在同一个地址上,而LinkedList的每个数据都拥有自己的地址。所以在对数据进行查找的时候，由于LinkedList的每个数据地址不一样，get数据的时候ArrayList的速度会优于LinkedList，而更新数据的时候，虽然都是通过循环循环到指定节点修改数据，但LinkedList的查询速度已经是慢的，而且对于LinkedList而言，更新数据时不像ArrayList只需要找到对应下标更新就好，LinkedList需要修改指针，速率不言而喻</p>\n<h2><span id=\"shu-ju-de-zeng-jia-he-shan-chu\">数据的增加和删除</span><a href=\"#shu-ju-de-zeng-jia-he-shan-chu\" class=\"header-anchor\">#</a></h2>\n<p>对于数据的增加元素，ArrayList是通过移动该元素之后的元素位置，其后元素位置全部+1，所以耗时较长，而LinkedList只需要将该元素前的后续指针指向该元素并将该元素的后续指针指向之后的元素即可。与增加相同，删除元素时ArrayList需要将被删除元素之后的元素位置-1，而LinkedList只需要将之后的元素前置指针指向前一元素，前一元素的指针指向后一元素即可。当然，事实上，若是单一元素的增删，尤其是在List末端增删一个元素，二者效率不相上下。</p>\n<p>下面我们通过程序检验结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> N = <span class=\"number\">50000</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">getTime</span><span class=\"params\">(List list)</span> </span>&#123;</span><br><span class=\"line\">    insertByPosition(list);</span><br><span class=\"line\">    readByPosition(list);</span><br><span class=\"line\">    updateByPosition(list);</span><br><span class=\"line\">    deleteByPosition(list);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 向list的指定位置插入N个元素，并统计时间</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">insertByPosition</span><span class=\"params\">(List list)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++)</span><br><span class=\"line\">        list.add(<span class=\"number\">0</span>, i);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> endTime = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> interval = endTime - startTime;</span><br><span class=\"line\">    System.out.println(getListName(list) + <span class=\"string\">&quot;插入&quot;</span> + N + <span class=\"string\">&quot;条数据耗时：&quot;</span> + interval</span><br><span class=\"line\">            + <span class=\"string\">&quot; ms&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//从list中读取元素，并统计时间</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">readByPosition</span><span class=\"params\">(List list)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++)&#123;</span><br><span class=\"line\">        list.get(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> endTime = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> interval = endTime - startTime;</span><br><span class=\"line\">    System.out.println(getListName(list) + <span class=\"string\">&quot;查询&quot;</span> + N + <span class=\"string\">&quot;条数据耗时：&quot;</span> + interval</span><br><span class=\"line\">            + <span class=\"string\">&quot;ms&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从list的随机位置修改元素，并统计时间</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">updateByPosition</span><span class=\"params\">(List list)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> M = <span class=\"number\">40000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">40000</span>;i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = (<span class=\"keyword\">int</span>)(<span class=\"number\">1</span>+Math.random()*(<span class=\"number\">40000</span>-<span class=\"number\">1</span>+<span class=\"number\">1</span>));</span><br><span class=\"line\">    list.set(j, <span class=\"string\">&quot;list&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> endTime = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> interval = endTime - startTime;</span><br><span class=\"line\">    System.out.println(getListName(list) + <span class=\"string\">&quot;随机修改&quot;</span> + M + <span class=\"string\">&quot;条数据耗时&quot;</span> + interval</span><br><span class=\"line\">            + <span class=\"string\">&quot; ms&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从list的指定位置删除N个元素，并统计时间</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteByPosition</span><span class=\"params\">(List list)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"comment\">// 删除list第一个位置元素</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++)</span><br><span class=\"line\">        list.remove(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> endTime = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> interval = endTime - startTime;</span><br><span class=\"line\">    System.out.println(getListName(list) + <span class=\"string\">&quot;删除&quot;</span> + N + <span class=\"string\">&quot;条数据耗时&quot;</span> + interval</span><br><span class=\"line\">            + <span class=\"string\">&quot; ms&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取list类型名称</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String <span class=\"title\">getListName</span><span class=\"params\">(List list)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (list <span class=\"keyword\">instanceof</span> LinkedList) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;LinkedList&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (list <span class=\"keyword\">instanceof</span> ArrayList) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;ArrayList&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;error&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    getTime(<span class=\"keyword\">new</span> ArrayList());</span><br><span class=\"line\">    getTime(<span class=\"keyword\">new</span> LinkedList());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后在我本机的运行结果如下：</p>\n<p><img src=\"/images/posts/2020/arraylist-linkedlist.webp\" alt></p>\n<blockquote>\n<p>由此可见在程序执行过程中，对大量数据的增删改查时就会面临效率问题，所以对于ArrayList和LinkedList的选择，多数情况下如果查询操作较多ArrayList的效果更好.如果删除,插入较多LinkedList的效果较好.当然，具体怎么用还看具体的需求.</p>\n</blockquote>\n<link rel=\"stylesheet\" href=\"/css/markmap.css\" type=\"text/css\">","tags":[{"name":"原理","slug":"原理","permalink":"https://blog.beyhub.com/tags/%E5%8E%9F%E7%90%86/"}]},{"title":"MySQL中事务隔离的级别","path":"post/mysql中事务隔离的级别/","text":"数据库事务（简称:事务）是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。事务的使用是数据库管理系统区别文件系统的重要特征之一。事务拥有四个重要的特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability），人们习惯称之为 ACID 特性。下面我逐一对其进行解释。 事务的四个特征# 原子性（Atomicity）# 事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。例如，如果一个事务需要新增 100 条记录，但是在新增了 10 条记录之后就失败了，那么数据库将回滚对这 10 条新增的记录。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。 一致性（Consistency）# 指事务将数据库从一种状态转变为另一种一致的的状态。事务开始前和结束后，数据库的完整性约束没有被破坏。例如工号带有唯一属性，如果经过一个修改工号的事务后，工号变的非唯一了，则表明一致性遭到了破坏。 隔离性（Isolation）# 要求每个读写事务的对象对其他事务的操作对象能互相分离，即该事务提交前对其他事务不可见。 也可以理解为多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。这指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。例如一个用户在更新自己的个人信息的同时，是不能看到系统管理员也在更新该用户的个人信息（此时更新事务还未提交）。 注：MySQL 通过锁机制来保证事务的隔离性。 持久性（Durability）# 事务一旦提交，则其结果就是永久性的。即使发生宕机的故障，数据库也能将数据恢复，也就是说事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。这只是从事务本身的角度来保证，排除 RDBMS（关系型数据库管理系统，例如 Oracle、MySQL 等）本身发生的故障。 注：MySQL 使用 redo log 来保证事务的持久性。 事务的隔离级别# SQL 标准定义的四种隔离级别被 ANSI（美国国家标准学会）和 ISO/IEC（国际标准）采用，每种级别对事务的处理能力会有不同程度的影响。 我们分别对四种隔离级别从并发程度由高到低进行描述，并用代码进行演示，数据库环境为 MySQL 5.7。 READ UNCOMMITTED（读未提交）# 该隔离级别的事务会读到其它未提交事务的数据，此现象也称之为脏读。 准备两个终端，在此命名为 mysql 终端 1 和 mysql 终端 2，再准备一张测试表 test，写入一条测试数据并调整隔离级别为 READ UNCOMMITTED，任意一个终端执行即可。 12345SET @@session.transaction_isolation = &#x27;READ-UNCOMMITTED&#x27;;create database test;use test; 12create table test(id int primary key);insert into test(id) values(1); 登录 mysql 终端 1，开启一个事务，将 ID 为 1 的记录更新为 2。 12begin;update test set id = 2 where id = 1; 1select * from test; -- 此时看到一条ID为2的记录 登录 mysql 终端 2，开启一个事务后查看表中的数据。 12use test;begin; 1select * from test; -- 此时看到一条 ID 为 2 的记录 最后一步读取到了 mysql 终端 1 中未提交的事务（没有 commit 提交动作），即产生了脏读，大部分业务场景都不允许脏读出现，但是此隔离级别下数据库的并发是最好的。 READ COMMITTED（读提交）# 一个事务可以读取另一个已提交的事务，多次读取会造成不一样的结果，此现象称为不可重复读问题，Oracle 和 SQL Server 的默认隔离级别。 准备两个终端，在此命名为 mysql 终端 1 和 mysql 终端 2，再准备一张测试表 test，写入一条测试数据并调整隔离级别为 READ COMMITTED，任意一个终端执行即可。 12345SET @@session.transaction_isolation = &#x27;READ-COMMITTED&#x27;;create database test;use test;create table test(id int primary key);insert into test(id) values(1); 登录 mysql 终端 1，开启一个事务，将 ID 为 1 的记录更新为 2，并确认记录数变更过来。 123begin;update test set id = 2 where id = 1;select * from test; -- 此时看到一条记录为 2 登录 mysql 终端 2，开启一个事务后，查看表中的数据。 123use test;begin;select * from test; -- 此时看一条 ID 为 1 的记录 登录 mysql 终端 1，提交事务。 1commit; 切换到 mysql 终端 2。 12select * from test; -- 此时看到一条 ID 为 2 的记录 mysql 终端 2 在开启了一个事务之后，在第一次读取 test 表（此时 mysql 终端 1 的事务还未提交）时 ID 为 1，在第二次读取 test 表（此时 mysql 终端 1 的事务已经提交）时 ID 已经变为 2，说明在此隔离级别下已经读取到已提交的事务。 REPEATABLE READ（可重复读）# 该隔离级别是 MySQL 默认的隔离级别，在同一个事务里，select 的结果是事务开始时时间点的状态，因此，同样的 select 操作读到的结果会是一致的，但是，会有幻读现象。MySQL 的 InnoDB 引擎可以通过 next-key locks 机制（参考下文&quot;行锁的算法&quot;一节）来避免幻读。 准备两个终端，在此命名为 mysql 终端 1 和 mysql 终端 2，准备一张测试表 test 并调整隔离级别为 REPEATABLE READ，任意一个终端执行即可。 1234SET @@session.transaction_isolation = &#x27;REPEATABLE-READ&#x27;;create database test;use test;create table test(id int primary key,name varchar(20)); 登录 mysql 终端 1，开启一个事务。 12begin;select * from test; -- 无记录 登录 mysql 终端 2，开启一个事务。 12begin;select * from test; -- 无记录 切换到 mysql 终端 1，增加一条记录并提交。 123insert into test(id,name) values(1,&#x27;a&#x27;);commit; 切换到 msyql 终端 2。 1select * from test; --此时查询还是无记录 通过这一步可以证明，在该隔离级别下已经读取不到别的已提交的事务，如果想看到 mysql 终端 1 提交的事务，在 mysql 终端 2 将当前事务提交后再次查询就可以读取到 mysql 终端 1 提交的事务。我们接着实验，看看在该隔离级别下是否会存在别的问题。 此时接着在 mysql 终端 2 插入一条数据。 1insert into test(id,name) values(1,&#x27;b&#x27;); -- 此时报主键冲突的错误 也许到这里您心里可能会有疑问，明明在第 5 步没有数据，为什么在这里会报错呢？其实这就是该隔离级别下可能产生的问题，MySQL 称之为幻读。注意我在这里强调的是 MySQL 数据库，Oracle 数据库对于幻读的定义可能有所不同。 SERIALIZABLE（序列化）# 在该隔离级别下事务都是串行顺序执行的，MySQL 数据库的 InnoDB 引擎会给读操作隐式加一把读共享锁，从而避免了脏读、不可重读复读和幻读问题。 准备两个终端，在此命名为 mysql 终端 1 和 mysql 终端 2，分别登入 mysql，准备一张测试表 test 并调整隔离级别为 SERIALIZABLE，任意一个终端执行即可。 1234SET @@session.transaction_isolation = &#x27;SERIALIZABLE&#x27;;create database test;use test;create table test(id int primary key); 登录 mysql 终端 1，开启一个事务，并写入一条数据。 12begin;insert into test(id) values(1); 登录 mysql 终端 2，开启一个事务。 12begin;select * from test; -- 此时会一直卡住 立马切换到 mysql 终端 1,提交事务。 1commit; 一旦事务提交，msyql 终端 2 会立马返回 ID 为 1 的记录，否则会一直卡住，直到超时，其中超时参数是由 innodb_lock_wait_timeout 控制。由于每条 select 语句都会加锁，所以该隔离级别的数据库并发能力最弱，但是有些资料表明该结论也不一定对，如果感兴趣，您可以自行做个压力测试。 表 1 总结了各个隔离级别下产生的一些问题。 隔离级别 脏读 不可重复读 幻读 读未提交 可以出现 可以出现 可以出现 读提交 不允许出现 可以出现 可以出现 可重复读 不允许出现 不允许出现 可以出现 序列化 不允许出现 不允许出现 不允许出现 MySQL 中的锁# 锁也是数据库管理系统区别文件系统的重要特征之一。锁机制使得在对数据库进行并发访问时，可以保障数据的完整性和一致性。对于锁的实现，各个数据库厂商的实现方法都会有所不同。本文讨论 MySQL 中的 InnoDB 引擎的锁。 锁的类型# InnoDB 实现了两种类型的行级锁： 共享锁（也称为 S 锁）：允许事务读取一行数据。# 可以使用 SQL 语句 select * from tableName where … lock in share mode; 手动加 S 锁。 独占锁（也称为 X 锁）：允许事务删除或更新一行数据。# 可以使用 SQL 语句 select * from tableName where … for update; 手动加 X 锁。 S 锁和 S 锁是兼容的，X 锁和其它锁都不兼容，举个例子，事务 T1 获取了一个行 r1 的 S 锁，另外事务 T2 可以立即获得行 r1 的 S 锁，此时 T1 和 T2 共同获得行 r1 的 S 锁，此种情况称为锁兼容，但是另外一个事务 T2 此时如果想获得行 r1 的 X 锁，则必须等待 T1 对行 r 锁的释放，此种情况也成为锁冲突。 为了实现多粒度的锁机制，InnoDB 还有两种内部使用的意向锁，由 InnoDB 自动添加，且都是表级别的锁。 意向共享锁（IS）：事务即将给表中的各个行设置共享锁，事务给数据行加 S 锁前必须获得该表的 IS 锁。 意向排他锁（IX）：事务即将给表中的各个行设置排他锁，事务给数据行加 X 锁前必须获得该表 IX 锁。 意向锁的主要目的是为了使得行锁和表锁共存。表 2 列出了行级锁和表级意向锁的兼容性。 表 2. 行级锁和表级意向锁的兼容性 锁类型 X IX S IS X 冲突 冲突 冲突 冲突 IX 冲突 兼容 冲突 兼容 S 冲突 冲突 兼容 兼容 IS 冲突 兼容 兼容 兼容 行锁的算法# InnoDB 存储引擎使用三种行锁的算法用来满足相关事务隔离级别的要求。 Record Locks# 该锁为索引记录上的锁，如果表中没有定义索引，InnoDB 会默认为该表创建一个隐藏的聚簇索引，并使用该索引锁定记录。 Gap Locks# 该锁会锁定一个范围，但是不括记录本身。可以通过修改隔离级别为 READ COMMITTED 或者配置 innodb_locks_unsafe_for_binlog 参数为 ON。 Next-key Locks# 该锁就是 Record Locks 和 Gap Locks 的组合，即锁定一个范围并且锁定该记录本身。InnoDB 使用 Next-key Locks 解决幻读问题。需要注意的是，如果索引有唯一属性，则 InnnoDB 会自动将 Next-key Locks 降级为 Record Locks。举个例子，如果一个索引有 1, 3, 5 三个值，则该索引锁定的区间为 (-∞,1], (1,3], (3,5], (5,+ ∞)。 死锁# 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。 InnoDB 引擎采取的是 wait-for graph 等待图的方法来自动检测死锁，如果发现死锁会自动回滚一个事务。 下面我们通过一个示例来了解死锁。 准备两个终端，在此命名为 mysql 终端 1 和 mysql 终端 2，分别登入 mysql，再准备一张测试表 test 写入两条测试数据，并调整隔离级别为 SERIALIZABLE，任意一个终端执行即可。 12345SET @@session.transaction_isolation = &#x27;REPEATABLE-READ&#x27;;create database test;use test;create table test(id int primary key);insert into test(id) values(1),(2); 登录 mysql 终端 1，开启一个事务，手动给 ID 为 1 的记录加 X 锁。 12begin;select * from test where id = 1 for update; 登录 mysql 终端 2，开启一个事务，手动给 ID 为 2 的记录加 X 锁。 12begin;select * from test where id = 2 for update; 切换到 mysql 终端 1，手动给 ID 为 2 的记录加 X 锁，此时会一直卡住，因为此时在等待第 3 步中 X 锁的释放，直到超时，超时时间由 innodb_lock_wait_timeout 控制。 1select * from test where id = 2 for update; 在锁超时前立刻切换到 mysql 终端 2，手动给 ID 为 1 的记录加 X 锁，此时又会等待第 2 步中 X 所的释放，两个终端都在等待资源的释放，所以 InnoDB 引擎会立马检测到死锁产生，自动回滚一个事务，以防止死锁一直占用资源。 123select * from test where id = 1 for update;ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction 此时，通过 show engine innodb status\\G 命令可以看到 LATEST DETECTED DEADLOCK 相关信息，即表明有死锁发生；或者通过配置 innodb_print_all_deadlocks（MySQL 5.6.2 版本开始提供）参数为 ON 将死锁相关信息打印到 MySQL 的错误日志。 锁的优化建议# 锁如果利用不好，会给业务造成大量的卡顿现象，在了解了锁相关的一些知识点后，我们可以有意识的去避免锁带来的一些问题。 合理设计索引，让 InnoDB 在索引键上面加锁的时候尽可能准确，尽可能的缩小锁定范围，避免造成不必要的锁定而影响其他 Query 的执行。 尽可能减少基于范围的数据检索过滤条件，避免因为间隙锁带来的负面影响而锁定了不该锁定的记录。 尽量控制事务的大小，减少锁定的资源量和锁定时间长度。 在业务环境允许的情况下，尽量使用较低级别的事务隔离，以减少 MySQL 因为实现事务隔离级别所带来的附加成本。","content":"<p>数据库事务（简称:事务）是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。事务的使用是数据库管理系统区别文件系统的重要特征之一。事务拥有四个重要的特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability），人们习惯称之为 ACID 特性。下面我逐一对其进行解释。</p>\n<span id=\"more\"></span>\n<h2><span id=\"shi-wu-de-si-ge-te-zheng\">事务的四个特征</span><a href=\"#shi-wu-de-si-ge-te-zheng\" class=\"header-anchor\">#</a></h2>\n<h3><span id=\"yuan-zi-xing-atomicity\">原子性（Atomicity）</span><a href=\"#yuan-zi-xing-atomicity\" class=\"header-anchor\">#</a></h3>\n<p>事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。例如，如果一个事务需要新增 100 条记录，但是在新增了 10 条记录之后就失败了，那么数据库将回滚对这 10 条新增的记录。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。</p>\n<h3><span id=\"yi-zhi-xing-consistency\">一致性（Consistency）</span><a href=\"#yi-zhi-xing-consistency\" class=\"header-anchor\">#</a></h3>\n<p>指事务将数据库从一种状态转变为另一种一致的的状态。事务开始前和结束后，数据库的完整性约束没有被破坏。例如工号带有唯一属性，如果经过一个修改工号的事务后，工号变的非唯一了，则表明一致性遭到了破坏。</p>\n<h3><span id=\"ge-chi-xing-isolation\">隔离性（Isolation）</span><a href=\"#ge-chi-xing-isolation\" class=\"header-anchor\">#</a></h3>\n<p>要求每个读写事务的对象对其他事务的操作对象能互相分离，即该事务提交前对其他事务不可见。 也可以理解为多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。这指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。例如一个用户在更新自己的个人信息的同时，是不能看到系统管理员也在更新该用户的个人信息（此时更新事务还未提交）。</p>\n<p>注：MySQL 通过锁机制来保证事务的隔离性。</p>\n<h3><span id=\"chi-jiu-xing-durability\">持久性（Durability）</span><a href=\"#chi-jiu-xing-durability\" class=\"header-anchor\">#</a></h3>\n<p>事务一旦提交，则其结果就是永久性的。即使发生宕机的故障，数据库也能将数据恢复，也就是说事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。这只是从事务本身的角度来保证，排除 RDBMS（关系型数据库管理系统，例如 Oracle、MySQL 等）本身发生的故障。</p>\n<p>注：MySQL 使用 redo log 来保证事务的持久性。</p>\n<h2><span id=\"shi-wu-de-ge-chi-ji-bie\">事务的隔离级别</span><a href=\"#shi-wu-de-ge-chi-ji-bie\" class=\"header-anchor\">#</a></h2>\n<p>SQL 标准定义的四种隔离级别被 ANSI（美国国家标准学会）和 ISO/IEC（国际标准）采用，每种级别对事务的处理能力会有不同程度的影响。</p>\n<p>我们分别对四种隔离级别从并发程度由高到低进行描述，并用代码进行演示，数据库环境为 MySQL 5.7。</p>\n<h3><span id=\"read-uncommitted-du-wei-ti-jiao\">READ UNCOMMITTED（读未提交）</span><a href=\"#read-uncommitted-du-wei-ti-jiao\" class=\"header-anchor\">#</a></h3>\n<p>该隔离级别的事务会读到其它未提交事务的数据，此现象也称之为脏读。</p>\n<p>准备两个终端，在此命名为 mysql 终端 1 和 mysql 终端 2，再准备一张测试表 test，写入一条测试数据并调整隔离级别为 READ UNCOMMITTED，任意一个终端执行即可。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">SET @@session.transaction_isolation = <span class=\"string\">&#x27;READ-UNCOMMITTED&#x27;</span>;</span><br><span class=\"line\">create database <span class=\"built_in\">test</span>;</span><br><span class=\"line\">use <span class=\"built_in\">test</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> test(id <span class=\"type\">int</span> <span class=\"keyword\">primary</span> key);</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> test(id) <span class=\"keyword\">values</span>(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p>登录 mysql 终端 1，开启一个事务，将 ID 为 1 的记录更新为 2。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">begin;</span><br><span class=\"line\">update <span class=\"built_in\">test</span> <span class=\"built_in\">set</span> id = 2 <span class=\"built_in\">where</span> id = 1;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> test;  <span class=\"comment\">-- 此时看到一条ID为2的记录</span></span><br></pre></td></tr></table></figure>\n<p>登录 mysql 终端 2，开启一个事务后查看表中的数据。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use <span class=\"built_in\">test</span>;</span><br><span class=\"line\">begin;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> test; <span class=\"comment\">-- 此时看到一条 ID 为 2 的记录</span></span><br></pre></td></tr></table></figure>\n<p>最后一步读取到了 mysql 终端 1 中未提交的事务（没有 commit 提交动作），即产生了脏读，大部分业务场景都不允许脏读出现，但是此隔离级别下数据库的并发是最好的。</p>\n<h3><span id=\"read-committed-du-ti-jiao\">READ COMMITTED（读提交）</span><a href=\"#read-committed-du-ti-jiao\" class=\"header-anchor\">#</a></h3>\n<p>一个事务可以读取另一个已提交的事务，多次读取会造成不一样的结果，此现象称为不可重复读问题，Oracle 和 SQL Server 的默认隔离级别。</p>\n<p>准备两个终端，在此命名为 mysql 终端 1 和 mysql 终端 2，再准备一张测试表 test，写入一条测试数据并调整隔离级别为 READ COMMITTED，任意一个终端执行即可。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SET</span> @<span class=\"variable\">@session</span>.transaction_isolation <span class=\"operator\">=</span> <span class=\"string\">&#x27;READ-COMMITTED&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">create</span> database test;</span><br><span class=\"line\">use test;</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> test(id <span class=\"type\">int</span> <span class=\"keyword\">primary</span> key);</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> test(id) <span class=\"keyword\">values</span>(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p>登录 mysql 终端 1，开启一个事务，将 ID 为 1 的记录更新为 2，并确认记录数变更过来。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">begin</span>;</span><br><span class=\"line\">update test <span class=\"keyword\">set</span> id <span class=\"operator\">=</span> <span class=\"number\">2</span> <span class=\"keyword\">where</span> id <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> test; <span class=\"comment\">-- 此时看到一条记录为 2</span></span><br></pre></td></tr></table></figure>\n<p>登录 mysql 终端 2，开启一个事务后，查看表中的数据。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use test;</span><br><span class=\"line\"><span class=\"keyword\">begin</span>;</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> test; <span class=\"comment\">-- 此时看一条 ID 为 1 的记录</span></span><br></pre></td></tr></table></figure>\n<p>登录 mysql 终端 1，提交事务。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">commit</span>;</span><br></pre></td></tr></table></figure>\n<p>切换到 mysql 终端 2。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> test; <span class=\"comment\">-- 此时看到一条 ID 为 2 的记录</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>mysql 终端 2 在开启了一个事务之后，在第一次读取 test 表（此时 mysql 终端 1 的事务还未提交）时 ID 为 1，在第二次读取 test 表（此时 mysql 终端 1 的事务已经提交）时 ID 已经变为 2，说明在此隔离级别下已经读取到已提交的事务。</p>\n<h3><span id=\"repeatable-read-ke-chong-fu-du\">REPEATABLE READ（可重复读）</span><a href=\"#repeatable-read-ke-chong-fu-du\" class=\"header-anchor\">#</a></h3>\n<p>该隔离级别是 MySQL 默认的隔离级别，在同一个事务里，select 的结果是事务开始时时间点的状态，因此，同样的 select 操作读到的结果会是一致的，但是，会有幻读现象。MySQL 的 InnoDB 引擎可以通过 next-key locks 机制（参考下文&quot;行锁的算法&quot;一节）来避免幻读。</p>\n<p>准备两个终端，在此命名为 mysql 终端 1 和 mysql 终端 2，准备一张测试表 test 并调整隔离级别为 REPEATABLE READ，任意一个终端执行即可。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SET</span> @<span class=\"variable\">@session</span>.transaction_isolation <span class=\"operator\">=</span> <span class=\"string\">&#x27;REPEATABLE-READ&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">create</span> database test;</span><br><span class=\"line\">use test;</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> test(id <span class=\"type\">int</span> <span class=\"keyword\">primary</span> key,name <span class=\"type\">varchar</span>(<span class=\"number\">20</span>));</span><br></pre></td></tr></table></figure>\n<p>登录 mysql 终端 1，开启一个事务。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">begin</span>;</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> test; <span class=\"comment\">-- 无记录</span></span><br></pre></td></tr></table></figure>\n<p>登录 mysql 终端 2，开启一个事务。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">begin</span>;</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> test; <span class=\"comment\">-- 无记录</span></span><br></pre></td></tr></table></figure>\n<p>切换到 mysql 终端 1，增加一条记录并提交。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> test(id,name) <span class=\"keyword\">values</span>(<span class=\"number\">1</span>,<span class=\"string\">&#x27;a&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">commit</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>切换到 msyql 终端 2。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> test; <span class=\"comment\">--此时查询还是无记录</span></span><br></pre></td></tr></table></figure>\n<p>通过这一步可以证明，在该隔离级别下已经读取不到别的已提交的事务，如果想看到 mysql 终端 1 提交的事务，在 mysql 终端 2 将当前事务提交后再次查询就可以读取到 mysql 终端 1 提交的事务。我们接着实验，看看在该隔离级别下是否会存在别的问题。</p>\n<p>此时接着在 mysql 终端 2 插入一条数据。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> test(id,name) <span class=\"keyword\">values</span>(<span class=\"number\">1</span>,<span class=\"string\">&#x27;b&#x27;</span>); <span class=\"comment\">-- 此时报主键冲突的错误</span></span><br></pre></td></tr></table></figure>\n<p>也许到这里您心里可能会有疑问，明明在第 5 步没有数据，为什么在这里会报错呢？其实这就是该隔离级别下可能产生的问题，MySQL 称之为幻读。注意我在这里强调的是 MySQL 数据库，Oracle 数据库对于幻读的定义可能有所不同。</p>\n<h3><span id=\"serializable-xu-lie-hua\">SERIALIZABLE（序列化）</span><a href=\"#serializable-xu-lie-hua\" class=\"header-anchor\">#</a></h3>\n<p>在该隔离级别下事务都是串行顺序执行的，MySQL 数据库的 InnoDB 引擎会给读操作隐式加一把读共享锁，从而避免了脏读、不可重读复读和幻读问题。</p>\n<p>准备两个终端，在此命名为 mysql 终端 1 和 mysql 终端 2，分别登入 mysql，准备一张测试表 test 并调整隔离级别为 SERIALIZABLE，任意一个终端执行即可。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SET</span> @<span class=\"variable\">@session</span>.transaction_isolation <span class=\"operator\">=</span> <span class=\"string\">&#x27;SERIALIZABLE&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">create</span> database test;</span><br><span class=\"line\">use test;</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> test(id <span class=\"type\">int</span> <span class=\"keyword\">primary</span> key);</span><br></pre></td></tr></table></figure>\n<p>登录 mysql 终端 1，开启一个事务，并写入一条数据。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">begin</span>;</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> test(id) <span class=\"keyword\">values</span>(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p>登录 mysql 终端 2，开启一个事务。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">begin</span>;</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> test; <span class=\"comment\">-- 此时会一直卡住</span></span><br></pre></td></tr></table></figure>\n<p>立马切换到 mysql 终端 1,提交事务。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">commit</span>;</span><br></pre></td></tr></table></figure>\n<p>一旦事务提交，msyql 终端 2 会立马返回 ID 为 1 的记录，否则会一直卡住，直到超时，其中超时参数是由 innodb_lock_wait_timeout 控制。由于每条 select 语句都会加锁，所以该隔离级别的数据库并发能力最弱，但是有些资料表明该结论也不一定对，如果感兴趣，您可以自行做个压力测试。</p>\n<p>表 1 总结了各个隔离级别下产生的一些问题。</p>\n<table>\n<thead>\n<tr>\n<th>隔离级别</th>\n<th>脏读</th>\n<th>不可重复读</th>\n<th>幻读</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>读未提交</td>\n<td>可以出现</td>\n<td>可以出现</td>\n<td>可以出现</td>\n</tr>\n<tr>\n<td>读提交</td>\n<td>不允许出现</td>\n<td>可以出现</td>\n<td>可以出现</td>\n</tr>\n<tr>\n<td>可重复读</td>\n<td>不允许出现</td>\n<td>不允许出现</td>\n<td>可以出现</td>\n</tr>\n<tr>\n<td>序列化</td>\n<td>不允许出现</td>\n<td>不允许出现</td>\n<td>不允许出现</td>\n</tr>\n</tbody>\n</table>\n<h2><span id=\"mysql-zhong-de-suo\">MySQL 中的锁</span><a href=\"#mysql-zhong-de-suo\" class=\"header-anchor\">#</a></h2>\n<p>锁也是数据库管理系统区别文件系统的重要特征之一。锁机制使得在对数据库进行并发访问时，可以保障数据的完整性和一致性。对于锁的实现，各个数据库厂商的实现方法都会有所不同。本文讨论 MySQL 中的 InnoDB 引擎的锁。</p>\n<h3><span id=\"suo-de-lei-xing\">锁的类型</span><a href=\"#suo-de-lei-xing\" class=\"header-anchor\">#</a></h3>\n<p>InnoDB 实现了两种类型的行级锁：</p>\n<h4><span id=\"gong-xiang-suo-ye-cheng-wei-s-suo-yun-xu-shi-wu-du-qu-yi-xing-shu-ju\">共享锁（也称为 S 锁）：允许事务读取一行数据。</span><a href=\"#gong-xiang-suo-ye-cheng-wei-s-suo-yun-xu-shi-wu-du-qu-yi-xing-shu-ju\" class=\"header-anchor\">#</a></h4>\n<p>可以使用 SQL 语句 select * from tableName where … lock in share mode; 手动加 S 锁。</p>\n<h4><span id=\"du-zhan-suo-ye-cheng-wei-x-suo-yun-xu-shi-wu-shan-chu-huo-geng-xin-yi-xing-shu-ju\">独占锁（也称为 X 锁）：允许事务删除或更新一行数据。</span><a href=\"#du-zhan-suo-ye-cheng-wei-x-suo-yun-xu-shi-wu-shan-chu-huo-geng-xin-yi-xing-shu-ju\" class=\"header-anchor\">#</a></h4>\n<p>可以使用 SQL 语句 select * from tableName where … for update; 手动加 X 锁。</p>\n<p>S 锁和 S 锁是兼容的，X 锁和其它锁都不兼容，举个例子，事务 T1 获取了一个行 r1 的 S 锁，另外事务 T2 可以立即获得行 r1 的 S 锁，此时 T1 和 T2 共同获得行 r1 的 S 锁，此种情况称为锁兼容，但是另外一个事务 T2 此时如果想获得行 r1 的 X 锁，则必须等待 T1 对行 r 锁的释放，此种情况也成为锁冲突。</p>\n<p>为了实现多粒度的锁机制，InnoDB 还有两种内部使用的意向锁，由 InnoDB 自动添加，且都是表级别的锁。</p>\n<p>意向共享锁（IS）：事务即将给表中的各个行设置共享锁，事务给数据行加 S 锁前必须获得该表的 IS 锁。<br>\n意向排他锁（IX）：事务即将给表中的各个行设置排他锁，事务给数据行加 X 锁前必须获得该表 IX 锁。<br>\n意向锁的主要目的是为了使得行锁和表锁共存。表 2 列出了行级锁和表级意向锁的兼容性。</p>\n<p>表 2. 行级锁和表级意向锁的兼容性</p>\n<table>\n<thead>\n<tr>\n<th>锁类型</th>\n<th>X</th>\n<th>IX</th>\n<th>S</th>\n<th>IS</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>X</td>\n<td>冲突</td>\n<td>冲突</td>\n<td>冲突</td>\n<td>冲突</td>\n</tr>\n<tr>\n<td>IX</td>\n<td>冲突</td>\n<td>兼容</td>\n<td>冲突</td>\n<td>兼容</td>\n</tr>\n<tr>\n<td>S</td>\n<td>冲突</td>\n<td>冲突</td>\n<td>兼容</td>\n<td>兼容</td>\n</tr>\n<tr>\n<td>IS</td>\n<td>冲突</td>\n<td>兼容</td>\n<td>兼容</td>\n<td>兼容</td>\n</tr>\n</tbody>\n</table>\n<h4><span id=\"xing-suo-de-suan-fa\">行锁的算法</span><a href=\"#xing-suo-de-suan-fa\" class=\"header-anchor\">#</a></h4>\n<p>InnoDB 存储引擎使用三种行锁的算法用来满足相关事务隔离级别的要求。</p>\n<h4><span id=\"record-locks\">Record Locks</span><a href=\"#record-locks\" class=\"header-anchor\">#</a></h4>\n<p>该锁为索引记录上的锁，如果表中没有定义索引，InnoDB 会默认为该表创建一个隐藏的聚簇索引，并使用该索引锁定记录。</p>\n<h4><span id=\"gap-locks\">Gap Locks</span><a href=\"#gap-locks\" class=\"header-anchor\">#</a></h4>\n<p>该锁会锁定一个范围，但是不括记录本身。可以通过修改隔离级别为 READ COMMITTED 或者配置 innodb_locks_unsafe_for_binlog 参数为 ON。</p>\n<h4><span id=\"next-key-locks\">Next-key Locks</span><a href=\"#next-key-locks\" class=\"header-anchor\">#</a></h4>\n<p>该锁就是 Record Locks 和 Gap Locks 的组合，即锁定一个范围并且锁定该记录本身。InnoDB 使用 Next-key Locks 解决幻读问题。需要注意的是，如果索引有唯一属性，则 InnnoDB 会自动将 Next-key Locks 降级为 Record Locks。举个例子，如果一个索引有 1, 3, 5 三个值，则该索引锁定的区间为 (-∞,1], (1,3], (3,5], (5,+ ∞)。</p>\n<h4><span id=\"si-suo\">死锁</span><a href=\"#si-suo\" class=\"header-anchor\">#</a></h4>\n<p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p>\n<p>InnoDB 引擎采取的是 wait-for graph 等待图的方法来自动检测死锁，如果发现死锁会自动回滚一个事务。</p>\n<p>下面我们通过一个示例来了解死锁。</p>\n<p>准备两个终端，在此命名为 mysql 终端 1 和 mysql 终端 2，分别登入 mysql，再准备一张测试表 test 写入两条测试数据，并调整隔离级别为 SERIALIZABLE，任意一个终端执行即可。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SET</span> @<span class=\"variable\">@session</span>.transaction_isolation <span class=\"operator\">=</span> <span class=\"string\">&#x27;REPEATABLE-READ&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">create</span> database test;</span><br><span class=\"line\">use test;</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> test(id <span class=\"type\">int</span> <span class=\"keyword\">primary</span> key);</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> test(id) <span class=\"keyword\">values</span>(<span class=\"number\">1</span>),(<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n<p>登录 mysql 终端 1，开启一个事务，手动给 ID 为 1 的记录加 X 锁。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">begin</span>;</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> test <span class=\"keyword\">where</span> id <span class=\"operator\">=</span> <span class=\"number\">1</span> <span class=\"keyword\">for</span> update;</span><br></pre></td></tr></table></figure>\n<p>登录 mysql 终端 2，开启一个事务，手动给 ID 为 2 的记录加 X 锁。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">begin</span>;</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> test <span class=\"keyword\">where</span> id <span class=\"operator\">=</span> <span class=\"number\">2</span> <span class=\"keyword\">for</span> update;</span><br></pre></td></tr></table></figure>\n<p>切换到 mysql 终端 1，手动给 ID 为 2 的记录加 X 锁，此时会一直卡住，因为此时在等待第 3 步中 X 锁的释放，直到超时，超时时间由 innodb_lock_wait_timeout 控制。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> test <span class=\"keyword\">where</span> id <span class=\"operator\">=</span> <span class=\"number\">2</span> <span class=\"keyword\">for</span> update;</span><br></pre></td></tr></table></figure>\n<p>在锁超时前立刻切换到 mysql 终端 2，手动给 ID 为 1 的记录加 X 锁，此时又会等待第 2 步中 X 所的释放，两个终端都在等待资源的释放，所以 InnoDB 引擎会立马检测到死锁产生，自动回滚一个事务，以防止死锁一直占用资源。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> test <span class=\"keyword\">where</span> id <span class=\"operator\">=</span> <span class=\"number\">1</span> <span class=\"keyword\">for</span> update;</span><br><span class=\"line\">ERROR <span class=\"number\">1213</span> (<span class=\"number\">40001</span>): Deadlock found <span class=\"keyword\">when</span> trying <span class=\"keyword\">to</span> <span class=\"keyword\">get</span> lock; try restarting transaction</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>此时，通过 show engine innodb status\\G 命令可以看到 LATEST DETECTED DEADLOCK 相关信息，即表明有死锁发生；或者通过配置 innodb_print_all_deadlocks（MySQL 5.6.2 版本开始提供）参数为 ON 将死锁相关信息打印到 MySQL 的错误日志。</p>\n<h3><span id=\"suo-de-you-hua-jian-yi\">锁的优化建议</span><a href=\"#suo-de-you-hua-jian-yi\" class=\"header-anchor\">#</a></h3>\n<p>锁如果利用不好，会给业务造成大量的卡顿现象，在了解了锁相关的一些知识点后，我们可以有意识的去避免锁带来的一些问题。</p>\n<ol>\n<li>合理设计索引，让 InnoDB 在索引键上面加锁的时候尽可能准确，尽可能的缩小锁定范围，避免造成不必要的锁定而影响其他 Query 的执行。</li>\n<li>尽可能减少基于范围的数据检索过滤条件，避免因为间隙锁带来的负面影响而锁定了不该锁定的记录。</li>\n<li>尽量控制事务的大小，减少锁定的资源量和锁定时间长度。</li>\n<li>在业务环境允许的情况下，尽量使用较低级别的事务隔离，以减少 MySQL 因为实现事务隔离级别所带来的附加成本。</li>\n</ol>\n<link rel=\"stylesheet\" href=\"/css/markmap.css\" type=\"text/css\">","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.beyhub.com/tags/MySQL/"}]},{"title":"基于Redis实现分布式锁","path":"post/基于redis实现分布式锁/","text":"在多线程的环境下，为了保证一个代码块在同一时间只能由一个线程访问，Java中我们一般可以使用synchronized语法和ReetrantLock去保证，这实际上是本地锁的方式。但是现在公司都是流行分布式架构，在分布式环境下，如何保证不同节点的线程同步执行呢？保证分布式操作的原子性。 简介# 实际上，对于分布式场景，我们可以使用分布式锁，它是控制分布式系统之间互斥访问共享资源的一种方式。比如说在一个分布式系统中，多台机器上部署了多个服务，当客户端一个用户发起一个数据插入请求时，如果没有分布式锁机制保证，那么那多台机器上的多个服务可能进行并发插入操作，导致数据重复插入，对于某些不允许有多余数据的业务来说，这就会造成问题。而分布式锁机制就是为了解决类似这类问题，保证多个服务之间互斥的访问共享资源，如果一个服务抢占了分布式锁，其他服务没获取到锁，就不进行后续操作。大致意思如下图所示（不一定准确） Redis 锁主要利用 Redis 的 setnx 命令。 场景举例# 假设有一个进程A，每小时准点给用户发送一条短信&quot;Hello world&quot;，为了高可用，就必须在多台机器上面部署多个进程，避免宕机的情况； 假设部署在两台机器，那么问题来了，用户每个小时就会收到两条&quot;Hello world&quot;，信息就重复了； 我们希望只发送一条&quot;Hello world&quot;，那么就可以引入分布式锁的概念了； 进程A和进程B发送短信前先去注册一个锁，假设进程A抢到了锁，进程B就等待结果，如果发送成功了，那么B就放弃此次任务，等待下一个小时。 问题的核心就在于怎么注册锁，检查锁的存在和注册锁是一个原子性操作，类似mysql的主键，存在则不能insert，就是说你不能把我的锁覆盖了，你得等着； 我们有多种方式可以实现分布式锁，最简单的就是以每小时准点这个时间作为主键，到mysql写入一条数据，利用数据库来维持一致性。 分布式锁一般有如下的特点：# 互斥性： 同一时刻只能有一个线程持有锁 可重入性： 同一节点上的同一个线程如果获取了锁之后能够再次获取锁 锁超时：和J.U.C中的锁一样支持锁超时，防止死锁 高性能和高可用：加锁和解锁需要高效，同时也需要保证高可用，防止分布式锁失效 具备阻塞和非阻塞性：能够及时从阻塞状态中被唤醒 我们一般实现分布式锁有以下几种方式：# 基于数据库 基于Redis 基于zookeeper 本篇文章主要介绍基于Redis如何实现分布式锁 分布式锁应该具备的条件# 在分布式系统环境下，一个方法在同一时间只能被一个机器的的一个线程执行； 高可用的获取锁与释放锁； 高性能的获取锁与释放锁； 具备可重入特性； 具备锁失效机制，防止死锁； 具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。 Redis的分布式锁实现# 利用setnx+expire命令 (错误的做法)# Redis的SETNX命令，setnx key value，将key设置为value，当键不存在时，才能成功，若键存在，什么也不做，成功返回1，失败返回0 。 SETNX实际上就是SET IF NOT Exists的缩写 因为分布式锁还需要超时机制，所以我们利用expire命令来设置，所以利用setnx+expire命令的核心代码如下： 123456789public boolean tryLock(String key,String requset,int timeout) &#123; Long result = jedis.setnx(key, requset); // result = 1时，设置成功，否则设置失败 if (result == 1L) &#123; return jedis.expire(key, timeout) == 1L; &#125; else &#123; return false; &#125;&#125; 实际上上面的步骤是有问题的，setnx和expire是分开的两步操作，不具有原子性，如果执行完第一条指令应用异常或者重启了，锁将无法过期。 一种改善方案就是使用Lua脚本来保证原子性（包含setnx和expire两条指令） 使用Lua脚本（包含setnx和expire两条指令）# 代码如下 123456789101112public boolean tryLock_with_lua(String key, String UniqueId, int seconds) &#123; String lua_scripts = &quot;if redis.call(&#x27;setnx&#x27;,KEYS[1],ARGV[1]) == 1 then&quot; + &quot;redis.call(&#x27;expire&#x27;,KEYS[1],ARGV[2]) return 1 else return 0 end&quot;; List&lt;String&gt; keys = new ArrayList&lt;&gt;(); List&lt;String&gt; values = new ArrayList&lt;&gt;(); keys.add(key); values.add(UniqueId); values.add(String.valueOf(seconds)); Object result = jedis.eval(lua_scripts, keys, values); //判断是否成功 return result.equals(1L);&#125; 使用 set key value [EX seconds][PX milliseconds][NX|XX] 命令 (正确做法)# Redis在 2.6.12 版本开始，为 SET 命令增加一系列选项： SET key value[EX seconds][PX milliseconds][NX|XX] EX seconds: 设定过期时间，单位为秒 PX milliseconds: 设定过期时间，单位为毫秒 NX: 仅当key不存在时设置值 XX: 仅当key存在时设置值 set命令的nx选项，就等同于setnx命令，代码过程如下： 123public boolean tryLock_with_set(String key, String UniqueId, int seconds) &#123; return &quot;OK&quot;.equals(jedis.set(key, UniqueId, &quot;NX&quot;, &quot;EX&quot;, seconds));&#125; value必须要具有唯一性，我们可以用UUID来做，设置随机字符串保证唯一性，至于为什么要保证唯一性？假如value不是随机字符串，而是一个固定值，那么就可能存在下面的问题： 客户端1获取锁成功 客户端1在某个操作上阻塞了太长时间 设置的key过期了，锁自动释放了 客户端2获取到了对应同一个资源的锁 客户端1从阻塞中恢复过来，因为value值一样，所以执行释放锁操作时就会释放掉客户端2持有的锁，这样就会造成问题 所以通常来说，在释放锁时，我们需要对value进行验证 释放锁的实现 释放锁时需要验证value值，也就是说我们在获取锁的时候需要设置一个value，不能直接用del key这种粗暴的方式，因为直接del key任何客户端都可以进行解锁了，所以解锁时，我们需要判断锁是否是自己的，基于value值来判断，代码如下： 12345public boolean releaseLock_with_lua(String key,String value) &#123; String luaScript = &quot;if redis.call(&#x27;get&#x27;,KEYS[1]) == ARGV[1] then &quot; + &quot;return redis.call(&#x27;del&#x27;,KEYS[1]) else return 0 end&quot;; return jedis.eval(luaScript, Collections.singletonList(key), Collections.singletonList(value)).equals(1L);&#125; 这里使用Lua脚本的方式，尽量保证原子性。 使用 set key value [EX seconds][PX milliseconds][NX|XX] 命令 看上去很OK，实际上在Redis集群的时候也会出现问题，比如说A客户端在Redis的master节点上拿到了锁，但是这个加锁的key还没有同步到slave节点，master故障，发生故障转移，一个slave节点升级为master节点，B客户端也可以获取同个key的锁，但客户端A也已经拿到锁了，这就导致多个客户端都拿到锁。 所以针对Redis集群这种情况，还有其他方案 Redlock算法 与 Redisson 实现# Redis作者 antirez基于分布式环境下提出了一种更高级的分布式锁的实现Redlock，原理如下： 下面参考文章Redlock：Redis分布式锁最牛逼的实现 和 https://redis.io/topics/distlock 假设有5个独立的Redis节点（注意这里的节点可以是5个Redis单master实例，也可以是5个Redis Cluster集群，但并不是有5个主节点的cluster集群）： 获取当前Unix时间，以毫秒为单位 依次尝试从5个实例，使用相同的key和具有唯一性的value(例如UUID)获取锁，当向Redis请求获取锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应用小于锁的失效时间，例如你的锁自动失效时间为10s，则超时时间应该在5~50毫秒之间，这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务端没有在规定时间内响应，客户端应该尽快尝试去另外一个Redis实例请求获取锁 客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间，当且仅当从大多数(N/2+1，这里是3个节点)的Redis节点都取到锁，并且使用的时间小于锁失败时间时，锁才算获取成功。 如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果） 如果某些原因，获取锁失败（没有在至少N/2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功，防止某些节点获取到锁但是客户端没有得到响应而导致接下来的一段时间不能被重新获取锁） Redisson实现简单分布式锁# 对于Java用户而言，我们经常使用Jedis，Jedis是Redis的Java客户端，除了Jedis之外，Redisson也是Java的客户端，Jedis是阻塞式I/O，而Redisson底层使用Netty可以实现非阻塞I/O，该客户端封装了锁的，继承了J.U.C的Lock接口，所以我们可以像使用ReentrantLock一样使用Redisson，具体使用过程如下。首先加入POM依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson&lt;/artifactId&gt; &lt;version&gt;3.10.6&lt;/version&gt;&lt;/dependency&gt; 使用Redisson，代码如下(与使用ReentrantLock类似） 1234567891011121314151617181920// 1. 配置文件Config config = new Config();config.useSingleServer() .setAddress(&quot;redis://127.0.0.1:6379&quot;) .setPassword(RedisConfig.PASSWORD) .setDatabase(0);//2. 构造RedissonClientRedissonClient redissonClient = Redisson.create(config);//3. 设置锁定资源名称RLock lock = redissonClient.getLock(&quot;redlock&quot;);lock.lock();try &#123; System.out.println(&quot;获取锁成功，实现业务逻辑&quot;); Thread.sleep(10000);&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125; finally &#123; lock.unlock();&#125; 关于Redlock算法的实现，在Redisson中我们可以使用RedissonRedLock来完成。 Redis实现的分布式锁轮子# 下面利用SpringBoot + Jedis + AOP的组合来实现一个简易的分布式锁。 自定义注解# 自定义一个注解，被注解的方法会执行获取分布式锁的逻辑 12345678910111213141516171819202122232425262728293031@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@Documented@Inheritedpublic @interface RedisLock &#123; /** * 业务键 * * @return */ String key(); /** * 锁的过期秒数,默认是5秒 * * @return */ int expire() default 5; /** * 尝试加锁，最多等待时间 * * @return */ long waitTime() default Long.MIN_VALUE; /** * 锁的超时时间单位 * * @return */ TimeUnit timeUnit() default TimeUnit.SECONDS;&#125; AOP拦截器实现# 在AOP中我们去执行获取分布式锁和释放分布式锁的逻辑，代码如下： 12345678910111213141516171819202122232425262728293031323334353637@Aspect@Componentpublic class LockMethodAspect &#123; @Autowired private RedisLockHelper redisLockHelper; @Autowired private JedisUtil jedisUtil; private Logger logger = LoggerFactory.getLogger(LockMethodAspect.class); @Around(&quot;@annotation(com.redis.lock.annotation.RedisLock)&quot;) public Object around(ProceedingJoinPoint joinPoint) &#123; Jedis jedis = jedisUtil.getJedis(); MethodSignature signature = (MethodSignature) joinPoint.getSignature(); Method method = signature.getMethod(); RedisLock redisLock = method.getAnnotation(RedisLock.class); String value = UUID.randomUUID().toString(); String key = redisLock.key(); try &#123; final boolean islock = redisLockHelper.lock(jedis,key, value, redisLock.expire(), redisLock.timeUnit()); logger.info(&quot;isLock : &#123;&#125;&quot;,islock); if (!islock) &#123; logger.error(&quot;获取锁失败&quot;); throw new RuntimeException(&quot;获取锁失败&quot;); &#125; try &#123; return joinPoint.proceed(); &#125; catch (Throwable throwable) &#123; throw new RuntimeException(&quot;系统异常&quot;); &#125; &#125; finally &#123; logger.info(&quot;释放锁&quot;); redisLockHelper.unlock(jedis,key, value); jedis.close(); &#125; &#125;&#125; Redis实现分布式锁核心类# 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104@Componentpublic class RedisLockHelper &#123; private long sleepTime = 100; /** * 直接使用setnx + expire方式获取分布式锁 * 非原子性 * * @param key * @param value * @param timeout * @return */ public boolean lock_setnx(Jedis jedis,String key, String value, int timeout) &#123; Long result = jedis.setnx(key, value); // result = 1时，设置成功，否则设置失败 if (result == 1L) &#123; return jedis.expire(key, timeout) == 1L; &#125; else &#123; return false; &#125; &#125; /** * 使用Lua脚本，脚本中使用setnex+expire命令进行加锁操作 * * @param jedis * @param key * @param UniqueId * @param seconds * @return */ public boolean Lock_with_lua(Jedis jedis,String key, String UniqueId, int seconds) &#123; String lua_scripts = &quot;if redis.call(&#x27;setnx&#x27;,KEYS[1],ARGV[1]) == 1 then&quot; + &quot;redis.call(&#x27;expire&#x27;,KEYS[1],ARGV[2]) return 1 else return 0 end&quot;; List&lt;String&gt; keys = new ArrayList&lt;&gt;(); List&lt;String&gt; values = new ArrayList&lt;&gt;(); keys.add(key); values.add(UniqueId); values.add(String.valueOf(seconds)); Object result = jedis.eval(lua_scripts, keys, values); //判断是否成功 return result.equals(1L); &#125; /** * 在Redis的2.6.12及以后中,使用 set key value [NX] [EX] 命令 * * @param key * @param value * @param timeout * @return */ public boolean lock(Jedis jedis,String key, String value, int timeout, TimeUnit timeUnit) &#123; long seconds = timeUnit.toSeconds(timeout); return &quot;OK&quot;.equals(jedis.set(key, value, &quot;NX&quot;, &quot;EX&quot;, seconds)); &#125; /** * 自定义获取锁的超时时间 * * @param jedis * @param key * @param value * @param timeout * @param waitTime * @param timeUnit * @return * @throws InterruptedException */ public boolean lock_with_waitTime(Jedis jedis,String key, String value, int timeout, long waitTime,TimeUnit timeUnit) throws InterruptedException &#123; long seconds = timeUnit.toSeconds(timeout); while (waitTime &gt;= 0) &#123; String result = jedis.set(key, value, &quot;nx&quot;, &quot;ex&quot;, seconds); if (&quot;OK&quot;.equals(result)) &#123; return true; &#125; waitTime -= sleepTime; Thread.sleep(sleepTime); &#125; return false; &#125; /** * 错误的解锁方法—直接删除key * * @param key */ public void unlock_with_del(Jedis jedis,String key) &#123; jedis.del(key); &#125; /** * 使用Lua脚本进行解锁操纵，解锁的时候验证value值 * * @param jedis * @param key * @param value * @return */ public boolean unlock(Jedis jedis,String key,String value) &#123; String luaScript = &quot;if redis.call(&#x27;get&#x27;,KEYS[1]) == ARGV[1] then &quot; + &quot;return redis.call(&#x27;del&#x27;,KEYS[1]) else return 0 end&quot;; return jedis.eval(luaScript, Collections.singletonList(key), Collections.singletonList(value)).equals(1L); &#125;&#125; Controller层控制# 定义一个TestController来测试我们实现的分布式锁 123456789@RestControllerpublic class TestController &#123; @RedisLock(key = &quot;redis_lock&quot;) @GetMapping(&quot;/index&quot;) public String index() &#123; return &quot;index&quot;; &#125;&#125; Zookeeper实现简单，但效率较低；Redis实现复杂，但效率较高。 分布式锁重点在于互斥性，在任意一个时刻，只有一个客户端获取了锁。在实际的生产环境中，分布式锁的实现可能会更复杂，而我这里的讲述主要针对的是单机环境下的基于Redis的分布式锁实现，至于Redis集群环境并没有过多涉及，有兴趣的朋友可以查阅相关资料。 Redission Lock# Lua脚本在Redis底层操作具有原子性（基于事务） 资料# 项目源码地址：https://github.com/pjmike/redis-distributed-lock Redis分布式锁：https://redis.io/topics/distlock 小米的实现方案：https://xiaomi-info.github.io/2019/12/17/redis-distributed-lock/ 使用Redis SETNX 命令实现分布式锁：https://blog.csdn.net/lihao21/article/details/49104695 B站视频原理分析","content":"<p>在多线程的环境下，为了保证一个代码块在同一时间只能由一个线程访问，Java中我们一般可以使用synchronized语法和ReetrantLock去保证，这实际上是本地锁的方式。但是现在公司都是流行分布式架构，在分布式环境下，如何保证不同节点的线程同步执行呢？保证分布式操作的原子性。</p>\n<span id=\"more\"></span>\n<h2><span id=\"jian-jie\">简介</span><a href=\"#jian-jie\" class=\"header-anchor\">#</a></h2>\n<p>实际上，对于分布式场景，我们可以使用分布式锁，它是控制<strong>分布式系统之间互斥访问共享资源</strong>的一种方式。比如说在一个分布式系统中，多台机器上部署了多个服务，当客户端一个用户发起一个数据插入请求时，如果没有分布式锁机制保证，那么那多台机器上的多个服务可能进行并发插入操作，导致数据重复插入，对于某些不允许有多余数据的业务来说，这就会造成问题。而分布式锁机制就是为了解决类似这类问题，保证多个服务之间互斥的访问共享资源，如果一个服务抢占了分布式锁，其他服务没获取到锁，就不进行后续操作。大致意思如下图所示（不一定准确）</p>\n<p><img src=\"/images/posts/2020/distributed-lock.png\" alt=\"分布式锁\"></p>\n<p>Redis 锁主要利用 Redis 的 setnx 命令。</p>\n<h2><span id=\"chang-jing-ju-li\">场景举例</span><a href=\"#chang-jing-ju-li\" class=\"header-anchor\">#</a></h2>\n<ol>\n<li>假设有一个进程A，每小时准点给用户发送一条短信&quot;Hello world&quot;，为了高可用，就必须在多台机器上面部署多个进程，避免宕机的情况；</li>\n<li>假设部署在两台机器，那么问题来了，用户每个小时就会收到两条&quot;Hello world&quot;，信息就重复了；</li>\n<li>我们希望只发送一条&quot;Hello world&quot;，那么就可以引入分布式锁的概念了；</li>\n<li>进程A和进程B发送短信前先去注册一个锁，假设进程A抢到了锁，进程B就等待结果，如果发送成功了，那么B就放弃此次任务，等待下一个小时。</li>\n<li>问题的核心就在于怎么注册锁，检查锁的存在和注册锁是一个原子性操作，类似mysql的主键，存在则不能insert，就是说你不能把我的锁覆盖了，你得等着；</li>\n<li>我们有多种方式可以实现分布式锁，最简单的就是以每小时准点这个时间作为主键，到mysql写入一条数据，利用数据库来维持一致性。</li>\n</ol>\n<h3><span id=\"fen-bu-shi-suo-yi-ban-you-ru-xia-de-te-dian\">分布式锁一般有如下的特点：</span><a href=\"#fen-bu-shi-suo-yi-ban-you-ru-xia-de-te-dian\" class=\"header-anchor\">#</a></h3>\n<ul>\n<li>互斥性： 同一时刻只能有一个线程持有锁</li>\n<li>可重入性： 同一节点上的同一个线程如果获取了锁之后能够再次获取锁</li>\n<li>锁超时：和J.U.C中的锁一样支持锁超时，防止死锁</li>\n<li>高性能和高可用：加锁和解锁需要高效，同时也需要保证高可用，防止分布式锁失效</li>\n<li>具备阻塞和非阻塞性：能够及时从阻塞状态中被唤醒</li>\n</ul>\n<h3><span id=\"wo-men-yi-ban-shi-xian-fen-bu-shi-suo-you-yi-xia-ji-chong-fang-shi\">我们一般实现分布式锁有以下几种方式：</span><a href=\"#wo-men-yi-ban-shi-xian-fen-bu-shi-suo-you-yi-xia-ji-chong-fang-shi\" class=\"header-anchor\">#</a></h3>\n<ul>\n<li>基于数据库</li>\n<li>基于Redis</li>\n<li>基于zookeeper</li>\n<li>本篇文章主要介绍基于Redis如何实现分布式锁</li>\n</ul>\n<h2><span id=\"fen-bu-shi-suo-ying-gai-ju-bei-de-tiao-jian\">分布式锁应该具备的条件</span><a href=\"#fen-bu-shi-suo-ying-gai-ju-bei-de-tiao-jian\" class=\"header-anchor\">#</a></h2>\n<ol>\n<li>在分布式系统环境下，一个方法在同一时间只能被一个机器的的一个线程执行；</li>\n<li>高可用的获取锁与释放锁；</li>\n<li>高性能的获取锁与释放锁；</li>\n<li>具备可重入特性；</li>\n<li>具备锁失效机制，防止死锁；</li>\n<li>具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。</li>\n</ol>\n<h2><span id=\"redis-de-fen-bu-shi-suo-shi-xian\">Redis的分布式锁实现</span><a href=\"#redis-de-fen-bu-shi-suo-shi-xian\" class=\"header-anchor\">#</a></h2>\n<h3><span id=\"li-yong-setnx-expire-ming-ling-cuo-wu-de-zuo-fa\">利用setnx+expire命令 (错误的做法)</span><a href=\"#li-yong-setnx-expire-ming-ling-cuo-wu-de-zuo-fa\" class=\"header-anchor\">#</a></h3>\n<p>Redis的SETNX命令，setnx key value，将key设置为value，当键不存在时，才能成功，若键存在，什么也不做，成功返回1，失败返回0 。 SETNX实际上就是SET IF NOT Exists的缩写</p>\n<p>因为分布式锁还需要超时机制，所以我们利用expire命令来设置，所以利用setnx+expire命令的核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryLock</span><span class=\"params\">(String key,String requset,<span class=\"keyword\">int</span> timeout)</span> </span>&#123;</span><br><span class=\"line\">    Long result = jedis.setnx(key, requset);</span><br><span class=\"line\">    <span class=\"comment\">// result = 1时，设置成功，否则设置失败</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result == <span class=\"number\">1L</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> jedis.expire(key, timeout) == <span class=\"number\">1L</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实际上上面的步骤是有问题的，setnx和expire是分开的两步操作，不具有原子性，如果执行完第一条指令应用异常或者重启了，锁将无法过期。</p>\n<p>一种改善方案就是使用Lua脚本来保证原子性（包含setnx和expire两条指令）</p>\n<h3><span id=\"shi-yong-lua-jiao-ben-bao-han-setnx-he-expire-liang-tiao-zhi-ling\">使用Lua脚本（包含setnx和expire两条指令）</span><a href=\"#shi-yong-lua-jiao-ben-bao-han-setnx-he-expire-liang-tiao-zhi-ling\" class=\"header-anchor\">#</a></h3>\n<p>代码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryLock_with_lua</span><span class=\"params\">(String key, String UniqueId, <span class=\"keyword\">int</span> seconds)</span> </span>&#123;</span><br><span class=\"line\">    String lua_scripts = <span class=\"string\">&quot;if redis.call(&#x27;setnx&#x27;,KEYS[1],ARGV[1]) == 1 then&quot;</span> +</span><br><span class=\"line\">            <span class=\"string\">&quot;redis.call(&#x27;expire&#x27;,KEYS[1],ARGV[2]) return 1 else return 0 end&quot;</span>;</span><br><span class=\"line\">    List&lt;String&gt; keys = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    List&lt;String&gt; values = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    keys.add(key);</span><br><span class=\"line\">    values.add(UniqueId);</span><br><span class=\"line\">    values.add(String.valueOf(seconds));</span><br><span class=\"line\">    Object result = jedis.eval(lua_scripts, keys, values);</span><br><span class=\"line\">    <span class=\"comment\">//判断是否成功</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result.equals(<span class=\"number\">1L</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"shi-yong-set-key-value-ex-seconds-px-milliseconds-nx-xx-ming-ling-zheng-que-zuo-fa\">使用 set key value [EX seconds][PX milliseconds][NX|XX] 命令 (正确做法)</span><a href=\"#shi-yong-set-key-value-ex-seconds-px-milliseconds-nx-xx-ming-ling-zheng-que-zuo-fa\" class=\"header-anchor\">#</a></h3>\n<p>Redis在 2.6.12 版本开始，为 SET 命令增加一系列选项：</p>\n<p>SET key value[EX seconds][PX milliseconds][NX|XX]</p>\n<ul>\n<li>EX seconds: 设定过期时间，单位为秒</li>\n<li>PX milliseconds: 设定过期时间，单位为毫秒</li>\n<li>NX: 仅当key不存在时设置值</li>\n<li>XX: 仅当key存在时设置值</li>\n</ul>\n<p>set命令的nx选项，就等同于setnx命令，代码过程如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryLock_with_set</span><span class=\"params\">(String key, String UniqueId, <span class=\"keyword\">int</span> seconds)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;OK&quot;</span>.equals(jedis.set(key, UniqueId, <span class=\"string\">&quot;NX&quot;</span>, <span class=\"string\">&quot;EX&quot;</span>, seconds));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>value必须要具有唯一性，我们可以用UUID来做，设置随机字符串保证唯一性，至于为什么要保证唯一性？假如value不是随机字符串，而是一个固定值，那么就可能存在下面的问题：</p>\n<ol>\n<li>客户端1获取锁成功</li>\n<li>客户端1在某个操作上阻塞了太长时间</li>\n<li>设置的key过期了，锁自动释放了</li>\n<li>客户端2获取到了对应同一个资源的锁</li>\n<li>客户端1从阻塞中恢复过来，因为value值一样，所以执行释放锁操作时就会释放掉客户端2持有的锁，这样就会造成问题</li>\n</ol>\n<p>所以通常来说，在释放锁时，我们需要对value进行验证</p>\n<p>释放锁的实现<br>\n释放锁时需要验证value值，也就是说我们在获取锁的时候需要设置一个value，不能直接用del key这种粗暴的方式，因为直接del key任何客户端都可以进行解锁了，所以解锁时，我们需要判断锁是否是自己的，基于value值来判断，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">releaseLock_with_lua</span><span class=\"params\">(String key,String value)</span> </span>&#123;</span><br><span class=\"line\">    String luaScript = <span class=\"string\">&quot;if redis.call(&#x27;get&#x27;,KEYS[1]) == ARGV[1] then &quot;</span> +</span><br><span class=\"line\">            <span class=\"string\">&quot;return redis.call(&#x27;del&#x27;,KEYS[1]) else return 0 end&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> jedis.eval(luaScript, Collections.singletonList(key), Collections.singletonList(value)).equals(<span class=\"number\">1L</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里使用Lua脚本的方式，尽量保证原子性。</p>\n<p>使用 set key value [EX seconds][PX milliseconds][NX|XX] 命令 看上去很OK，实际上在Redis集群的时候也会出现问题，比如说A客户端在Redis的master节点上拿到了锁，但是这个加锁的key还没有同步到slave节点，master故障，发生故障转移，一个slave节点升级为master节点，B客户端也可以获取同个key的锁，但客户端A也已经拿到锁了，这就导致多个客户端都拿到锁。</p>\n<p>所以针对Redis集群这种情况，还有其他方案</p>\n<h3><span id=\"redlock-suan-fa-yu-redisson-shi-xian\">Redlock算法 与 Redisson 实现</span><a href=\"#redlock-suan-fa-yu-redisson-shi-xian\" class=\"header-anchor\">#</a></h3>\n<p>Redis作者 antirez基于分布式环境下提出了一种更高级的分布式锁的实现Redlock，原理如下：</p>\n<blockquote>\n<p>下面参考文章Redlock：Redis分布式锁最牛逼的实现 和 <a href=\"https://redis.io/topics/distlock\">https://redis.io/topics/distlock</a></p>\n</blockquote>\n<p>假设有5个独立的Redis节点（注意这里的节点可以是5个Redis单master实例，也可以是5个Redis Cluster集群，但并不是有5个主节点的cluster集群）：</p>\n<ul>\n<li>获取当前Unix时间，以毫秒为单位</li>\n<li>依次尝试从5个实例，使用相同的key和具有唯一性的value(例如UUID)获取锁，当向Redis请求获取锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应用小于锁的失效时间，例如你的锁自动失效时间为10s，则超时时间应该在5~50毫秒之间，这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务端没有在规定时间内响应，客户端应该尽快尝试去另外一个Redis实例请求获取锁</li>\n<li>客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间，当且仅当从大多数(N/2+1，这里是3个节点)的Redis节点都取到锁，并且使用的时间小于锁失败时间时，锁才算获取成功。</li>\n<li>如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）</li>\n<li>如果某些原因，获取锁失败（没有在至少N/2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功，防止某些节点获取到锁但是客户端没有得到响应而导致接下来的一段时间不能被重新获取锁）</li>\n</ul>\n<h3><span id=\"redisson-shi-xian-jian-dan-fen-bu-shi-suo\">Redisson实现简单分布式锁</span><a href=\"#redisson-shi-xian-jian-dan-fen-bu-shi-suo\" class=\"header-anchor\">#</a></h3>\n<p>对于Java用户而言，我们经常使用Jedis，Jedis是Redis的Java客户端，除了Jedis之外，Redisson也是Java的客户端，Jedis是阻塞式I/O，而Redisson底层使用Netty可以实现非阻塞I/O，该客户端封装了锁的，继承了J.U.C的Lock接口，所以我们可以像使用ReentrantLock一样使用Redisson，具体使用过程如下。首先加入POM依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.redisson<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>redisson<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.10.6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>使用Redisson，代码如下(与使用ReentrantLock类似）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 配置文件</span></span><br><span class=\"line\">Config config = <span class=\"keyword\">new</span> Config();</span><br><span class=\"line\">config.useSingleServer()</span><br><span class=\"line\">        .setAddress(<span class=\"string\">&quot;redis://127.0.0.1:6379&quot;</span>)</span><br><span class=\"line\">        .setPassword(RedisConfig.PASSWORD)</span><br><span class=\"line\">        .setDatabase(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">//2. 构造RedissonClient</span></span><br><span class=\"line\">RedissonClient redissonClient = Redisson.create(config);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//3. 设置锁定资源名称</span></span><br><span class=\"line\">RLock lock = redissonClient.getLock(<span class=\"string\">&quot;redlock&quot;</span>);</span><br><span class=\"line\">lock.lock();</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;获取锁成功，实现业务逻辑&quot;</span>);</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">10000</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    lock.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关于Redlock算法的实现，在Redisson中我们可以使用RedissonRedLock来完成。</p>\n<h2><span id=\"redis-shi-xian-de-fen-bu-shi-suo-lun-zi\">Redis实现的分布式锁轮子</span><a href=\"#redis-shi-xian-de-fen-bu-shi-suo-lun-zi\" class=\"header-anchor\">#</a></h2>\n<p>下面利用SpringBoot + Jedis + AOP的组合来实现一个简易的分布式锁。</p>\n<h3><span id=\"zi-ding-yi-zhu-jie\">自定义注解</span><a href=\"#zi-ding-yi-zhu-jie\" class=\"header-anchor\">#</a></h3>\n<p>自定义一个注解，被注解的方法会执行获取分布式锁的逻辑</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.METHOD)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> RedisLock &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 业务键</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">key</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 锁的过期秒数,默认是5秒</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">expire</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 尝试加锁，最多等待时间</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">waitTime</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> Long.MIN_VALUE</span>;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 锁的超时时间单位</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">TimeUnit <span class=\"title\">timeUnit</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> TimeUnit.SECONDS</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"aop-lan-jie-qi-shi-xian\">AOP拦截器实现</span><a href=\"#aop-lan-jie-qi-shi-xian\" class=\"header-anchor\">#</a></h3>\n<p>在AOP中我们去执行获取分布式锁和释放分布式锁的逻辑，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LockMethodAspect</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RedisLockHelper redisLockHelper;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> JedisUtil jedisUtil;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Logger logger = LoggerFactory.getLogger(LockMethodAspect.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Around(&quot;@annotation(com.redis.lock.annotation.RedisLock)&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">around</span><span class=\"params\">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class=\"line\">        Jedis jedis = jedisUtil.getJedis();</span><br><span class=\"line\">        MethodSignature signature = (MethodSignature) joinPoint.getSignature();</span><br><span class=\"line\">        Method method = signature.getMethod();</span><br><span class=\"line\"></span><br><span class=\"line\">        RedisLock redisLock = method.getAnnotation(RedisLock.class);</span><br><span class=\"line\">        String value = UUID.randomUUID().toString();</span><br><span class=\"line\">        String key = redisLock.key();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> islock = redisLockHelper.lock(jedis,key, value, redisLock.expire(), redisLock.timeUnit());</span><br><span class=\"line\">            logger.info(<span class=\"string\">&quot;isLock : &#123;&#125;&quot;</span>,islock);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!islock) &#123;</span><br><span class=\"line\">                logger.error(<span class=\"string\">&quot;获取锁失败&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;获取锁失败&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> joinPoint.proceed();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable throwable) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;系统异常&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;  <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            logger.info(<span class=\"string\">&quot;释放锁&quot;</span>);</span><br><span class=\"line\">            redisLockHelper.unlock(jedis,key, value);</span><br><span class=\"line\">            jedis.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"redis-shi-xian-fen-bu-shi-suo-he-xin-lei\">Redis实现分布式锁核心类</span><a href=\"#redis-shi-xian-fen-bu-shi-suo-he-xin-lei\" class=\"header-anchor\">#</a></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisLockHelper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> sleepTime = <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 直接使用setnx + expire方式获取分布式锁</span></span><br><span class=\"line\"><span class=\"comment\">     * 非原子性</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> timeout</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">lock_setnx</span><span class=\"params\">(Jedis jedis,String key, String value, <span class=\"keyword\">int</span> timeout)</span> </span>&#123;</span><br><span class=\"line\">        Long result = jedis.setnx(key, value);</span><br><span class=\"line\">        <span class=\"comment\">// result = 1时，设置成功，否则设置失败</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result == <span class=\"number\">1L</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> jedis.expire(key, timeout) == <span class=\"number\">1L</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 使用Lua脚本，脚本中使用setnex+expire命令进行加锁操作</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> jedis</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> UniqueId</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> seconds</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">Lock_with_lua</span><span class=\"params\">(Jedis jedis,String key, String UniqueId, <span class=\"keyword\">int</span> seconds)</span> </span>&#123;</span><br><span class=\"line\">        String lua_scripts = <span class=\"string\">&quot;if redis.call(&#x27;setnx&#x27;,KEYS[1],ARGV[1]) == 1 then&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;redis.call(&#x27;expire&#x27;,KEYS[1],ARGV[2]) return 1 else return 0 end&quot;</span>;</span><br><span class=\"line\">        List&lt;String&gt; keys = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        List&lt;String&gt; values = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        keys.add(key);</span><br><span class=\"line\">        values.add(UniqueId);</span><br><span class=\"line\">        values.add(String.valueOf(seconds));</span><br><span class=\"line\">        Object result = jedis.eval(lua_scripts, keys, values);</span><br><span class=\"line\">        <span class=\"comment\">//判断是否成功</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result.equals(<span class=\"number\">1L</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 在Redis的2.6.12及以后中,使用 set key value [NX] [EX] 命令</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> timeout</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">lock</span><span class=\"params\">(Jedis jedis,String key, String value, <span class=\"keyword\">int</span> timeout, TimeUnit timeUnit)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> seconds = timeUnit.toSeconds(timeout);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;OK&quot;</span>.equals(jedis.set(key, value, <span class=\"string\">&quot;NX&quot;</span>, <span class=\"string\">&quot;EX&quot;</span>, seconds));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 自定义获取锁的超时时间</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> jedis</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> timeout</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> waitTime</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> timeUnit</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> InterruptedException</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">lock_with_waitTime</span><span class=\"params\">(Jedis jedis,String key, String value, <span class=\"keyword\">int</span> timeout, <span class=\"keyword\">long</span> waitTime,TimeUnit timeUnit)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> seconds = timeUnit.toSeconds(timeout);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (waitTime &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            String result = jedis.set(key, value, <span class=\"string\">&quot;nx&quot;</span>, <span class=\"string\">&quot;ex&quot;</span>, seconds);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"string\">&quot;OK&quot;</span>.equals(result)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            waitTime -= sleepTime;</span><br><span class=\"line\">            Thread.sleep(sleepTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 错误的解锁方法—直接删除key</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock_with_del</span><span class=\"params\">(Jedis jedis,String key)</span> </span>&#123;</span><br><span class=\"line\">        jedis.del(key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 使用Lua脚本进行解锁操纵，解锁的时候验证value值</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> jedis</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">unlock</span><span class=\"params\">(Jedis jedis,String key,String value)</span> </span>&#123;</span><br><span class=\"line\">        String luaScript = <span class=\"string\">&quot;if redis.call(&#x27;get&#x27;,KEYS[1]) == ARGV[1] then &quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;return redis.call(&#x27;del&#x27;,KEYS[1]) else return 0 end&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> jedis.eval(luaScript, Collections.singletonList(key), Collections.singletonList(value)).equals(<span class=\"number\">1L</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"controller-ceng-kong-zhi\">Controller层控制</span><a href=\"#controller-ceng-kong-zhi\" class=\"header-anchor\">#</a></h3>\n<p>定义一个TestController来测试我们实现的分布式锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@RedisLock(key = &quot;redis_lock&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/index&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">index</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;index&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<hr>\n<p>Zookeeper实现简单，但效率较低；Redis实现复杂，但效率较高。</p>\n<blockquote>\n<p>分布式锁重点在于互斥性，在任意一个时刻，只有一个客户端获取了锁。在实际的生产环境中，分布式锁的实现可能会更复杂，而我这里的讲述主要针对的是单机环境下的基于Redis的分布式锁实现，至于Redis集群环境并没有过多涉及，有兴趣的朋友可以查阅相关资料。</p>\n</blockquote>\n<h3><span id=\"redission-lock\">Redission Lock</span><a href=\"#redission-lock\" class=\"header-anchor\">#</a></h3>\n<p>Lua脚本在Redis底层操作具有原子性（基于事务）</p>\n<p><img src=\"/images/posts/2020/redission.png\" alt></p>\n<h2><span id=\"zi-liao\">资料</span><a href=\"#zi-liao\" class=\"header-anchor\">#</a></h2>\n<ol>\n<li>项目源码地址：<a href=\"https://github.com/pjmike/redis-distributed-lock\">https://github.com/pjmike/redis-distributed-lock</a></li>\n<li>Redis分布式锁：<a href=\"https://redis.io/topics/distlock\">https://redis.io/topics/distlock</a></li>\n<li>小米的实现方案：<a href=\"https://xiaomi-info.github.io/2019/12/17/redis-distributed-lock/\">https://xiaomi-info.github.io/2019/12/17/redis-distributed-lock/</a></li>\n<li>使用Redis SETNX 命令实现分布式锁：<a href=\"https://blog.csdn.net/lihao21/article/details/49104695\">https://blog.csdn.net/lihao21/article/details/49104695</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1Y7411j7qU?p=2\">B站视频原理分析</a></li>\n</ol>\n<link rel=\"stylesheet\" href=\"/css/markmap.css\" type=\"text/css\">","tags":[{"name":"分布式","slug":"分布式","permalink":"https://blog.beyhub.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"高并发","slug":"高并发","permalink":"https://blog.beyhub.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"}]},{"title":"基于quartz的任务调度","path":"post/基于quartz的任务调度/","text":"Quartz是一个Java下作业控制的开源框架。Quartz用来创建或简单或复杂的调度时间表，执行Java下任意数量的作业。 可以通过CronTrigger定义Quartz的调度时间表（例如0 0 12 ? * WED表示“每周三上午12：00”）。此外，时间表也可以通过SimpleTrigger，由Date定义触发的开始时间、毫秒的时间间隔和重复计数（例如“在下周三12：00，然后每隔10秒、执行5次”）。可以使用Calender定义例外的日程（例如“没有周末和节假日”）。作业可以是实现了Job接口任意的Java类。作业监听器（JobListener）和触发器监听器（TriggerListener）通知作业的执行（和其他事件）。作业及其触发器可以被持久化。 Quartz一般用于企业级应用程序，以支持工作流、系统管理（英语：Systems management）（维护）活动，并在应用程序中提供实时的服务。Quartz还支持集群。 核心概念# Quartz对任务调度的领域问题进行了高度的抽象，提出了调度器、任务和触发器这3个核心的概念，并在org.quartz通过接口和类对重要的这些核心概念进行描述： Job：是一个接口，只有一个方法void execute(JobExecutionContext context)，开发者实现该接口定义运行任务，JobExecutionContext类提供了调度上下文的各种信息。Job运行时的信息保存在JobDataMap实例中； JobDetail：Quartz在每次执行Job时，都重新创建一个Job实例，所以它不直接接受一个Job的实例，相反它接收一个Job实现类，以便运行时通过newInstance()的反射机制实例化Job。因此需要通过一个类来描述Job的实现类及其它相关的静态信息，如Job名字、描述、关联监听器等信息，JobDetail承担了这一角色。通过该类的构造函数可以更具体地了解它的功用：JobDetail(java.lang.String name, java.lang.String group, java.lang.Class jobClass)，该构造函数要求指定Job的实现类，以及任务在Scheduler中的组名和Job名称； Trigger：是一个类，描述触发Job执行的时间触发规则。主要有SimpleTrigger和CronTrigger这两个子类。当仅需触发一次或者以固定时间间隔周期执行，SimpleTrigger是最适合的选择；而CronTrigger则可以通过Cron表达式定义出各种复杂时间规则的调度方案：如每早晨9:00执行，周一、周三、周五下午5:00执行等； Calendar：org.quartz.Calendar和java.util.Calendar不同，它是一些日历特定时间点的集合（可以简单地将org.quartz.Calendar看作java.util.Calendar的集合——java.util.Calendar代表一个日历时间点，无特殊说明后面的Calendar即指org.quartz.Calendar）。一个Trigger可以和多个Calendar关联，以便排除或包含某些时间点。 Scheduler：代表一个Quartz的独立运行容器，Trigger和JobDetail可以注册到Scheduler中，两者在Scheduler中拥有各自的组及名称，组及名称是Scheduler查找定位容器中某一对象的依据，Trigger的组及名称必须唯一，JobDetail的组和名称也必须唯一（但可以和Trigger的组和名称相同，因为它们是不同类型的）。Scheduler定义了多个接口方法，允许外部通过组及名称访问和控制容器中Trigger和JobDetail。 ThreadPool：Scheduler使用一个线程池作为任务运行的基础设施，任务通过共享线程池中的线程提高运行效率。 Scheduler、Trigger和Job是Quartz的三大核心组件。 Quartz集群# 虽然单个Quartz实例能给予你很好的Job调度能力，但它不能满足典型的企业需求，如可伸缩性、高可靠性满足。假如你需要故障转移的能力并能运行日益增多的 Job，Quartz集群势必成为你应用的一部分了。使用 Quartz 的集群能力可以更好的支持你的业务需求，并且即使是其中一台机器在最糟的时间崩溃了也能确保所有的 Job 得到执行。 一个 Quartz 集群中的每个节点是一个独立的 Quartz 应用，它又管理着其他的节点。意思是你必须对每个节点分别启动或停止。不像许多应用服务器的集群，独立的 Quartz 节点并不与另一其的节点或是管理节点通信。Quartz 应用是通过数据库表来感知到另一应用的。 实战# 首先我们先创建一个新的类，叫做QuartzTest，并添加对应的main方法。具体代码如下： 12345678910111213141516171819202122232425262728293031// 需要引入的静态方法import static org.quartz.TriggerBuilder.newTrigger;import static org.quartz.SimpleScheduleBuilder.simpleSchedule;import static org.quartz.JobBuilder.newJob;public static void main(String[] args) throws SchedulerException &#123; // 实例化一个Scheduler Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler(); // 设置Trigger Trigger trigger = newTrigger() // 需要手动引入静态方法，用于常见一个Trigger .withIdentity(&quot;trigger1&quot;, &quot;group1&quot;) // 设置名称和分组 .startNow() //启动trigger .withSchedule(simpleSchedule().withIntervalInSeconds(1).repeatForever()) // 设置任务调度的类型、时间间隔和持续触发 .build(); // 设置JobDetail JobDetail jobDetail = newJob(MyJobDetail.class) .withIdentity(&quot;jobDetail1&quot;, &quot;group1&quot;) .usingJobData(&quot;user&quot;, &quot;AlanShelby&quot;) .build(); // 设置一个任务调度，需要一个JobDetail和一个Trigger scheduler.scheduleJob(jobDetail, trigger); // 启动任务调度 scheduler.start(); // 设置指定的睡眠时间 try &#123; Thread.sleep(1000000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 关闭任务调度 scheduler.shutdown();&#125; 在上面的代码中引入了三个静态方法，需手动引入，还有另一种方法，可以不引入静态方法，具体如果编写在下一节中进行演示。可以看到代码中设置了一个JobDetail，这个需要我们自定义一个类，创建MyJobDetail类，实现quartz中的Job类，重写execute方法，代码如下所示： 12345678910111213141516public class MyJobDetail implements Job &#123; public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123; JobDetail jobDetail = jobExecutionContext.getJobDetail(); Map map = jobDetail.getJobDataMap(); System.out.println(&quot;time is ---&quot; + getTime() + &quot;data is ---&quot; + map.get(&quot;user&quot;)); &#125; // 获取时间的方法 public String getTime() &#123; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss SSS&quot;); long millis = System.currentTimeMillis(); String times = sdf.format(millis); return times; &#125;&#125; 至此，一个简单的demo就完成了，输出信息每一秒打印一次。 FAQ# Timer 和 Quartz 之间有什么区别？ Timer 只能执行定时定频率的任务，而 Quartz 不是 Timer 只有一个线程在执行，而 Quartz 有线程池，默认开启 10 个线程 Timer 中出现异常，一切 GC，不能记录事故现场，而Quartz可以 扩展阅读# 官方网站：http://www.quartz-scheduler.org/ 源码地址：https://github.com/quartz-scheduler/quartz SpringBoot + quartz 的DEMO: https://github.com/tenstone/spring-boot-quartz-demo","content":"<p>Quartz是一个Java下作业控制的开源框架。Quartz用来创建或简单或复杂的调度时间表，执行Java下任意数量的作业。</p>\n<p>可以通过CronTrigger定义Quartz的调度时间表（例如0 0 12 ? * WED表示“每周三上午12：00”）。此外，时间表也可以通过SimpleTrigger，由Date定义触发的开始时间、毫秒的时间间隔和重复计数（例如“在下周三12：00，然后每隔10秒、执行5次”）。可以使用Calender定义例外的日程（例如“没有周末和节假日”）。作业可以是实现了Job接口任意的Java类。作业监听器（JobListener）和触发器监听器（TriggerListener）通知作业的执行（和其他事件）。作业及其触发器可以被持久化。</p>\n<p>Quartz一般用于企业级应用程序，以支持工作流、系统管理（英语：Systems management）（维护）活动，并在应用程序中提供实时的服务。Quartz还支持集群。</p>\n<span id=\"more\"></span>\n<h2><span id=\"he-xin-gai-nian\">核心概念</span><a href=\"#he-xin-gai-nian\" class=\"header-anchor\">#</a></h2>\n<p>Quartz对任务调度的领域问题进行了高度的抽象，提出了调度器、任务和触发器这3个核心的概念，并在org.quartz通过接口和类对重要的这些核心概念进行描述：</p>\n<ol>\n<li>\n<p>Job：是一个接口，只有一个方法void execute(JobExecutionContext context)，开发者实现该接口定义运行任务，JobExecutionContext类提供了调度上下文的各种信息。Job运行时的信息保存在JobDataMap实例中；</p>\n</li>\n<li>\n<p>JobDetail：Quartz在每次执行Job时，都重新创建一个Job实例，所以它不直接接受一个Job的实例，相反它接收一个Job实现类，以便运行时通过newInstance()的反射机制实例化Job。因此需要通过一个类来描述Job的实现类及其它相关的静态信息，如Job名字、描述、关联监听器等信息，JobDetail承担了这一角色。通过该类的构造函数可以更具体地了解它的功用：JobDetail(java.lang.String name, java.lang.String group, java.lang.Class jobClass)，该构造函数要求指定Job的实现类，以及任务在Scheduler中的组名和Job名称；</p>\n</li>\n<li>\n<p>Trigger：是一个类，描述触发Job执行的时间触发规则。主要有SimpleTrigger和CronTrigger这两个子类。当仅需触发一次或者以固定时间间隔周期执行，SimpleTrigger是最适合的选择；而CronTrigger则可以通过Cron表达式定义出各种复杂时间规则的调度方案：如每早晨9:00执行，周一、周三、周五下午5:00执行等；</p>\n</li>\n<li>\n<p>Calendar：org.quartz.Calendar和java.util.Calendar不同，它是一些日历特定时间点的集合（可以简单地将org.quartz.Calendar看作java.util.Calendar的集合——java.util.Calendar代表一个日历时间点，无特殊说明后面的Calendar即指org.quartz.Calendar）。一个Trigger可以和多个Calendar关联，以便排除或包含某些时间点。</p>\n</li>\n<li>\n<p>Scheduler：代表一个Quartz的独立运行容器，Trigger和JobDetail可以注册到Scheduler中，两者在Scheduler中拥有各自的组及名称，组及名称是Scheduler查找定位容器中某一对象的依据，Trigger的组及名称必须唯一，JobDetail的组和名称也必须唯一（但可以和Trigger的组和名称相同，因为它们是不同类型的）。Scheduler定义了多个接口方法，允许外部通过组及名称访问和控制容器中Trigger和JobDetail。</p>\n</li>\n<li>\n<p>ThreadPool：Scheduler使用一个线程池作为任务运行的基础设施，任务通过共享线程池中的线程提高运行效率。</p>\n</li>\n</ol>\n<p><img src=\"/images/posts/2020/quartz.png\" alt></p>\n<p>Scheduler、Trigger和Job是Quartz的三大核心组件。</p>\n<h2><span id=\"quartz-ji-qun\">Quartz集群</span><a href=\"#quartz-ji-qun\" class=\"header-anchor\">#</a></h2>\n<p>虽然单个Quartz实例能给予你很好的Job调度能力，但它不能满足典型的企业需求，如可伸缩性、高可靠性满足。假如你需要故障转移的能力并能运行日益增多的 Job，Quartz集群势必成为你应用的一部分了。使用 Quartz 的集群能力可以更好的支持你的业务需求，并且即使是其中一台机器在最糟的时间崩溃了也能确保所有的 Job 得到执行。</p>\n<p>一个 Quartz 集群中的每个节点是一个独立的 Quartz 应用，它又管理着其他的节点。意思是你必须对每个节点分别启动或停止。不像许多应用服务器的集群，独立的 Quartz 节点并不与另一其的节点或是管理节点通信。Quartz 应用是通过数据库表来感知到另一应用的。</p>\n<p><img src=\"/images/posts/2020/quartz-distributed.webp\" alt></p>\n<h2><span id=\"shi-zhan\">实战</span><a href=\"#shi-zhan\" class=\"header-anchor\">#</a></h2>\n<p>首先我们先创建一个新的类，叫做QuartzTest，并添加对应的main方法。具体代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 需要引入的静态方法</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> org.quartz.TriggerBuilder.newTrigger;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> org.quartz.SimpleScheduleBuilder.simpleSchedule;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> org.quartz.JobBuilder.newJob;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> SchedulerException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 实例化一个Scheduler</span></span><br><span class=\"line\">    Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler();</span><br><span class=\"line\">    <span class=\"comment\">// 设置Trigger</span></span><br><span class=\"line\">    Trigger trigger = newTrigger() <span class=\"comment\">// 需要手动引入静态方法，用于常见一个Trigger</span></span><br><span class=\"line\">            .withIdentity(<span class=\"string\">&quot;trigger1&quot;</span>, <span class=\"string\">&quot;group1&quot;</span>) <span class=\"comment\">// 设置名称和分组</span></span><br><span class=\"line\">            .startNow() <span class=\"comment\">//启动trigger</span></span><br><span class=\"line\">            .withSchedule(simpleSchedule().withIntervalInSeconds(<span class=\"number\">1</span>).repeatForever()) <span class=\"comment\">// 设置任务调度的类型、时间间隔和持续触发</span></span><br><span class=\"line\">            .build();</span><br><span class=\"line\">    <span class=\"comment\">// 设置JobDetail</span></span><br><span class=\"line\">    JobDetail jobDetail = newJob(MyJobDetail.class)</span><br><span class=\"line\">            .withIdentity(<span class=\"string\">&quot;jobDetail1&quot;</span>, <span class=\"string\">&quot;group1&quot;</span>)</span><br><span class=\"line\">            .usingJobData(<span class=\"string\">&quot;user&quot;</span>, <span class=\"string\">&quot;AlanShelby&quot;</span>)</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">    <span class=\"comment\">// 设置一个任务调度，需要一个JobDetail和一个Trigger</span></span><br><span class=\"line\">    scheduler.scheduleJob(jobDetail, trigger);</span><br><span class=\"line\">    <span class=\"comment\">// 启动任务调度</span></span><br><span class=\"line\">    scheduler.start();</span><br><span class=\"line\">    <span class=\"comment\">// 设置指定的睡眠时间</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000000</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 关闭任务调度</span></span><br><span class=\"line\">    scheduler.shutdown();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面的代码中引入了三个静态方法，需手动引入，还有另一种方法，可以不引入静态方法，具体如果编写在下一节中进行演示。可以看到代码中设置了一个JobDetail，这个需要我们自定义一个类，创建MyJobDetail类，实现quartz中的Job类，重写execute方法，代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyJobDetail</span> <span class=\"keyword\">implements</span> <span class=\"title\">Job</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(JobExecutionContext jobExecutionContext)</span> <span class=\"keyword\">throws</span> JobExecutionException </span>&#123;</span><br><span class=\"line\">        JobDetail jobDetail = jobExecutionContext.getJobDetail();</span><br><span class=\"line\">        Map map = jobDetail.getJobDataMap();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;time is ---&quot;</span> + getTime() + <span class=\"string\">&quot;data is ---&quot;</span> + map.get(<span class=\"string\">&quot;user&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取时间的方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getTime</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        SimpleDateFormat sdf = <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">&quot;yyyy-MM-dd hh:mm:ss SSS&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">long</span> millis = System.currentTimeMillis();</span><br><span class=\"line\">        String times = sdf.format(millis);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> times;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>至此，一个简单的demo就完成了，输出信息每一秒打印一次。</p>\n<h2><span id=\"faq\">FAQ</span><a href=\"#faq\" class=\"header-anchor\">#</a></h2>\n<p><strong>Timer 和 Quartz 之间有什么区别？</strong></p>\n<ol>\n<li>Timer 只能执行定时定频率的任务，而 Quartz 不是</li>\n<li>Timer 只有一个线程在执行，而 Quartz 有线程池，默认开启 10 个线程</li>\n<li>Timer 中出现异常，一切 GC，不能记录事故现场，而Quartz可以</li>\n</ol>\n<h2><span id=\"kuo-zhan-yue-du\">扩展阅读</span><a href=\"#kuo-zhan-yue-du\" class=\"header-anchor\">#</a></h2>\n<ol>\n<li>官方网站：<a href=\"http://www.quartz-scheduler.org/\">http://www.quartz-scheduler.org/</a></li>\n<li>源码地址：<a href=\"https://github.com/quartz-scheduler/quartz\">https://github.com/quartz-scheduler/quartz</a></li>\n<li>SpringBoot + quartz 的DEMO: <a href=\"https://github.com/tenstone/spring-boot-quartz-demo\">https://github.com/tenstone/spring-boot-quartz-demo</a></li>\n</ol>\n<link rel=\"stylesheet\" href=\"/css/markmap.css\" type=\"text/css\">","tags":[{"name":"分布式","slug":"分布式","permalink":"https://blog.beyhub.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"定时任务","slug":"定时任务","permalink":"https://blog.beyhub.com/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"}]},{"title":"SpringBoot-Bean基本原理","path":"post/springboot-bean基本原理/","text":"被称作 bean 的对象是构成应用程序的支柱也是由 Spring IoC 容器管理的。bean 是一个被实例化，组装，并通过 Spring IoC 容器所管理的对象。这些 bean 是由用容器提供的配置元数据创建的，例如，已经在先前章节看到的，在 XML 的表单中的 定义。 Spring 只帮我们管理单例模式 Bean 的完整生命周期，对于 prototype 的 bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期。 IoC与DI详解# IoC的实现方式 及 与DI的关系？# **依赖查找(Dependency Lookup)：**容器中的受控对象通过容器的API来查找自己所依赖的资源和协作对象。 这种方式虽然降低了对象间的依赖，但是同时也使用到了容器的API，造成了我们无法在容器外使用和测试对象。 依赖查找是一种更加传统的IoC实现方式。 **依赖注入(Dependency Injection)：**这就是DI，字面上理解，依赖注入就是将服务注入到使用它的地方。对象只提供普通的方法让容器去决定依赖关系， 容器全权负责组件的装配，它会把符合依赖关系的对象通过属性（JavaBean中的setter）或者是构造子传递给需要的对象。 相对于IoC而言，依赖注入(DI)更加准确地描述了IoC的设计理念。所谓依赖注入，即组件之间的依赖关系由容器在应用系统运行期来决定， 也就是由容器动态地将某种依赖关系的目标对象实例注入到应用系统中的各个关联的组件之中。 Spring中的IoC与DI# IoC是Spring的核心，贯穿始终。对于Spring框架来说，就是由Spring来负责控制对象的生命周期和对象间的关系。 Spring中DI有两种实现方式—Setter方式(传值方式)和构造器方式(引用方式)。 IoC的实现原理：反射与工厂模式# 反射# 反射是Java语言的一个特性，它允许程序在运行时（注意不是编译的时候）来进行自我检查并且对内部的成员进行操作。例如它允许一个Java类获取它所有的成员变量和方法并且显示出来。 反射主要是指程序可以访问，检测和修改它本身状态或行为的一种能力，并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。在Java中，只要给定类的名字，那么就可以通过反射机制来获得类的所有信息。 反射的作用 在运行时判断任意一个对象所属的类； 在运行时获取类的对象； 在运行时访问java对象的属性，方法，构造方法等； 在运行时修改类的对象、方法和属性 静态编译：在编译时确定类型，绑定对象，即通过。 动态编译：运行时确定类型，绑定对象。动态编译最大限度发挥了Java的灵活性，体现了多态的应用，有以降低类之间的藕合性。 反射机制优缺点 优点：可以实现动态创建对象和编译，体现出很大的灵活性（特别是在J2EE的开发中它的灵活性就表现的十分明显）。通过反射机制我们可以获得类的各种内容，进行反编译。对于JAVA这种先编译再运行的语言来说，反射机制可以使代码更加灵活，更加容易实现面向对象。 比如，一个大型的软件，不可能一次就把把它设计得很完美，把这个程序编译后，发布了，当发现需要更新某些功能时，我们不可能要用户把以前的卸载，再重新安装新的版本，假如这样的话，这个软件肯定是没有多少人用的。采用静态的话，需要把整个程序重新编译一次才可以实现功能的更新，而采用反射机制的话，它就可以不用卸载，只需要在运行时动态地创建和编译，就可以实现该功能。 缺点：对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且让它满足我们的要求。这类操作总是慢于直接执行相同的操作。 工厂模式# IOC容器的工作：创建和管理Bean，它是一个工厂，负责对外提供Bean实例。 @Bean# Spring的@Bean注解用于告诉方法，产生一个Bean对象，然后这个Bean对象交给Spring管理。产生这个Bean对象的方法Spring只会调用一次，随后这个Spring将会将这个Bean对象放在自己的IOC容器中。(默认bean的名称就是其方法名。但是也可以指定名称) 1234567891011121314151617181920@Servicepublic class BeanTest &#123; @Bean public BeanTest getBean()&#123; BeanTest bean = new BeanTest(); System.out.println(&quot;调用方法：&quot;+bean); return bean; &#125;&#125;public class Main &#123; @SuppressWarnings(&quot;unused&quot;) public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;application-context.xml&quot;); Object bean1 = context.getBean(&quot;getBean&quot;); System.out.println(bean1); Object bean2 = context.getBean(&quot;getBean&quot;); System.out.println(bean2); &#125;&#125; 123调用方法：Spring.BeanTest@5a4041ccSpring.BeanTest@5a4041ccSpring.BeanTest@5a4041cc FAQ# Spring中的Bean是线程安全的吗（不是）？# Spring中的Bean默认是单例模式的，框架并没有对bean进行多线程的封装处理。实际上大部分时间Bean是无状态的（比如Dao） 所以说在某种程度上来说Bean其实是安全的。但是如果Bean是有状态的 那就需要开发人员自己来进行线程安全的保证，最简单的办法就是改变bean的作用域把singleton改为protopyte这样每次请求Bean就相当于是new Bean()这样就可以保证线程的安全了。 (有状态就是有数据存储功能/无状态就是不会保存数据） 线程安全这个问题，要从单例与原型Bean分别进行说明。 原型Bean： 对于原型Bean,每次创建一个新对象，也就是线程之间并不存在Bean共享，自然是不会有线程安全的问题。 单例Bean： 对于单例Bean,所有线程都共享一个单例实例Bean,因此是存在资源的竞争。 如果单例Bean,是一个无状态Bean，也就是线程中的操作不会对Bean的成员执行查询以外的操作，那么这个单例Bean是线程安全的。比如Spring mvc 的 Controller、Service、Dao等，这些Bean大多是无状态的，只关注于方法本身。 Spring 的 bean 作用域（scope）类型 ?# singleton:单例，默认作用域。 prototype:原型，每次创建一个新对象。 request:请求，每次Http请求创建一个新对象，适用于WebApplicationContext环境下。 session:会话，同一个会话共享一个实例，不同会话使用不用的实例。 global-session:全局会话，所有会话共享一个实例。 @Service和@Controller是否线程安全？# 默认配置下不是的。为啥呢？因为默认情况下@Controller没有加上@Scope，没有加@Scope就是默认值singleton，单例的。意思就是系统只会初始化一次Controller容器，所以每次请求的都是同一个Controller容器，当然是非线程安全的。 在@Controller/@Service等容器中，默认情况下，scope值是单例-singleton的，也是线程不安全的 尽量不要在@Controller/@Service等容器中定义静态变量，不论是单例(singleton)还是多实例(prototype)他都是线程不安全的 默认注入的Bean对象，在不设置scope的时候他也是线程不安全的 一定要定义变量的话，用ThreadLocal来封装，这个是线程安全的 多线程场景下，多个线程对这个单例Bean的成员变量并不存在资源的竞争，因为ThreadLocal为每个线程保存线程私有的数据。这是一种以空间换时间的方式。 @Bean和@Component之间的联系和区别# @Component 注解表明一个类会作为组件类，并告知Spring要为这个类创建bean，（@Controller,@Service,@Repository实际上都包含了@Component注解） @Bean 用在方法上，一般有返回值，@Bean注解告诉Spring这个方法将会返回一个对象，这个对象要注册为Spring应用上下文中的bean。通常方法体中包含了最终产生bean实例的逻辑；第三方的类，如果要注册到spring中，一般用bean的方式。 ApplicationContext 与 BeanFactory 区别# Bean工厂（BeanFactory）是Spring框架的最核心接口，它提供了高级Ioc的配置机制。应用上下文（ApplicationContext）是BeanFactory的实现，以Bean工厂为基础，它提供了更多面向应用的功能。 在用途上，BeanFactory是Spring框架的基础设施，面向Spring本身，我们一般不直接使用；ApplicationContext面向使用Spring框架的开发者，所以，在几乎所有的应用场合我们都使用应用上下文而非Bean工厂。 扩展阅读# Spring 中的bean 是线程安全的吗： https://www.cnblogs.com/myseries/p/11729800.html Bean 文档： https://wiki.jikexueyuan.com/project/spring/bean-definition.html","content":"<p>被称作 bean 的对象是构成应用程序的支柱也是由 Spring IoC 容器管理的。bean 是一个被实例化，组装，并通过 Spring IoC 容器所管理的对象。这些 bean 是由用容器提供的配置元数据创建的，例如，已经在先前章节看到的，在 XML 的表单中的 定义。</p>\n<p><img src=\"/images/posts/2020/bean-lifecycle.png\" alt></p>\n<blockquote>\n<p>Spring 只帮我们管理单例模式 Bean 的完整生命周期，对于 prototype 的 bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2><span id=\"ioc-yu-di-xiang-jie\">IoC与DI详解</span><a href=\"#ioc-yu-di-xiang-jie\" class=\"header-anchor\">#</a></h2>\n<h3><span id=\"ioc-de-shi-xian-fang-shi-ji-yu-di-de-guan-xi\">IoC的实现方式 及 与DI的关系？</span><a href=\"#ioc-de-shi-xian-fang-shi-ji-yu-di-de-guan-xi\" class=\"header-anchor\">#</a></h3>\n<p>**依赖查找(Dependency Lookup)：**容器中的受控对象通过容器的API来查找自己所依赖的资源和协作对象。<br>\n这种方式虽然降低了对象间的依赖，但是同时也使用到了容器的API，造成了我们无法在容器外使用和测试对象。<br>\n依赖查找是一种更加传统的IoC实现方式。</p>\n<p>**依赖注入(Dependency Injection)：**这就是DI，字面上理解，依赖注入就是将服务注入到使用它的地方。对象只提供普通的方法让容器去决定依赖关系，<br>\n容器全权负责组件的装配，它会把符合依赖关系的对象通过属性（JavaBean中的setter）或者是构造子传递给需要的对象。</p>\n<p>相对于IoC而言，依赖注入(DI)更加准确地描述了IoC的设计理念。所谓依赖注入，即组件之间的依赖关系由容器在应用系统运行期来决定，<br>\n也就是由容器动态地将某种依赖关系的目标对象实例注入到应用系统中的各个关联的组件之中。</p>\n<h3><span id=\"spring-zhong-de-ioc-yu-di\">Spring中的IoC与DI</span><a href=\"#spring-zhong-de-ioc-yu-di\" class=\"header-anchor\">#</a></h3>\n<p>IoC是Spring的核心，贯穿始终。对于Spring框架来说，就是由Spring来负责控制对象的生命周期和对象间的关系。<br>\nSpring中DI有两种实现方式—Setter方式(传值方式)和构造器方式(引用方式)。</p>\n<h3><span id=\"ioc-de-shi-xian-yuan-li-fan-she-yu-gong-han-mo-shi\">IoC的实现原理：反射与工厂模式</span><a href=\"#ioc-de-shi-xian-yuan-li-fan-she-yu-gong-han-mo-shi\" class=\"header-anchor\">#</a></h3>\n<h4><span id=\"fan-she\">反射</span><a href=\"#fan-she\" class=\"header-anchor\">#</a></h4>\n<p>反射是Java语言的一个特性，它允许程序在运行时（注意不是编译的时候）来进行自我检查并且对内部的成员进行操作。例如它允许一个Java类获取它所有的成员变量和方法并且显示出来。</p>\n<p>反射主要是指程序可以访问，检测和修改它本身状态或行为的一种能力，并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。在Java中，只要给定类的名字，那么就可以通过反射机制来获得类的所有信息。</p>\n<p><strong>反射的作用</strong></p>\n<ol>\n<li>在运行时判断任意一个对象所属的类；</li>\n<li>在运行时获取类的对象；</li>\n<li>在运行时访问java对象的属性，方法，构造方法等；</li>\n<li>在运行时修改类的对象、方法和属性</li>\n</ol>\n<p>静态编译：在编译时确定类型，绑定对象，即通过。<br><br>\n动态编译：运行时确定类型，绑定对象。动态编译最大限度发挥了Java的灵活性，体现了多态的应用，有以降低类之间的藕合性。<br></p>\n<p><strong>反射机制优缺点</strong></p>\n<p>优点：可以实现动态创建对象和编译，体现出很大的灵活性（特别是在J2EE的开发中它的灵活性就表现的十分明显）。通过反射机制我们可以获得类的各种内容，进行反编译。对于JAVA这种先编译再运行的语言来说，反射机制可以使代码更加灵活，更加容易实现面向对象。</p>\n<p>比如，一个大型的软件，不可能一次就把把它设计得很完美，把这个程序编译后，发布了，当发现需要更新某些功能时，我们不可能要用户把以前的卸载，再重新安装新的版本，假如这样的话，这个软件肯定是没有多少人用的。采用静态的话，需要把整个程序重新编译一次才可以实现功能的更新，而采用反射机制的话，它就可以不用卸载，只需要在运行时动态地创建和编译，就可以实现该功能。</p>\n<p>缺点：对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且让它满足我们的要求。这类操作总是慢于直接执行相同的操作。</p>\n<h4><span id=\"gong-han-mo-shi\">工厂模式</span><a href=\"#gong-han-mo-shi\" class=\"header-anchor\">#</a></h4>\n<p>IOC容器的工作：创建和管理Bean，它是一个工厂，负责对外提供Bean实例。</p>\n<h2><span id=\"bean\">@Bean</span><a href=\"#bean\" class=\"header-anchor\">#</a></h2>\n<p>Spring的@Bean注解用于告诉方法，产生一个Bean对象，然后这个Bean对象交给Spring管理。产生这个Bean对象的方法Spring只会调用一次，随后这个Spring将会将这个Bean对象放在自己的IOC容器中。(默认bean的名称就是其方法名。但是也可以指定名称)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BeanTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> BeanTest <span class=\"title\">getBean</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        BeanTest bean = <span class=\"keyword\">new</span>  BeanTest();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;调用方法：&quot;</span>+bean);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ClassPathXmlApplicationContext context = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">&quot;application-context.xml&quot;</span>);</span><br><span class=\"line\">        Object bean1 = context.getBean(<span class=\"string\">&quot;getBean&quot;</span>);</span><br><span class=\"line\">        System.out.println(bean1);</span><br><span class=\"line\">        Object bean2 = context.getBean(<span class=\"string\">&quot;getBean&quot;</span>);</span><br><span class=\"line\">        System.out.println(bean2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">调用方法：Spring.BeanTest@5a4041cc</span><br><span class=\"line\">Spring.BeanTest@5a4041cc</span><br><span class=\"line\">Spring.BeanTest@5a4041cc</span><br></pre></td></tr></table></figure>\n<h2><span id=\"faq\">FAQ</span><a href=\"#faq\" class=\"header-anchor\">#</a></h2>\n<h3><span id=\"spring-zhong-de-bean-shi-xian-cheng-an-quan-de-ma-bu-shi\">Spring中的Bean是线程安全的吗（不是）？</span><a href=\"#spring-zhong-de-bean-shi-xian-cheng-an-quan-de-ma-bu-shi\" class=\"header-anchor\">#</a></h3>\n<p>Spring中的Bean默认是单例模式的，框架并没有对bean进行多线程的封装处理。实际上大部分时间Bean是无状态的（比如Dao） 所以说在某种程度上来说Bean其实是安全的。但是如果Bean是有状态的 那就需要开发人员自己来进行线程安全的保证，最简单的办法就是改变bean的作用域把singleton改为protopyte这样每次请求Bean就相当于是new Bean()这样就可以保证线程的安全了。　(有状态就是有数据存储功能/无状态就是不会保存数据）</p>\n<p>线程安全这个问题，要从单例与原型Bean分别进行说明。</p>\n<p><strong>原型Bean：</strong><br>\n对于原型Bean,每次创建一个新对象，也就是线程之间并不存在Bean共享，自然是不会有线程安全的问题。</p>\n<p><strong>单例Bean：</strong><br>\n对于单例Bean,所有线程都共享一个单例实例Bean,因此是存在资源的竞争。<br>\n如果单例Bean,是一个无状态Bean，也就是线程中的操作不会对Bean的成员执行查询以外的操作，那么这个单例Bean是线程安全的。比如Spring mvc 的 Controller、Service、Dao等，这些Bean大多是无状态的，只关注于方法本身。</p>\n<h3><span id=\"spring-de-bean-zuo-yong-yu-scope-lei-xing\">Spring 的 bean 作用域（scope）类型 ?</span><a href=\"#spring-de-bean-zuo-yong-yu-scope-lei-xing\" class=\"header-anchor\">#</a></h3>\n<ol>\n<li>singleton:单例，默认作用域。</li>\n<li>prototype:原型，每次创建一个新对象。</li>\n<li>request:请求，每次Http请求创建一个新对象，适用于WebApplicationContext环境下。</li>\n<li>session:会话，同一个会话共享一个实例，不同会话使用不用的实例。</li>\n<li>global-session:全局会话，所有会话共享一个实例。</li>\n</ol>\n<h3><span id=\"service-he-controller-shi-fou-xian-cheng-an-quan\">@Service和@Controller是否线程安全？</span><a href=\"#service-he-controller-shi-fou-xian-cheng-an-quan\" class=\"header-anchor\">#</a></h3>\n<p>默认配置下不是的。为啥呢？因为默认情况下@Controller没有加上@Scope，没有加@Scope就是默认值singleton，单例的。意思就是系统只会初始化一次Controller容器，所以每次请求的都是同一个Controller容器，当然是非线程安全的。</p>\n<ol>\n<li>在@Controller/@Service等容器中，默认情况下，scope值是单例-singleton的，也是线程不安全的</li>\n<li>尽量不要在@Controller/@Service等容器中定义静态变量，不论是单例(singleton)还是多实例(prototype)他都是线程不安全的</li>\n<li>默认注入的Bean对象，在不设置scope的时候他也是线程不安全的</li>\n<li>一定要定义变量的话，用ThreadLocal来封装，这个是线程安全的</li>\n</ol>\n<blockquote>\n<p>多线程场景下，多个线程对这个单例Bean的成员变量并不存在资源的竞争，因为ThreadLocal为每个线程保存线程私有的数据。这是一种以空间换时间的方式。</p>\n</blockquote>\n<h3><span id=\"bean-he-component-zhi-jian-de-lian-xi-he-qu-bie\">@Bean和@Component之间的联系和区别</span><a href=\"#bean-he-component-zhi-jian-de-lian-xi-he-qu-bie\" class=\"header-anchor\">#</a></h3>\n<p><strong>@Component</strong><br>\n注解表明一个类会作为组件类，并告知Spring要为这个类创建bean，（@Controller,@Service,@Repository实际上都包含了@Component注解）</p>\n<p><strong>@Bean</strong><br>\n用在方法上，一般有返回值，@Bean注解告诉Spring这个方法将会返回一个对象，这个对象要注册为Spring应用上下文中的bean。通常方法体中包含了最终产生bean实例的逻辑；第三方的类，如果要注册到spring中，一般用bean的方式。</p>\n<h3><span id=\"applicationcontext-yu-beanfactory-qu-bie\">ApplicationContext 与 BeanFactory 区别</span><a href=\"#applicationcontext-yu-beanfactory-qu-bie\" class=\"header-anchor\">#</a></h3>\n<p>Bean工厂（BeanFactory）是Spring框架的最核心接口，它提供了高级Ioc的配置机制。应用上下文（ApplicationContext）是BeanFactory的实现，以Bean工厂为基础，它提供了更多面向应用的功能。</p>\n<p>在用途上，BeanFactory是Spring框架的基础设施，面向Spring本身，我们一般不直接使用；ApplicationContext面向使用Spring框架的开发者，所以，在几乎所有的应用场合我们都使用应用上下文而非Bean工厂。</p>\n<h2><span id=\"kuo-zhan-yue-du\">扩展阅读</span><a href=\"#kuo-zhan-yue-du\" class=\"header-anchor\">#</a></h2>\n<ol>\n<li>Spring 中的bean 是线程安全的吗： <a href=\"https://www.cnblogs.com/myseries/p/11729800.html\">https://www.cnblogs.com/myseries/p/11729800.html</a></li>\n<li>Bean 文档： <a href=\"https://wiki.jikexueyuan.com/project/spring/bean-definition.html\">https://wiki.jikexueyuan.com/project/spring/bean-definition.html</a></li>\n</ol>\n<link rel=\"stylesheet\" href=\"/css/markmap.css\" type=\"text/css\">","tags":[{"name":"Java","slug":"Java","permalink":"https://blog.beyhub.com/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://blog.beyhub.com/tags/Spring/"}]},{"title":"一文看懂Zookeeper","path":"post/一文看懂zookeeper/","text":"Apache ZooKeeper是Apache软件基金会的一个软件项目，它为大型分布式计算提供开源的分布式配置服务、同步服务和命名注册。 ZooKeeper曾经是Hadoop的一个子项目，但现在是一个独立的顶级项目。ZooKeeper的架构通过冗余服务实现高可用性（英语：High-availability cluster）。 因此，如果第一次无应答，客户端就可以询问另一台ZooKeeper主机。ZooKeeper节点将它们的数据存储于一个分层的命名空间，非常类似于一个文件系统或一个前缀树结构。客户端可以在节点读写，从而以这种方式拥有一个共享的配置服务。 简介# 概述 应用场景 目录服务 配置管理 同步 集群节点选举 消息队列 通知系统 下载地址 数据结构 文件系统+通知机制（观察者模式） 知识点# 选举机制（重要）# 半数机制：集群中半数以上机器可用，集群可用。所以zookeeper适合奇数台服务器 Zookeeper虽然在配置文件中没有指定Master和Slave，但Zookeeper在工作时，有一个节点是Leader，其它节点为Follwer，Leader是通过内部选举机制产生的 监听器原理（重要）# 常见的监听：1. 监听节点数据变化(get path watch) 2. 监听子节点增减的变化(ls path watch) 监听原理解析 首先有一个main()线程 在main线程创建zookeeper客户端，这时就会创建两个线程，一个负责网络通信(connet)，一个负责监听(listener) 通过connect线程将注册的监听事件发送给zookeeper 在Zookeeper的注册监听器列表中将注册的监听事件添加到列表中 Zookeeper监听到有数据或路径变化，就将会把这个消息发送给listener线程 listener线程内部调用了process()方法 节点类型# 持久(Persistent): 客户端和服务器断开连接后，创建节点不删除 短暂(Ephemeral): 客户端和服务器断开连接后，创建的节点自己删除 Stat结构体# 写数据流程# client 向Zookeeper的server1上写数据，发送一个写请求 如果server1不是Leader，则把请求转发给Leader，Leader再广播给Follwer 当Leader收到大多数Server写成功了 实战# 分布式安装部署# 集群规划 解压 配置服务器编号 1234mkdir zkDatacd zkDatatouch myid # 集群的唯一标识echo 1&gt; myid # myid为递增的数字 常用命令命令行# 1234567891011121314bin/zkCli.sh # 进入客户端ls # 查看节点ls2 # 查看节点详细数据create /sanguo &quot;jinlian&quot; # 创建节点（必须要写数据）create /sanguo/shuguo &quot;刘备&quot; # 创建多级节点 delete path # 删除当前pathrmr path # 递归删除所有下级路径get path # 取出节点的数据ls /sanguoset path # 修改节点的数据ls path watch # 监听子节点增减的变化get path watch # 监听节点数据变化（注册一次，只生效一次）stat path # 查看路径的详细信息 FAQ# zookeeper的部署方式有几种？集群中有哪些角色？集群最少要几台机器 部署方式：单机模式、集群模式 集群中最少需要几台机器：3台 跳转到github看examples Zookeeper是大数据框架中比较基础，也比较简单的一个，你已经掌握了吗？","content":"<p>Apache ZooKeeper是Apache软件基金会的一个软件项目，它为大型分布式计算提供开源的分布式配置服务、同步服务和命名注册。 ZooKeeper曾经是Hadoop的一个子项目，但现在是一个独立的顶级项目。ZooKeeper的架构通过冗余服务实现高可用性（英语：High-availability cluster）。</p>\n<p>因此，如果第一次无应答，客户端就可以询问另一台ZooKeeper主机。ZooKeeper节点将它们的数据存储于一个分层的命名空间，非常类似于一个文件系统或一个前缀树结构。客户端可以在节点读写，从而以这种方式拥有一个共享的配置服务。</p>\n<span id=\"more\"></span>\n<h2><span id=\"jian-jie\">简介</span><a href=\"#jian-jie\" class=\"header-anchor\">#</a></h2>\n<ol>\n<li>概述</li>\n<li>应用场景<br>\n目录服务<br>\n配置管理<br>\n同步<br>\n集群节点选举<br>\n消息队列<br>\n通知系统</li>\n<li>下载地址</li>\n<li>数据结构<br>\n文件系统+通知机制（观察者模式）</li>\n</ol>\n<h2><span id=\"zhi-shi-dian\">知识点</span><a href=\"#zhi-shi-dian\" class=\"header-anchor\">#</a></h2>\n<h3><span id=\"xuan-ju-ji-zhi-chong-yao\">选举机制（重要）</span><a href=\"#xuan-ju-ji-zhi-chong-yao\" class=\"header-anchor\">#</a></h3>\n<ol>\n<li>半数机制：集群中半数以上机器可用，集群可用。所以zookeeper适合奇数台服务器</li>\n<li>Zookeeper虽然在配置文件中没有指定Master和Slave，但Zookeeper在工作时，有一个节点是Leader，其它节点为Follwer，Leader是通过内部选举机制产生的</li>\n</ol>\n<h3><span id=\"jian-ting-qi-yuan-li-chong-yao\">监听器原理（重要）</span><a href=\"#jian-ting-qi-yuan-li-chong-yao\" class=\"header-anchor\">#</a></h3>\n<blockquote>\n<p>常见的监听：1. 监听节点数据变化(get path watch) 2. 监听子节点增减的变化(ls path watch)</p>\n</blockquote>\n<p>监听原理解析</p>\n<ol>\n<li>首先有一个main()线程</li>\n<li>在main线程创建zookeeper客户端，这时就会创建两个线程，一个负责网络通信(connet)，一个负责监听(listener)</li>\n<li>通过connect线程将注册的监听事件发送给zookeeper</li>\n<li>在Zookeeper的注册监听器列表中将注册的监听事件添加到列表中</li>\n<li>Zookeeper监听到有数据或路径变化，就将会把这个消息发送给listener线程</li>\n<li>listener线程内部调用了process()方法<br>\n<img src=\"/images/posts/2020/zk-listener%E5%8E%9F%E7%90%86.png\" alt></li>\n</ol>\n<h3><span id=\"jie-dian-lei-xing\">节点类型</span><a href=\"#jie-dian-lei-xing\" class=\"header-anchor\">#</a></h3>\n<ol>\n<li>持久(Persistent): 客户端和服务器断开连接后，创建节点不删除</li>\n<li>短暂(Ephemeral): 客户端和服务器断开连接后，创建的节点自己删除</li>\n</ol>\n<h3><span id=\"stat-jie-gou-ti\">Stat结构体</span><a href=\"#stat-jie-gou-ti\" class=\"header-anchor\">#</a></h3>\n<h3><span id=\"xie-shu-ju-liu-cheng\">写数据流程</span><a href=\"#xie-shu-ju-liu-cheng\" class=\"header-anchor\">#</a></h3>\n<ol>\n<li>client 向Zookeeper的server1上写数据，发送一个写请求</li>\n<li>如果server1不是Leader，则把请求转发给Leader，Leader再广播给Follwer</li>\n<li>当Leader收到大多数Server写成功了</li>\n</ol>\n<p><img src=\"/images/posts/2020/zk-%E5%86%99%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B.png\" alt></p>\n<h2><span id=\"shi-zhan\">实战</span><a href=\"#shi-zhan\" class=\"header-anchor\">#</a></h2>\n<h3><span id=\"fen-bu-shi-an-zhuang-bu-shu\">分布式安装部署</span><a href=\"#fen-bu-shi-an-zhuang-bu-shu\" class=\"header-anchor\">#</a></h3>\n<ol>\n<li>集群规划</li>\n<li>解压</li>\n<li>配置服务器编号</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir zkData</span><br><span class=\"line\"><span class=\"built_in\">cd</span> zkData</span><br><span class=\"line\">touch myid  <span class=\"comment\"># 集群的唯一标识</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> 1&gt; myid  <span class=\"comment\"># myid为递增的数字</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"chang-yong-ming-ling-ming-ling-xing\">常用命令命令行</span><a href=\"#chang-yong-ming-ling-ming-ling-xing\" class=\"header-anchor\">#</a></h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bin/zkCli.sh  <span class=\"comment\"># 进入客户端</span></span><br><span class=\"line\">ls <span class=\"comment\"># 查看节点</span></span><br><span class=\"line\">ls2 <span class=\"comment\"># 查看节点详细数据</span></span><br><span class=\"line\">create /sanguo <span class=\"string\">&quot;jinlian&quot;</span> <span class=\"comment\"># 创建节点（必须要写数据）</span></span><br><span class=\"line\">create /sanguo/shuguo <span class=\"string\">&quot;刘备&quot;</span> <span class=\"comment\"># 创建多级节点 </span></span><br><span class=\"line\">delete path <span class=\"comment\"># 删除当前path</span></span><br><span class=\"line\">rmr path <span class=\"comment\"># 递归删除所有下级路径</span></span><br><span class=\"line\">get path <span class=\"comment\"># 取出节点的数据</span></span><br><span class=\"line\">ls /sanguo</span><br><span class=\"line\"><span class=\"built_in\">set</span> path <span class=\"comment\"># 修改节点的数据</span></span><br><span class=\"line\">ls path watch <span class=\"comment\"># 监听子节点增减的变化</span></span><br><span class=\"line\">get path watch <span class=\"comment\"># 监听节点数据变化（注册一次，只生效一次）</span></span><br><span class=\"line\"><span class=\"built_in\">stat</span> path <span class=\"comment\"># 查看路径的详细信息</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2><span id=\"faq\">FAQ</span><a href=\"#faq\" class=\"header-anchor\">#</a></h2>\n<ol>\n<li>zookeeper的部署方式有几种？集群中有哪些角色？集群最少要几台机器\n<ul>\n<li>部署方式：单机模式、集群模式</li>\n<li>集群中最少需要几台机器：3台</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/tenstone/spring-boot-zookeeper-examples\">跳转到github看examples</a></li>\n</ol>\n<p>Zookeeper是大数据框架中比较基础，也比较简单的一个，你已经掌握了吗？</p>\n<link rel=\"stylesheet\" href=\"/css/markmap.css\" type=\"text/css\">","tags":[{"name":"zookeeper","slug":"zookeeper","permalink":"https://blog.beyhub.com/tags/zookeeper/"}]}],"categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.beyhub.com/tags/Java/"},{"name":"锁","slug":"锁","permalink":"https://blog.beyhub.com/tags/%E9%94%81/"},{"name":"高并发","slug":"高并发","permalink":"https://blog.beyhub.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"},{"name":"java","slug":"java","permalink":"https://blog.beyhub.com/tags/java/"},{"name":"MySQL","slug":"MySQL","permalink":"https://blog.beyhub.com/tags/MySQL/"},{"name":"面试题","slug":"面试题","permalink":"https://blog.beyhub.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"原理","slug":"原理","permalink":"https://blog.beyhub.com/tags/%E5%8E%9F%E7%90%86/"},{"name":"数据库","slug":"数据库","permalink":"https://blog.beyhub.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"大数据","slug":"大数据","permalink":"https://blog.beyhub.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"分布式","slug":"分布式","permalink":"https://blog.beyhub.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"BPMN","slug":"BPMN","permalink":"https://blog.beyhub.com/tags/BPMN/"},{"name":"JVM","slug":"JVM","permalink":"https://blog.beyhub.com/tags/JVM/"},{"name":"定时任务","slug":"定时任务","permalink":"https://blog.beyhub.com/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"},{"name":"Spring","slug":"Spring","permalink":"https://blog.beyhub.com/tags/Spring/"},{"name":"zookeeper","slug":"zookeeper","permalink":"https://blog.beyhub.com/tags/zookeeper/"}]}