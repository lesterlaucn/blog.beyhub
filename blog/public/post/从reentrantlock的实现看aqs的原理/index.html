<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport"
    content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <meta name="theme-color" content="#000000">
  <meta http-equiv="window-target" content="_top">
  <title>从ReentrantLock的实现看AQS的原理 | 采菊东篱</title>
  <meta name="description"
    content="Java中的大部分同步类（Lock、Semaphore、ReentrantLock等）都是基于AbstractQueuedSynchronizer（简称为AQS）实现的。AQS是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架。本文会从应用层逐渐深入到原理层，并通过ReentrantLock的基本特性和ReentrantLock与AQS的关联，来深入解读AQS相关独占锁的知识">
  <meta property="og:type" content="article">
  <meta property="og:title" content="从ReentrantLock的实现看AQS的原理">
  <meta property="og:url"
    content="https://blog.beyhub.com/post/%E4%BB%8Ereentrantlock%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9C%8Baqs%E7%9A%84%E5%8E%9F%E7%90%86/index.html">
  <meta property="og:site_name" content="采菊东篱">
  <meta property="og:description"
    content="Java中的大部分同步类（Lock、Semaphore、ReentrantLock等）都是基于AbstractQueuedSynchronizer（简称为AQS）实现的。AQS是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架。本文会从应用层逐渐深入到原理层，并通过ReentrantLock的基本特性和ReentrantLock与AQS的关联，来深入解读AQS相关独占锁的知识">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:image" content="https://p1.meituan.net/travelcube/9d182d944e0889c304ef529ba50a4fcd205214.png">
  <meta property="og:image" content="https://p0.meituan.net/travelcube/412d294ff5535bbcddc0d979b2a339e6102264.png">
  <meta property="og:image" content="https://p1.meituan.net/travelcube/82077ccf14127a87b77cefd1ccf562d3253591.png">
  <meta property="og:image" content="https://p1.meituan.net/travelcube/d2f7f7fffdc30d85d17b44266c3ab05323338.png">
  <meta property="og:image" content="https://p0.meituan.net/travelcube/7132e4cef44c26f62835b197b239147b18062.png">
  <meta property="og:image" content="https://p1.meituan.net/travelcube/960271cf2b5c8a185eed23e98b72c75538637.png">
  <meta property="og:image" content="https://p0.meituan.net/travelcube/27605d483e8935da683a93be015713f331378.png">
  <meta property="og:image" content="https://p0.meituan.net/travelcube/3f1e1a44f5b7d77000ba4f9476189b2e32806.png">
  <meta property="og:image" content="https://p1.meituan.net/travelcube/b8b53a70984668bc68653efe9531573e78636.png">
  <meta property="og:image" content="https://p1.meituan.net/travelcube/7aadb272069d871bdee8bf3a218eed8136919.png">
  <meta property="og:image" content="https://p0.meituan.net/travelcube/f30c631c8ebbf820d3e8fcb6eee3c0ef18748.png">
  <meta property="og:image" content="https://p0.meituan.net/travelcube/e9e385c3c68f62c67c8d62ab0adb613921117.png">
  <meta property="og:image" content="https://p0.meituan.net/travelcube/c124b76dcbefb9bdc778458064703d1135485.png">
  <meta property="og:image" content="https://p0.meituan.net/travelcube/9af16e2481ad85f38ca322a225ae737535740.png">
  <meta property="og:image" content="https://p1.meituan.net/travelcube/b845211ced57561c24f79d56194949e822049.png">
  <meta property="og:image" content="https://p1.meituan.net/travelcube/ab89bfec875846e5028a4f8fead32b7117975.png">
  <meta property="og:image" content="https://p0.meituan.net/travelcube/45d0d9e4a6897eddadc4397cf53d6cd522452.png">
  <meta property="article:published_time" content="2021-04-12T15:12:22.000Z">
  <meta property="article:modified_time" content="2022-04-12T15:12:27.292Z">
  <meta property="article:author" content="刘远程 (Lester Lau)">
  <meta property="article:tag" content="Java">
  <meta property="article:tag" content="锁">
  <meta property="article:tag" content="高并发">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:image" content="https://p1.meituan.net/travelcube/9d182d944e0889c304ef529ba50a4fcd205214.png">
  <link rel="canonical"
    href="https://blog.beyhub.com/post/%E4%BB%8Ereentrantlock%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9C%8Baqs%E7%9A%84%E5%8E%9F%E7%90%86/index.html">
  <link rel="alternate" href="/atom.xml" title="采菊东篱" type="application/atom+xml">
  <link rel="icon" href="/favicon.png" type="image/x-icon">
  <link rel="stylesheet" href="/css/style.css">
  <link href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css" rel="stylesheet">
  <meta name="generator" content="Hexo 5.4.0">
</head>

<body class="main-center theme-purple" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
    <div class="slimContent">
      <div class="navbar-header">
        <div class="profile-block text-center"><a id="avatar" href="/about/"><img class="img-circle img-rotate"
              src="/images/avatar.jpg" width="200" height="200"></a>
          <h2 id="name" class="hidden-xs hidden-sm">Lester Lau</h2>
          <h3 id="title" class="hidden-xs hidden-sm hidden-md" style="margin-top:13px;margin-bottom:6px">采菊东篱下，悠然见南山
          </h3><small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> NanJing,
            China</small>
        </div>
        <div class="search" id="search-form-wrap">
          <form class="search-form sidebar-form">
            <div class="input-group"><input type="text" class="search-form-input form-control" placeholder="搜索"> <span
                class="input-group-btn"><button type="submit" class="search-form-submit btn btn-flat"
                  onclick="return!1"><i class="icon icon-search"></i></button></span></div>
          </form>
          <div class="ins-search">
            <div class="ins-search-mask"></div>
            <div class="ins-search-container">
              <div class="ins-input-wrapper"><input type="text" class="ins-search-input" placeholder="想要查找什么..."
                  x-webkit-speech> <button type="button" class="close ins-close ins-selectable" data-dismiss="modal"
                  aria-label="Close"><span aria-hidden="true">×</span></button></div>
              <div class="ins-section-wrapper">
                <div class="ins-section-container"></div>
              </div>
            </div>
          </div>
        </div><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar"
          aria-controls="main-navbar" aria-expanded="false"><span class="sr-only">Toggle navigation</span> <span
            class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button>
      </div>
      <nav id="main-navbar" class="collapse navbar-collapse" itemscope
        itemtype="http://schema.org/SiteNavigationElement" role="navigation">
        <ul class="nav navbar-nav main-nav menu-highlight">
          <li class="menu-item menu-item-home"><a href="/."><i class="icon icon-home-fill"></i> <span
                class="menu-title">首页</span></a></li>
          <li class="menu-item menu-item-archives"><a href="/archives"><i class="icon icon-archives-fill"></i> <span
                class="menu-title">归档</span></a></li>
          <li class="menu-item menu-item-categories"><a href="/categories"><i class="icon icon-folder"></i> <span
                class="menu-title">文章分类</span></a></li>
          <li class="menu-item menu-item-tags"><a href="/tags"><i class="icon icon-tags"></i> <span
                class="menu-title">标签</span></a></li>
          <li class="menu-item menu-item-links"><a href="/links"><i class="icon icon-friendship"></i> <span
                class="menu-title">常用网址</span></a></li>
          <li class="menu-item menu-item-about"><a href="/about"><i class="icon icon-cup-fill"></i> <span
                class="menu-title">关于我</span></a></li>
        </ul>
        <ul class="social-links">
          <li><a href="https://github.com/lesterlaucn" target="_blank" title="Github" data-toggle="tooltip"
              data-placement="top"><i class="icon icon-github"></i></a></li>
          <li><a href="http://weibo.com/lyc90" target="_blank" title="Weibo" data-toggle="tooltip"
              data-placement="top"><i class="icon icon-weibo"></i></a></li>
          <li><a href="https://twitter.com/lesterlaucn" target="_blank" title="Twitter" data-toggle="tooltip"
              data-placement="top"><i class="icon icon-twitter"></i></a></li>
          <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i
                class="icon icon-rss"></i></a></li>
        </ul>
      </nav>
    </div>
  </header>
  <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
    <div class="slimContent">
      <div class="widget">
        <h3 class="widget-title">公告</h3>
        <div class="widget-body">
          <div id="board">
            <div class="content">
              <p>永远只相信事实及其推论</p>
            </div>
          </div>
        </div>
      </div>
      <div class="widget">
        <h3 class="widget-title">标签云</h3>
        <div class="widget-body tagcloud"><a href="/tags/BPMN/" style="font-size:13px">BPMN</a> <a
            href="/tags/BinarySearch/" style="font-size:13px">BinarySearch</a> <a href="/tags/JVM/"
            style="font-size:13px">JVM</a> <a href="/tags/Java/" style="font-size:13.67px">Java</a> <a href="/tags/K3s/"
            style="font-size:13px">K3s</a> <a href="/tags/Kubernetes/" style="font-size:13px">Kubernetes</a> <a
            href="/tags/MySQL/" style="font-size:14px">MySQL</a> <a href="/tags/Proxy/" style="font-size:13px">Proxy</a>
          <a href="/tags/Spring/" style="font-size:13px">Spring</a> <a href="/tags/Traefik/"
            style="font-size:13px">Traefik</a> <a href="/tags/java/" style="font-size:13px">java</a> <a
            href="/tags/untagged/" style="font-size:13.33px">untagged</a> <a href="/tags/zookeeper/"
            style="font-size:13px">zookeeper</a> <a href="/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"
            style="font-size:13px">二分法</a> <a href="/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/" style="font-size:13px">云原生</a>
          <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size:13px">分布式</a> <a
            href="/tags/%E5%8E%9F%E7%90%86/" style="font-size:13.33px">原理</a> <a
            href="/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/" style="font-size:13px">定时任务</a> <a
            href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size:13px">数据库</a> <a href="/tags/%E9%94%81/"
            style="font-size:13.67px">锁</a> <a href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/" style="font-size:13px">高并发</a>
        </div>
      </div>
      <div class="widget">
        <h3 class="widget-title">分类</h3>
        <div class="widget-body">
          <ul class="category-list">
            <li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span
                class="category-list-count">5</span></li>
            <li class="category-list-item"><a class="category-list-link"
                href="/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/">云原生</a><span class="category-list-count">1</span></li>
            <li class="category-list-item"><a class="category-list-link"
                href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><span class="category-list-count">1</span></li>
            <li class="category-list-item"><a class="category-list-link"
                href="/categories/%E5%90%8E%E7%AB%AF/">后端</a><span class="category-list-count">7</span></li>
            <li class="category-list-item"><a class="category-list-link"
                href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</a><span
                class="category-list-count">1</span></li>
            <li class="category-list-item"><a class="category-list-link"
                href="/categories/%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87/">工作效率</a><span
                class="category-list-count">1</span></li>
            <li class="category-list-item"><a class="category-list-link"
                href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="category-list-count">2</span></li>
            <li class="category-list-item"><a class="category-list-link"
                href="/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/">未分类</a><span class="category-list-count">1</span></li>
            <li class="category-list-item"><a class="category-list-link"
                href="/categories/%E6%BA%90%E7%A0%81/">源码</a><span class="category-list-count">1</span></li>
            <li class="category-list-item"><a class="category-list-link"
                href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span class="category-list-count">1</span></li>
          </ul>
        </div>
      </div>
      <div class="widget">
        <h3 class="widget-title">最新文章</h3>
        <div class="widget-body">
          <ul class="recent-post-list list-unstyled no-thumbnail">
            <li>
              <div class="item-inner">
                <p class="item-title"><a
                    href="/post/kubernetes%E5%AE%9E%E7%8E%B0traefik%E4%BB%A3%E7%90%86mysql%E6%B5%81%E9%87%8F/"
                    class="title">Kubernetes实现Traefik代理MySQL流量</a></p>
                <p class="item-date"><time datetime="2022-04-12T07:44:46.000Z"
                    itemprop="datePublished">2022-04-12</time></p>
              </div>
            </li>
            <li>
              <div class="item-inner">
                <p class="item-title"><a href="/post/%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE/"
                    class="title">二分法查找</a></p>
                <p class="item-date"><time datetime="2022-04-12T02:45:18.000Z"
                    itemprop="datePublished">2022-04-12</time></p>
              </div>
            </li>
            <li>
              <div class="item-inner">
                <p class="item-title"><a href="/post/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAk3s%E7%8E%AF%E5%A2%83/"
                    class="title">快速搭建K3S环境</a></p>
                <p class="item-date"><time datetime="2022-04-12T02:42:45.000Z"
                    itemprop="datePublished">2022-04-12</time></p>
              </div>
            </li>
            <li>
              <div class="item-inner">
                <p class="item-title"><a href="/post/%E5%B0%8F%E7%B1%B3ax6000%E8%81%AA%E6%98%8E%E4%B8%8A%E7%BD%91/"
                    class="title">小米AX6000聪明上网</a></p>
                <p class="item-date"><time datetime="2022-04-12T02:42:37.000Z"
                    itemprop="datePublished">2022-04-12</time></p>
              </div>
            </li>
            <li>
              <div class="item-inner">
                <p class="item-title"><a
                    href="/post/%E5%9F%BA%E4%BA%8Ek3s%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAflink-session-cluster/"
                    class="title">基于K3S快速搭建Flink Session Cluster</a></p>
                <p class="item-date"><time datetime="2022-04-12T02:42:30.000Z"
                    itemprop="datePublished">2022-04-12</time></p>
              </div>
            </li>
          </ul>
        </div>
      </div>
    </div>
  </aside>
  <aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
    <div class="slimContent">
      <nav id="toc" class="article-toc">
        <h3 class="toc-title">文章目录</h3>
        <ol class="toc">
          <li class="toc-item toc-level-2"><a class="toc-link" href="#1-ReentrantLock"><span
                class="toc-number">1.</span> <span class="toc-text">1 ReentrantLock</span></a>
            <ol class="toc-child">
              <li class="toc-item toc-level-3"><a class="toc-link"
                  href="#1-1-ReentrantLock%E7%89%B9%E6%80%A7%E6%A6%82%E8%A7%88"><span class="toc-number">1.1.</span>
                  <span class="toc-text">1.1 ReentrantLock特性概览</span></a></li>
              <li class="toc-item toc-level-3"><a class="toc-link"
                  href="#1-2-ReentrantLock%E4%B8%8EAQS%E7%9A%84%E5%85%B3%E8%81%94"><span class="toc-number">1.2.</span>
                  <span class="toc-text">1.2 ReentrantLock与AQS的关联</span></a></li>
            </ol>
          </li>
          <li class="toc-item toc-level-2"><a class="toc-link" href="#2-AQS"><span class="toc-number">2.</span> <span
                class="toc-text">2 AQS</span></a>
            <ol class="toc-child">
              <li class="toc-item toc-level-3"><a class="toc-link"
                  href="#2-1-%E5%8E%9F%E7%90%86%E6%A6%82%E8%A7%88"><span class="toc-number">2.1.</span> <span
                    class="toc-text">2.1 原理概览</span></a>
                <ol class="toc-child">
                  <li class="toc-item toc-level-4"><a class="toc-link"
                      href="#2-1-1-AQS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.1.</span> <span
                        class="toc-text">2.1.1 AQS数据结构</span></a></li>
                  <li class="toc-item toc-level-4"><a class="toc-link"
                      href="#2-1-2-%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81State"><span class="toc-number">2.1.2.</span>
                      <span class="toc-text">2.1.2 同步状态State</span></a></li>
                </ol>
              </li>
            </ol>
          </li>
          <li class="toc-item toc-level-2"><a class="toc-link"
              href="#2-2-AQS%E9%87%8D%E8%A6%81%E6%96%B9%E6%B3%95%E4%B8%8EReentrantLock%E7%9A%84%E5%85%B3%E8%81%94"><span
                class="toc-number">3.</span> <span class="toc-text">2.2 AQS重要方法与ReentrantLock的关联</span></a></li>
          <li class="toc-item toc-level-2"><a class="toc-link"
              href="#2-3-%E9%80%9A%E8%BF%87ReentrantLock%E7%90%86%E8%A7%A3AQS"><span class="toc-number">4.</span> <span
                class="toc-text">2.3 通过ReentrantLock理解AQS</span></a>
            <ol class="toc-child">
              <li class="toc-item toc-level-3"><a class="toc-link"
                  href="#2-3-1-%E7%BA%BF%E7%A8%8B%E5%8A%A0%E5%85%A5%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97"><span
                    class="toc-number">4.1.</span> <span class="toc-text">2.3.1 线程加入等待队列</span></a>
                <ol class="toc-child">
                  <li class="toc-item toc-level-4"><a class="toc-link"
                      href="#2-3-1-1-%E5%8A%A0%E5%85%A5%E9%98%9F%E5%88%97%E7%9A%84%E6%97%B6%E6%9C%BA"><span
                        class="toc-number">4.1.1.</span> <span class="toc-text">2.3.1.1 加入队列的时机</span></a></li>
                  <li class="toc-item toc-level-4"><a class="toc-link"
                      href="#2-3-1-2-%E5%A6%82%E4%BD%95%E5%8A%A0%E5%85%A5%E9%98%9F%E5%88%97"><span
                        class="toc-number">4.1.2.</span> <span class="toc-text">2.3.1.2 如何加入队列</span></a></li>
                  <li class="toc-item toc-level-4"><a class="toc-link"
                      href="#2-3-1-3-%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97%E4%B8%AD%E7%BA%BF%E7%A8%8B%E5%87%BA%E9%98%9F%E5%88%97%E6%97%B6%E6%9C%BA"><span
                        class="toc-number">4.1.3.</span> <span class="toc-text">2.3.1.3 等待队列中线程出队列时机</span></a></li>
                </ol>
              </li>
              <li class="toc-item toc-level-3"><a class="toc-link"
                  href="#2-3-2-CANCELLED%E7%8A%B6%E6%80%81%E8%8A%82%E7%82%B9%E7%94%9F%E6%88%90"><span
                    class="toc-number">4.2.</span> <span class="toc-text">2.3.2 CANCELLED状态节点生成</span></a></li>
              <li class="toc-item toc-level-3"><a class="toc-link"
                  href="#2-3-3-%E5%A6%82%E4%BD%95%E8%A7%A3%E9%94%81"><span class="toc-number">4.3.</span> <span
                    class="toc-text">2.3.3 如何解锁</span></a></li>
              <li class="toc-item toc-level-3"><a class="toc-link"
                  href="#2-3-4-%E4%B8%AD%E6%96%AD%E6%81%A2%E5%A4%8D%E5%90%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span
                    class="toc-number">4.4.</span> <span class="toc-text">2.3.4 中断恢复后的执行流程</span></a></li>
              <li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-5-%E5%B0%8F%E7%BB%93"><span
                    class="toc-number">4.5.</span> <span class="toc-text">2.3.5 小结</span></a></li>
            </ol>
          </li>
          <li class="toc-item toc-level-2"><a class="toc-link" href="#3-AQS%E5%BA%94%E7%94%A8"><span
                class="toc-number">5.</span> <span class="toc-text">3 AQS应用</span></a>
            <ol class="toc-child">
              <li class="toc-item toc-level-3"><a class="toc-link"
                  href="#3-1-ReentrantLock%E7%9A%84%E5%8F%AF%E9%87%8D%E5%85%A5%E5%BA%94%E7%94%A8"><span
                    class="toc-number">5.1.</span> <span class="toc-text">3.1 ReentrantLock的可重入应用</span></a></li>
              <li class="toc-item toc-level-3"><a class="toc-link"
                  href="#3-2-JUC%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span
                    class="toc-number">5.2.</span> <span class="toc-text">3.2 JUC中的应用场景</span></a></li>
              <li class="toc-item toc-level-3"><a class="toc-link"
                  href="#3-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7"><span
                    class="toc-number">5.3.</span> <span class="toc-text">3.3 自定义同步工具</span></a></li>
            </ol>
          </li>
          <li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span
                class="toc-number">6.</span> <span class="toc-text">总结</span></a></li>
          <li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span
                class="toc-number">7.</span> <span class="toc-text">参考资料</span></a></li>
        </ol>
      </nav>
    </div>
  </aside>
  <main class="main" role="main">
    <div class="content">
      <article id="post-2021/从ReentrantLock的实现看AQS的原理" class="article article-type-post" itemscope
        itemtype="http://schema.org/BlogPosting">
        <div class="article-header">
          <h1 class="article-title" itemprop="name">从ReentrantLock的实现看AQS的原理</h1>
          <div class="article-meta"><span class="article-date"><i class="icon icon-calendar-check"></i> <a
                href="/post/%E4%BB%8Ereentrantlock%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9C%8Baqs%E7%9A%84%E5%8E%9F%E7%90%86/"
                class="article-date"><time datetime="2021-04-12T15:12:22.000Z"
                  itemprop="datePublished">2021-04-12</time> </a></span><span class="article-category"><i
                class="icon icon-folder"></i> <a class="article-category-link"
                href="/categories/%E5%90%8E%E7%AB%AF/">后端</a> </span><span class="article-tag"><i
                class="icon icon-tags"></i> <a class="article-tag-link-link" href="/tags/Java/" rel="tag">Java</a>, <a
                class="article-tag-link-link" href="/tags/%E9%94%81/" rel="tag">锁</a>, <a class="article-tag-link-link"
                href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/" rel="tag">高并发</a> </span><span class="post-comment"><i
                class="icon icon-comment"></i> <a
                href="/post/%E4%BB%8Ereentrantlock%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9C%8Baqs%E7%9A%84%E5%8E%9F%E7%90%86/#comments"
                class="article-comment-link">评论 </a></span><span class="post-wordcount hidden-xs"
              itemprop="wordCount">字数统计: 8.2k(字)</span> <span class="post-readcount hidden-xs"
              itemprop="timeRequired">阅读时长: 32(分)</span></div>
        </div>
        <div class="article-entry marked-body" itemprop="articleBody">
          <p>
            Java中的大部分同步类（Lock、Semaphore、ReentrantLock等）都是基于AbstractQueuedSynchronizer（简称为AQS）实现的。AQS是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架。本文会从应用层逐渐深入到原理层，并通过ReentrantLock的基本特性和ReentrantLock与AQS的关联，来深入解读AQS相关独占锁的知识点，同时采取问答的模式来帮助大家理解AQS。由于篇幅原因，本篇文章主要阐述AQS中独占锁的逻辑和Sync
            Queue，不讲述包含共享锁和Condition Queue的部分（本篇文章核心为AQS原理剖析，只是简单介绍了ReentrantLock，感兴趣同学可以阅读一下ReentrantLock的源码）。</p><span
            id="more"></span>
          <p>下面列出本篇文章的大纲和思路，以便于大家更好地理解：<br><img
              src="https://p1.meituan.net/travelcube/9d182d944e0889c304ef529ba50a4fcd205214.png"></p>
          <h2 id="1-ReentrantLock"><a href="#1-ReentrantLock" class="headerlink" title="1 ReentrantLock"></a>1
            ReentrantLock</h2>
          <h3 id="1-1-ReentrantLock特性概览"><a href="#1-1-ReentrantLock特性概览" class="headerlink"
              title="1.1 ReentrantLock特性概览"></a>1.1 ReentrantLock特性概览</h3>
          <p>
            ReentrantLock意思为可重入锁，指的是一个线程能够对一个临界资源重复加锁。为了帮助大家更好地理解ReentrantLock的特性，我们先将ReentrantLock跟常用的Synchronized进行比较，其特性如下（蓝色部分为本篇文章主要剖析的点）：
          </p>
          <p><img src="https://p0.meituan.net/travelcube/412d294ff5535bbcddc0d979b2a339e6102264.png"></p>
          <p>下面通过伪代码，进行更加直观的比较：</p>
          <figure class="highlight java">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (object) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span> <span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span> <span class="params">()</span> throw Exception </span>&#123;</span><br><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(lock.tryLock(<span class="number">100</span>, TimeUnit.MILLISECONDS))&#123; &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">lock.unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>
          <h3 id="1-2-ReentrantLock与AQS的关联"><a href="#1-2-ReentrantLock与AQS的关联" class="headerlink"
              title="1.2 ReentrantLock与AQS的关联"></a>1.2 ReentrantLock与AQS的关联</h3>
          <p>通过上文我们已经了解，ReentrantLock支持公平锁和非公平锁（关于公平锁和非公平锁的原理分析，可参考《<a target="_blank" rel="noopener"
              href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651749434&idx=3&sn=5ffa63ad47fe166f2f1a9f604ed10091&chksm=bd12a5778a652c61509d9e718ab086ff27ad8768586ea9b38c3dcf9e017a8e49bcae3df9bcc8&scene=38#wechat_redirect">不可不说的Java“锁”事</a>》），并且ReentrantLock的底层就是由AQS来实现的。那么ReentrantLock是如何通过公平锁和非公平锁与AQS关联起来呢？
            我们着重从这两者的加锁过程来理解一下它们与AQS之间的关系（加锁过程中与AQS的关联比较明显，解锁流程后续会介绍）。</p>
          <p>非公平锁源码中的加锁流程如下：</p>
          <figure class="highlight java">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>
          <p>这块代码的含义为：</p>
          <ul>
            <li>
              <p>若通过CAS设置变量State（同步状态）成功，也就是获取锁成功，则将当前线程设置为独占线程。</p>
            </li>
            <li>
              <p>若通过CAS设置变量State（同步状态）失败，也就是获取锁失败，则进入Acquire方法进行后续处理。</p>
            </li>
          </ul>
          <p>第一步很好理解，但第二步获取锁失败后，后续的处理策略是怎么样的呢？这块可能会有以下思考：</p>
          <ul>
            <li>某个线程获取锁失败的后续流程是什么呢？有以下两种可能：</li>
          </ul>
          <p>(1) 将当前线程获锁结果设置为失败，获取锁流程结束。这种设计会极大降低系统的并发度，并不满足我们实际的需求。所以就需要下面这种流程，也就是AQS框架的处理流程。</p>
          <p>(2) 存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。</p>
          <ul>
            <li>
              <p>对于问题1的第二种情况，既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？</p>
            </li>
            <li>
              <p>处于排队等候机制中的线程，什么时候可以有机会获取锁呢？</p>
            </li>
            <li>
              <p>如果处于排队等候机制中的线程一直无法获取锁，还是需要一直等待吗，还是有别的策略来解决这一问题？</p>
            </li>
          </ul>
          <p>带着非公平锁的这些问题，再看下公平锁源码中获锁的方式：</p>
          <figure class="highlight plaintext">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line">static final class FairSync extends Sync &#123;</span><br><span class="line">  ...  </span><br><span class="line">final void lock() &#123;</span><br><span class="line">acquire(1);</span><br><span class="line">&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>
          <p>看到这块代码，我们可能会存在这种疑问：Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？</p>
          <p>结合公平锁和非公平锁的加锁流程，虽然流程上有一定的不同，但是都调用了Acquire方法，而Acquire方法是FairSync和UnfairSync的父类AQS中的核心方法。</p>
          <p>
            对于上边提到的问题，其实在ReentrantLock类源码中都无法解答，而这些问题的答案，都是位于Acquire方法所在的类AbstractQueuedSynchronizer中，也就是本文的核心——AQS。下面我们会对AQS以及ReentrantLock和AQS的关联做详细介绍（相关问题答案会在2.3.5小节中解答）。
          </p>
          <h2 id="2-AQS"><a href="#2-AQS" class="headerlink" title="2 AQS"></a>2 AQS</h2>
          <p>首先，我们通过下面的架构图来整体了解一下AQS框架：</p>
          <p><img src="https://p1.meituan.net/travelcube/82077ccf14127a87b77cefd1ccf562d3253591.png"></p>
          <ul>
            <li>
              <p>上图中有颜色的为Method，无颜色的为Attribution。</p>
            </li>
            <li>
              <p>总的来说，AQS框架共分为五层，自上而下由浅入深，从AQS对外暴露的API到底层基础数据。</p>
            </li>
            <li>
              <p>
                当有自定义同步器接入时，只需重写第一层所需要的部分方法即可，不需要关注底层具体的实现流程。当自定义同步器进行加锁或者解锁操作时，先经过第一层的API进入AQS内部方法，然后经过第二层进行锁的获取，接着对于获取锁失败的流程，进入第三层和第四层的等待队列处理，而这些处理方式均依赖于第五层的基础数据提供层。
              </p>
            </li>
          </ul>
          <p>下面我们会从整体到细节，从流程到方法逐一剖析AQS框架，主要分析过程如下：</p>
          <p><img src="https://p1.meituan.net/travelcube/d2f7f7fffdc30d85d17b44266c3ab05323338.png"></p>
          <h3 id="2-1-原理概览"><a href="#2-1-原理概览" class="headerlink" title="2.1 原理概览"></a>2.1 原理概览</h3>
          <p>
            AQS核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。
          </p>
          <p>CLH：Craig、Landin and Hagersten队列，是单向链表，AQS中的队列是CLH变体的虚拟双向队列（FIFO），AQS是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配。</p>
          <p>主要原理图如下：</p>
          <p><img src="https://p0.meituan.net/travelcube/7132e4cef44c26f62835b197b239147b18062.png"></p>
          <p>AQS使用一个Volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。</p>
          <h4 id="2-1-1-AQS数据结构"><a href="#2-1-1-AQS数据结构" class="headerlink" title="2.1.1 AQS数据结构"></a>2.1.1 AQS数据结构
          </h4>
          <p>先来看下AQS中最基本的数据结构——Node，Node即为上面CLH变体队列中的节点。</p>
          <p><img src="https://p1.meituan.net/travelcube/960271cf2b5c8a185eed23e98b72c75538637.png"></p>
          <p>解释一下几个方法和属性值的含义：</p>
          <table>
            <thead>
              <tr>
                <th>方法和属性值</th>
                <th>含义</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>waitStatus</td>
                <td>当前节点在队列中的状态</td>
              </tr>
              <tr>
                <td>thread</td>
                <td>表示处于该节点的线程</td>
              </tr>
              <tr>
                <td>prev</td>
                <td>前驱指针</td>
              </tr>
              <tr>
                <td>predecessor</td>
                <td>返回前驱节点，没有的话抛出npe</td>
              </tr>
              <tr>
                <td>nextWaiter</td>
                <td>指向下一个处于CONDITION状态的节点（由于本篇文章不讲述Condition Queue队列，这个指针不多介绍）</td>
              </tr>
              <tr>
                <td>next</td>
                <td>后继指针</td>
              </tr>
            </tbody>
          </table>
          <p>线程两种锁的模式：</p>
          <table>
            <thead>
              <tr>
                <th>模式</th>
                <th>含义</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>SHARED</td>
                <td>表示线程以共享的模式等待锁</td>
              </tr>
              <tr>
                <td>EXCLUSIVE</td>
                <td>表示线程正在以独占的方式等待锁</td>
              </tr>
            </tbody>
          </table>
          <p>waitStatus有下面几个枚举值：</p>
          <table>
            <thead>
              <tr>
                <th>枚举</th>
                <th>含义</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>0</td>
                <td>当一个Node被初始化的时候的默认值</td>
              </tr>
              <tr>
                <td>CANCELLED</td>
                <td>为1，表示线程获取锁的请求已经取消了</td>
              </tr>
              <tr>
                <td>CONDITION</td>
                <td>为-2，表示节点在等待队列中，节点线程等待唤醒</td>
              </tr>
              <tr>
                <td>PROPAGATE</td>
                <td>为-3，当前线程处在SHARED情况下，该字段才会使用</td>
              </tr>
              <tr>
                <td>SIGNAL</td>
                <td>为-1，表示线程已经准备好了，就等资源释放了</td>
              </tr>
            </tbody>
          </table>
          <h4 id="2-1-2-同步状态State"><a href="#2-1-2-同步状态State" class="headerlink" title="2.1.2 同步状态State"></a>2.1.2
            同步状态State</h4>
          <p>在了解数据结构后，接下来了解一下AQS的同步状态——State。AQS中维护了一个名为state的字段，意为同步状态，是由Volatile修饰的，用于展示当前临界资源的获锁情况。</p>
          <figure class="highlight plaintext">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line">private volatile int state;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>
          <p>下面提供了几个访问这个字段的方法：</p>
          <table>
            <thead>
              <tr>
                <th>方法名</th>
                <th>描述</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>protected final int getState()</td>
                <td>获取State的值</td>
              </tr>
              <tr>
                <td>protected final void setState(int newState)</td>
                <td>设置State的值</td>
              </tr>
              <tr>
                <td>protected final boolean compareAndSetState(int expect, int update)</td>
                <td>使用CAS方式更新State</td>
              </tr>
            </tbody>
          </table>
          <p>这几个方法都是Final修饰的，说明子类中无法重写它们。我们可以通过修改State字段表示的同步状态来实现多线程的独占模式和共享模式（加锁过程）。</p>
          <p><img src="https://p0.meituan.net/travelcube/27605d483e8935da683a93be015713f331378.png"> <img
              src="https://p0.meituan.net/travelcube/3f1e1a44f5b7d77000ba4f9476189b2e32806.png"></p>
          <p>对于我们自定义的同步工具，需要自定义获取同步状态和释放状态的方式，也就是AQS架构图中的第一层：API层。</p>
          <h2 id="2-2-AQS重要方法与ReentrantLock的关联"><a href="#2-2-AQS重要方法与ReentrantLock的关联" class="headerlink"
              title="2.2 AQS重要方法与ReentrantLock的关联"></a>2.2 AQS重要方法与ReentrantLock的关联</h2>
          <p>
            从架构图中可以得知，AQS提供了大量用于自定义同步器实现的Protected方法。自定义同步器实现的相关方法也只是为了通过修改State字段来实现多线程的独占模式或者共享模式。自定义同步器需要实现以下方法（ReentrantLock需要实现的方法如下，并不是全部）：
          </p>
          <table>
            <thead>
              <tr>
                <th>方法名</th>
                <th>描述</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>protected boolean isHeldExclusively()</td>
                <td>该线程是否正在独占资源。只有用到Condition才需要去实现它。</td>
              </tr>
              <tr>
                <td>protected boolean tryAcquire(int arg)</td>
                <td>独占方式。arg为获取锁的次数，尝试获取资源，成功则返回True，失败则返回False。</td>
              </tr>
              <tr>
                <td>protected boolean tryRelease(int arg)</td>
                <td>独占方式。arg为释放锁的次数，尝试释放资源，成功则返回True，失败则返回False。</td>
              </tr>
              <tr>
                <td>protected int tryAcquireShared(int arg)</td>
                <td>共享方式。arg为获取锁的次数，尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</td>
              </tr>
              <tr>
                <td>protected boolean tryReleaseShared(int arg)</td>
                <td>共享方式。arg为释放锁的次数，尝试释放资源，如果释放后允许唤醒后续等待结点返回True，否则返回False。</td>
              </tr>
            </tbody>
          </table>
          <p>
            一般来说，自定义同步器要么是独占方式，要么是共享方式，它们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。ReentrantLock是独占锁，所以实现了tryAcquire-tryRelease。
          </p>
          <p>以非公平锁为例，这里主要阐述一下非公平锁与AQS之间方法的关联之处，具体每一处核心方法的作用会在文章后面详细进行阐述。</p>
          <p><img src="https://p1.meituan.net/travelcube/b8b53a70984668bc68653efe9531573e78636.png"></p>
          <p>为了帮助大家理解ReentrantLock和AQS之间方法的交互过程，以非公平锁为例，我们将加锁和解锁的交互流程单独拎出来强调一下，以便于对后续内容的理解。</p>
          <p><img src="https://p1.meituan.net/travelcube/7aadb272069d871bdee8bf3a218eed8136919.png"></p>
          <p>加锁：</p>
          <ul>
            <li>通过ReentrantLock的加锁方法Lock进行加锁操作。</li>
            <li>会调用到内部类Sync的Lock方法，由于Sync#lock是抽象方法，根据ReentrantLock初始化选择的公平锁和非公平锁，执行相关内部类的Lock方法，本质上都会执行AQS的Acquire方法。
            </li>
            <li>
              AQS的Acquire方法会执行tryAcquire方法，但是由于tryAcquire需要自定义同步器实现，因此执行了ReentrantLock中的tryAcquire方法，由于ReentrantLock是通过公平锁和非公平锁内部类实现的tryAcquire方法，因此会根据锁类型不同，执行不同的tryAcquire。
            </li>
            <li>tryAcquire是获取锁逻辑，获取失败后，会执行框架AQS的后续逻辑，跟ReentrantLock自定义同步器无关。</li>
          </ul>
          <p>解锁：</p>
          <ul>
            <li>通过ReentrantLock的解锁方法Unlock进行解锁。</li>
            <li>Unlock会调用内部类Sync的Release方法，该方法继承于AQS。</li>
            <li>Release中会调用tryRelease方法，tryRelease需要自定义同步器实现，tryRelease只在ReentrantLock中的Sync实现，因此可以看出，释放锁的过程，并不区分是否为公平锁。
            </li>
            <li>释放成功后，所有处理由AQS框架完成，与自定义同步器无关。</li>
          </ul>
          <p>通过上面的描述，大概可以总结出ReentrantLock加锁解锁时API层核心方法的映射关系。</p>
          <p><img src="https://p0.meituan.net/travelcube/f30c631c8ebbf820d3e8fcb6eee3c0ef18748.png"></p>
          <h2 id="2-3-通过ReentrantLock理解AQS"><a href="#2-3-通过ReentrantLock理解AQS" class="headerlink"
              title="2.3 通过ReentrantLock理解AQS"></a>2.3 通过ReentrantLock理解AQS</h2>
          <p>ReentrantLock中公平锁和非公平锁在底层是相同的，这里以非公平锁为例进行分析。</p>
          <p>在非公平锁中，有一段这样的代码：</p>
          <figure class="highlight java">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>
          <p>看一下这个Acquire是怎么写的：</p>
          <figure class="highlight java">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">    selfInterrupt();</span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>
          <p>再看一下tryAcquire方法：</p>
          <figure class="highlight plaintext">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line">protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>
          <p>
            可以看出，这里只是AQS的简单实现，具体获取锁的实现方法是由各自的公平锁和非公平锁单独实现的（以ReentrantLock为例）。如果该方法返回了True，则说明当前线程获取锁成功，就不用往后执行了；如果获取失败，就需要加入到等待队列中。下面会详细解释线程是何时以及怎样被加入进等待队列中的。
          </p>
          <h3 id="2-3-1-线程加入等待队列"><a href="#2-3-1-线程加入等待队列" class="headerlink" title="2.3.1 线程加入等待队列"></a>2.3.1 线程加入等待队列
          </h3>
          <h4 id="2-3-1-1-加入队列的时机"><a href="#2-3-1-1-加入队列的时机" class="headerlink" title="2.3.1.1 加入队列的时机"></a>2.3.1.1
            加入队列的时机</h4>
          <p>当执行Acquire(1)时，会通过tryAcquire获取锁。在这种情况下，如果获取锁失败，就会调用addWaiter加入到等待队列中去。</p>
          <h4 id="2-3-1-2-如何加入队列"><a href="#2-3-1-2-如何加入队列" class="headerlink" title="2.3.1.2 如何加入队列"></a>2.3.1.2 如何加入队列
          </h4>
          <p>获取锁失败后，会执行addWaiter(Node.EXCLUSIVE)加入等待队列，具体实现方法如下：</p>
          <figure class="highlight java">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">Node pred = tail;</span><br><span class="line"><span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">    node.prev = pred;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">    pred.next = node;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetTail</span><span class="params">(Node expect, Node update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, tailOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>
          <p>主要的流程如下：</p>
          <ul>
            <li>
              <p>通过当前的线程和锁模式新建一个节点。</p>
            </li>
            <li>
              <p>Pred指针指向尾节点Tail。</p>
            </li>
            <li>
              <p>将New中Node的Prev指针指向Pred。</p>
            </li>
            <li>
              <p>
                通过compareAndSetTail方法，完成尾节点的设置。这个方法主要是对tailOffset和Expect进行比较，如果tailOffset的Node和Expect的Node地址是相同的，那么设置Tail的值为Update的值。
              </p>
            </li>
          </ul>
          <figure class="highlight java">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    stateOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;state&quot;</span>));</span><br><span class="line">    headOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;head&quot;</span>));</span><br><span class="line">    tailOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;tail&quot;</span>));</span><br><span class="line">    waitStatusOffset = unsafe.objectFieldOffset(Node.class.getDeclaredField(<span class="string">&quot;waitStatus&quot;</span>));</span><br><span class="line">    nextOffset = unsafe.objectFieldOffset(Node.class.getDeclaredField(<span class="string">&quot;next&quot;</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123; </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>
          <p>
            从AQS的静态代码块可以看出，都是获取一个对象的属性相对于该对象在内存当中的偏移量，这样我们就可以根据这个偏移量在对象内存当中找到这个属性。tailOffset指的是tail对应的偏移量，所以这个时候会将new出来的Node置为当前队列的尾节点。同时，由于是双向链表，也需要将前一个节点指向尾节点。
          </p>
          <ul>
            <li>如果Pred指针是Null（说明等待队列中没有元素），或者当前Pred指针和Tail指向的位置不同（说明被别的线程已经修改），就需要看一下Enq的方法。</li>
          </ul>
          <figure class="highlight java">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>
          <p>
            如果没有被初始化，需要进行初始化一个头结点出来。但请注意，初始化的头结点并不是当前线程节点，而是调用了无参构造函数的节点。如果经历了初始化或者并发导致队列中有元素，则与之前的方法相同。其实，addWaiter就是一个在双端链表添加尾节点的操作，需要注意的是，双端链表的头结点是一个无参构造函数的头结点。
          </p>
          <p>总结一下，线程获取锁的时候，过程大体如下：</p>
          <ol>
            <li>
              <p>当没有线程获取到锁时，线程1获取锁成功。</p>
            </li>
            <li>
              <p>线程2申请锁，但是锁被线程1占有。</p>
            </li>
          </ol>
          <p><img src="https://p0.meituan.net/travelcube/e9e385c3c68f62c67c8d62ab0adb613921117.png"></p>
          <ol>
            <li>如果再有线程要获取锁，依次在队列中往后排队即可。</li>
          </ol>
          <p>
            回到上边的代码，hasQueuedPredecessors是公平锁加锁时判断等待队列中是否存在有效节点的方法。如果返回False，说明当前线程可以争取共享资源；如果返回True，说明队列中存在有效节点，当前线程必须加入到等待队列中。
          </p>
          <figure class="highlight java">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = tail; </span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp; ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>
          <p>看到这里，我们理解一下h !&#x3D; t &amp;&amp; ((s &#x3D; h.next) &#x3D;&#x3D; null || s.thread !&#x3D;
            Thread.currentThread());为什么要判断的头结点的下一个节点？第一个节点储存的数据是什么？</p>
          <blockquote>
            <p>双向链表中，第一个节点为虚节点，其实并不存储任何信息，只是占位。真正的第一个有数据的节点，是在第二个节点开始的。当h !&#x3D; t时： 如果(s &#x3D; h.next) &#x3D;&#x3D;
              null，等待队列正在有线程进行初始化，但只是进行到了Tail指向Head，没有将Head指向Tail，此时队列中有元素，需要返回True（这块具体见下边代码分析）。 如果(s &#x3D; h.next)
              !&#x3D; null，说明此时队列中至少有一个有效节点。如果此时s.thread &#x3D;&#x3D;
              Thread.currentThread()，说明等待队列的第一个有效节点中的线程与当前线程相同，那么当前线程是可以获取资源的；如果s.thread !&#x3D;
              Thread.currentThread()，说明等待队列的第一个有效节点线程与当前线程不同，当前线程必须加入进等待队列。</p>
          </blockquote>
          <figure class="highlight java">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; </span><br><span class="line">    <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">        tail = head;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.prev = t;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">        t.next = node;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>
          <p>节点入队不是原子操作，所以会出现短暂的head !&#x3D;
            tail，此时Tail指向最后一个节点，而且Tail指向Head。如果Head没有指向Tail（可见5、6、7行），这种情况下也需要将相关线程加入队列中。所以这块代码是为了解决极端情况下的并发问题。</p>
          <h4 id="2-3-1-3-等待队列中线程出队列时机"><a href="#2-3-1-3-等待队列中线程出队列时机" class="headerlink"
              title="2.3.1.3 等待队列中线程出队列时机"></a>2.3.1.3 等待队列中线程出队列时机</h4>
          <p>回到最初的源码：</p>
          <figure class="highlight java">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">    selfInterrupt();</span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>
          <p>
            上文解释了addWaiter方法，这个方法其实就是把对应的线程以Node的数据结构形式加入到双端队列里，返回的是一个包含该线程的Node。而这个Node会作为参数，进入到acquireQueued方法中。acquireQueued方法可以对排队中的线程进行“获锁”操作。
          </p>
          <p>总的来说，一个线程获取锁失败了，被放入等待队列，acquireQueued会把放入队列中的线程不断去获取锁，直到获取成功或者不再需要获取（中断）。</p>
          <p>下面我们从“何时出队列？”和“如何出队列？”两个方向来分析一下acquireQueued源码：</p>
          <figure class="highlight java">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">        <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">        setHead(node);</span><br><span class="line">        p.next = <span class="keyword">null</span>; </span><br><span class="line">        failed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> interrupted;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">        interrupted = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (failed)</span><br><span class="line">    cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>
          <p>注：setHead方法是把当前节点置为虚节点，但并没有修改waitStatus，因为它是一直需要用的数据。</p>
          <figure class="highlight java">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    head = node;</span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line">    node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line">    &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>
          <p>parkAndCheckInterrupt主要用于挂起当前线程，阻塞调用栈，返回当前线程的中断状态。</p>
          <figure class="highlight java">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>
          <p>上述方法的流程图如下：</p>
          <p><img src="https://p0.meituan.net/travelcube/c124b76dcbefb9bdc778458064703d1135485.png"></p>
          <p>
            从上图可以看出，跳出当前循环的条件是当“前置节点是头结点，且当前线程获取锁成功”。为了防止因死循环导致CPU资源被浪费，我们会判断前置节点的状态来决定是否要将当前线程挂起，具体挂起流程用流程图表示如下（shouldParkAfterFailedAcquire流程）：
          </p>
          <p><img src="https://p0.meituan.net/travelcube/9af16e2481ad85f38ca322a225ae737535740.png"></p>
          <p>从队列中释放节点的疑虑打消了，那么又有新问题了：</p>
          <ul>
            <li>
              <p>shouldParkAfterFailedAcquire中取消节点是怎么生成的呢？什么时候会把一个节点的waitStatus设置为-1？</p>
            </li>
            <li>
              <p>是在什么时间释放节点通知到被挂起的线程呢？</p>
            </li>
          </ul>
          <h3 id="2-3-2-CANCELLED状态节点生成"><a href="#2-3-2-CANCELLED状态节点生成" class="headerlink"
              title="2.3.2 CANCELLED状态节点生成"></a>2.3.2 CANCELLED状态节点生成</h3>
          <p>acquireQueued方法中的Finally代码：</p>
          <figure class="highlight java">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">    <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">        ...</span><br><span class="line">        failed = <span class="keyword">false</span>;</span><br><span class="line">                ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (failed)</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>
          <p>通过cancelAcquire方法，将Node的状态标记为CANCELLED。接下来，我们逐行来分析这个方法的原理：</p>
          <figure class="highlight java">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">    node.prev = pred = pred.prev;</span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp; ((ws = pred.waitStatus) == Node.SIGNAL || (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">        <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">            compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line">        node.next = node; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>
          <p>当前的流程：</p>
          <ul>
            <li>
              <p>获取当前节点的前驱节点，如果前驱节点的状态是CANCELLED，那就一直往前遍历，找到第一个waitStatus &lt;&#x3D;
                0的节点，将找到的Pred节点和当前Node关联，将当前Node设置为CANCELLED。</p>
            </li>
            <li>
              <p>根据当前节点的位置，考虑以下三种情况：</p>
            </li>
          </ul>
          <p>(1) 当前节点是尾节点。</p>
          <p>(2) 当前节点是Head的后继节点。</p>
          <p>(3) 当前节点不是Head的后继节点，也不是尾节点。</p>
          <p>根据上述第二条，我们来分析每一种情况的流程。</p>
          <p>当前节点是尾节点。</p>
          <p><img src="https://p1.meituan.net/travelcube/b845211ced57561c24f79d56194949e822049.png"></p>
          <p>当前节点是Head的后继节点。</p>
          <p><img src="https://p1.meituan.net/travelcube/ab89bfec875846e5028a4f8fead32b7117975.png"></p>
          <p>当前节点不是Head的后继节点，也不是尾节点。</p>
          <p><img src="https://p0.meituan.net/travelcube/45d0d9e4a6897eddadc4397cf53d6cd522452.png"></p>
          <p>通过上面的流程，我们对于CANCELLED节点状态的产生和变化已经有了大致的了解，但是为什么所有的变化都是对Next指针进行了操作，而没有对Prev指针进行操作呢？什么情况下会对Prev指针进行操作？</p>
          <blockquote>
            <p>
              执行cancelAcquire的时候，当前节点的前置节点可能已经从队列中出去了（已经执行过Try代码块中的shouldParkAfterFailedAcquire方法了），如果此时修改Prev指针，有可能会导致Prev指向另一个已经移除队列的Node，因此这块变化Prev指针不安全。
              shouldParkAfterFailedAcquire方法中，会执行下面的代码，其实就是在处理Prev指针。shouldParkAfterFailedAcquire是获取锁失败的情况下才会执行，进入该方法后，说明共享资源已被获取，当前节点之前的节点都不会出现变化，因此这个时候变更Prev指针比较安全。
            </p>
            <figure class="highlight plaintext">
              <table>
                <tr>
                  <td class="gutter">
                    <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                  </td>
                  <td class="code">
                    <pre><span class="line">do &#123;</span><br><span class="line">node.prev = pred = pred.prev;</span><br><span class="line">&#125; while (pred.waitStatus &gt; 0);</span><br></pre>
                  </td>
                </tr>
              </table>
            </figure>
          </blockquote>
          <h3 id="2-3-3-如何解锁"><a href="#2-3-3-如何解锁" class="headerlink" title="2.3.3 如何解锁"></a>2.3.3 如何解锁</h3>
          <p>我们已经剖析了加锁过程中的基本流程，接下来再对解锁的基本流程进行分析。由于ReentrantLock在解锁的时候，并不区分公平锁和非公平锁，所以我们直接看解锁的源码：</p>
          <figure class="highlight java">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>
          <p>可以看到，本质释放锁的地方，是通过框架来完成的。</p>
          <figure class="highlight java">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">        unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>
          <p>在ReentrantLock里面的公平锁和非公平锁的父类Sync定义了可重入锁的释放锁机制。</p>
          <figure class="highlight java">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    free = <span class="keyword">true</span>;</span><br><span class="line">    setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>
          <p>我们来解释下述源码：</p>
          <figure class="highlight java">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>
          <p>这里的判断条件为什么是h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0？</p>
          <blockquote>
            <p>h &#x3D;&#x3D; null Head还没初始化。初始情况下，head &#x3D;&#x3D;
              null，第一个节点入队，Head会被初始化一个虚拟节点。所以说，这里如果还没来得及入队，就会出现head &#x3D;&#x3D; null 的情况。</p>
            <p>h !&#x3D; null &amp;&amp; waitStatus &#x3D;&#x3D; 0 表明后继节点对应的线程仍在运行中，不需要唤醒。</p>
            <p>h !&#x3D; null &amp;&amp; waitStatus &lt; 0 表明后继节点可能被阻塞了，需要唤醒。</p>
          </blockquote>
          <p>再看一下unparkSuccessor方法：</p>
          <figure class="highlight java">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">    compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    s = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">    <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">    s = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">    LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>
          <p>为什么要从后往前找第一个非Cancelled的节点呢？原因如下。</p>
          <p>之前的addWaiter方法：</p>
          <figure class="highlight java">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>
          <p>我们从这里可以看到，节点入队并不是原子操作，也就是说，node.prev &#x3D; pred; compareAndSetTail(pred, node)
            这两个地方可以看作Tail入队的原子操作，但是此时pred.next &#x3D;
            node;还没执行，如果这个时候执行了unparkSuccessor方法，就没办法从前往后找了，所以需要从后往前找。还有一点原因，在产生CANCELLED状态节点的时候，先断开的是Next指针，Prev指针并未断开，因此也是必须要从后往前遍历才能够遍历完全部的Node。
          </p>
          <p>
            综上所述，如果是从前往后找，由于极端情况下入队的非原子操作和CANCELLED节点产生过程中断开Next指针的操作，可能会导致无法遍历所有的节点。所以，唤醒对应的线程后，对应的线程就会继续往下执行。继续执行acquireQueued方法以后，中断如何处理？
          </p>
          <h3 id="2-3-4-中断恢复后的执行流程"><a href="#2-3-4-中断恢复后的执行流程" class="headerlink" title="2.3.4 中断恢复后的执行流程"></a>2.3.4
            中断恢复后的执行流程</h3>
          <p>唤醒后，会执行return Thread.interrupted();，这个函数返回的是当前执行线程的中断状态，并清除。</p>
          <figure class="highlight java">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>
          <p>
            再回到acquireQueued代码，当parkAndCheckInterrupt返回True或者False的时候，interrupted的值不同，但都会执行下次循环。如果这个时候获取锁成功，就会把当前interrupted返回。
          </p>
          <figure class="highlight java">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">        <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">            setHead(node);</span><br><span class="line">            p.next = <span class="keyword">null</span>; </span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> interrupted;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">        interrupted = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (failed)</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>
          <p>如果acquireQueued为True，就会执行selfInterrupt方法。</p>
          <figure class="highlight java">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>
          <p>该方法其实是为了中断线程。但为什么获取了锁以后还要中断线程呢？这部分属于Java提供的协作式中断知识内容，感兴趣同学可以查阅一下。这里简单介绍一下：</p>
          <ol>
            <li>
              <p>
                当中断线程被唤醒时，并不知道被唤醒的原因，可能是当前线程在等待中被中断，也可能是释放了锁以后被唤醒。因此我们通过Thread.interrupted()方法检查中断标记（该方法返回了当前线程的中断状态，并将当前线程的中断标识设置为False），并记录下来，如果发现该线程被中断过，就再中断一次。
              </p>
            </li>
            <li>
              <p>线程在等待资源的过程中被唤醒，唤醒后还是会不断地去尝试获取锁，直到抢到锁为止。也就是说，在整个流程中，并不响应中断，只是记录中断记录。最后抢到锁返回了，那么如果被中断过的话，就需要补充一次中断。</p>
            </li>
          </ol>
          <p>这里的处理方式主要是运用线程池中基本运作单元Worder中的runWorker，通过Thread.interrupted()进行额外的判断处理，感兴趣的同学可以看下ThreadPoolExecutor源码。</p>
          <h3 id="2-3-5-小结"><a href="#2-3-5-小结" class="headerlink" title="2.3.5 小结"></a>2.3.5 小结</h3>
          <p>我们在1.3小节中提出了一些问题，现在来回答一下。</p>
          <blockquote>
            <p>Q：某个线程获取锁失败的后续流程是什么呢？</p>
            <p>A：存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。</p>
            <p>Q：既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？</p>
            <p>A：是CLH变体的FIFO双端队列。</p>
            <p>Q：处于排队等候机制中的线程，什么时候可以有机会获取锁呢？</p>
            <p>A：可以详细看下2.3.1.3小节。</p>
            <p>Q：如果处于排队等候机制中的线程一直无法获取锁，需要一直等待么？还是有别的策略来解决这一问题？</p>
            <p>A：线程所在节点的状态会变成取消状态，取消状态的节点会从队列中释放，具体可见2.3.2小节。</p>
            <p>Q：Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？</p>
            <p>A：AQS的Acquire会调用tryAcquire方法，tryAcquire由各个自定义同步器实现，通过tryAcquire完成加锁过程。</p>
          </blockquote>
          <h2 id="3-AQS应用"><a href="#3-AQS应用" class="headerlink" title="3 AQS应用"></a>3 AQS应用</h2>
          <h3 id="3-1-ReentrantLock的可重入应用"><a href="#3-1-ReentrantLock的可重入应用" class="headerlink"
              title="3.1 ReentrantLock的可重入应用"></a>3.1 ReentrantLock的可重入应用</h3>
          <p>
            ReentrantLock的可重入性是AQS很好的应用之一，在了解完上述知识点以后，我们很容易得知ReentrantLock实现可重入的方法。在ReentrantLock里面，不管是公平锁还是非公平锁，都有一段逻辑。
          </p>
          <p>公平锁：</p>
          <figure class="highlight java">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">    <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">    <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>
          <p>非公平锁：</p>
          <figure class="highlight java">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires))&#123;</span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line"><span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line"><span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) </span><br><span class="line"><span class="function">t   hrow new <span class="title">Error</span><span class="params">(<span class="string">&quot;Maximum lock count exceeded&quot;</span>)</span></span>;</span><br><span class="line">setState(nextc);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>
          <p>从上面这两段都可以看到，有一个同步状态State来控制整体可重入的情况。State是Volatile修饰的，用于保证一定的可见性和有序性。</p>
          <figure class="highlight java">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>
          <p>接下来看State这个字段主要的过程：</p>
          <ol>
            <li>
              <p>State初始化的时候为0，表示没有任何线程持有锁。</p>
            </li>
            <li>
              <p>当有线程持有该锁时，值就会在原来的基础上+1，同一个线程多次获得锁是，就会多次+1，这里就是可重入的概念。</p>
            </li>
            <li>
              <p>解锁也是对这个字段-1，一直到0，此线程对锁释放。</p>
            </li>
          </ol>
          <h3 id="3-2-JUC中的应用场景"><a href="#3-2-JUC中的应用场景" class="headerlink" title="3.2 JUC中的应用场景"></a>3.2 JUC中的应用场景
          </h3>
          <p>除了上边ReentrantLock的可重入性的应用，AQS作为并发编程的框架，为很多其他同步工具提供了良好的解决方案。下面列出了JUC中的几种同步工具，大体介绍一下AQS的应用场景：</p>
          <table>
            <thead>
              <tr>
                <th>同步工具</th>
                <th>同步工具与AQS的关联</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>ReentrantLock</td>
                <td>使用AQS保存锁重复持有的次数。当一个线程获取锁时，ReentrantLock记录当前获得锁的线程标识，用于检测是否重复获取，以及错误线程试图解锁操作时异常情况的处理。</td>
              </tr>
              <tr>
                <td>Semaphore</td>
                <td>使用AQS同步状态来保存信号量的当前计数。tryRelease会增加计数，acquireShared会减少计数。</td>
              </tr>
              <tr>
                <td>CountDownLatch</td>
                <td>使用AQS同步状态来表示计数。计数为0时，所有的Acquire操作（CountDownLatch的await方法）才可以通过。</td>
              </tr>
              <tr>
                <td>ReentrantReadWriteLock</td>
                <td>使用AQS同步状态中的16位保存写锁持有的次数，剩下的16位用于保存读锁的持有次数。</td>
              </tr>
              <tr>
                <td>ThreadPoolExecutor</td>
                <td>Worker利用AQS同步状态实现对独占线程变量的设置（tryAcquire和tryRelease）。</td>
              </tr>
            </tbody>
          </table>
          <h3 id="3-3-自定义同步工具"><a href="#3-3-自定义同步工具" class="headerlink" title="3.3 自定义同步工具"></a>3.3 自定义同步工具</h3>
          <p>了解AQS基本原理以后，按照上面所说的AQS知识点，自己实现一个同步工具。</p>
          <figure class="highlight java">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeeLock</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span> <span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> compareAndSetState(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span> <span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>
          <p>通过我们自己定义的Lock完成一定的同步功能。</p>
          <figure class="highlight java">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeeMain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> LeeLock leeLock = <span class="keyword">new</span> LeeLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    leeLock.lock();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    leeLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>
          <p>上述代码每次运行结果都会是20000。通过简单的几行代码就能实现同步功能，这就是AQS的强大之处。</p>
          <h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>
          <p>
            我们日常开发中使用并发的场景太多，但是对并发内部的基本框架原理了解的人却不多。由于篇幅原因，本文仅介绍了可重入锁ReentrantLock的原理和AQS原理，希望能够成为大家了解AQS和ReentrantLock等同步器的“敲门砖”。
          </p>
          <h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2>
          <ul>
            <li>Lea D. The java. util. concurrent synchronizer framework[J]. Science of Computer Programming, 2005,
              58(3): 293-309.</li>
            <li>《Java并发编程实战》</li>
            <li><a target="_blank" rel="noopener"
                href="https://tech.meituan.com/2018/11/15/java-lock.html">不可不说的Java“锁”事</a></li>
            <li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f584799f1c77">一张图读懂公平锁与非公平锁</a></li>
            <li><a target="_blank" rel="noopener"
                href="https://blog.csdn.net/qq_35190492/article/details/104943579">公平锁和非公平锁的区别</a></li>
          </ul>
          <link rel="stylesheet" href="/css/markmap.css" type="text/css">
        </div>
        <div class="article-footer">
          <blockquote class="mt-2x">
            <ul class="post-copyright list-unstyled">
              <li class="post-copyright-link hidden-xs"><strong>本文链接：</strong> <a
                  href="https://blog.beyhub.com/post/%E4%BB%8Ereentrantlock%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9C%8Baqs%E7%9A%84%E5%8E%9F%E7%90%86/"
                  title="从ReentrantLock的实现看AQS的原理" target="_blank"
                  rel="external">https://blog.beyhub.com/post/从reentrantlock的实现看aqs的原理/</a></li>
              <li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a
                  href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0
                  CN协议</a> 许可协议。转载请注明出处！</li>
            </ul>
          </blockquote>
          <hr>
        </div>
      </article>
      <section id="comments">
        <div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener"
              href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div>
      </section>
    </div>
    <nav class="bar bar-footer clearfix" data-stick-bottom>
      <div class="bar-inner">
        <ul class="pager pull-left">
          <li class="prev"><a href="/post/java-sdk%E4%B8%AD%E7%9A%84spi%E6%9C%BA%E5%88%B6/" title="Java SDK中的SPI机制"><i
                class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a></li>
          <li class="next"><a
              href="/post/hashmap%E3%80%81hashtable%E7%AD%89map%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%8E%9F%E7%90%86/"
              title="HashMap、Hashtable等Map接口的实现和原理"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right"
                aria-hidden="true"></i></a></li>
          <li class="toggle-toc"><a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc"
              aria-expanded="false" title="文章目录" role="button"><span>[&nbsp;</span><span>文章目录</span> <i
                class="text-collapsed icon icon-anchor"></i> <i class="text-in icon icon-close"></i> <span>]</span></a>
          </li>
        </ul>
        <div class="bar-right"></div>
      </div>
    </nav>
  </main>
  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
    <ul class="social-links">
      <li><a href="https://github.com/lesterlaucn" target="_blank" title="Github" data-toggle="tooltip"
          data-placement="top"><i class="icon icon-github"></i></a></li>
      <li><a href="http://weibo.com/lyc90" target="_blank" title="Weibo" data-toggle="tooltip" data-placement="top"><i
            class="icon icon-weibo"></i></a></li>
      <li><a href="https://twitter.com/lesterlaucn" target="_blank" title="Twitter" data-toggle="tooltip"
          data-placement="top"><i class="icon icon-twitter"></i></a></li>
      <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i
            class="icon icon-rss"></i></a></li>
    </ul>
    <div class="copyright">&copy; 2022 刘远程 (Lester Lau)<div class="publishby">Theme by <a
          href="https://github.com/cofess" target="_blank">me </a>base on <a
          href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.</div>
    </div>
  </footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')</script>
  <script src="/js/plugin.min.js"></script>
  <script src="/js/application.js"></script>
  <script>window.INSIGHT_CONFIG = { TRANSLATION: { POSTS: "文章", PAGES: "页面", CATEGORIES: "分类", TAGS: "标签", UNTITLED: "(未命名)" }, ROOT_URL: "/", CONTENT_URL: "/content.json" }</script>
  <script src="/js/insight.js"></script>
  <script
    defer>var disqus_config = function () { this.page.url = "https://blog.beyhub.com/post/%E4%BB%8Ereentrantlock%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9C%8Baqs%E7%9A%84%E5%8E%9F%E7%90%86/", this.page.identifier = "2021/从ReentrantLock的实现看AQS的原理" }; !function () { var t = document, e = t.createElement("script"); e.src = "//cai-ju-dong-li.disqus.com/embed.js", e.setAttribute("data-timestamp", +new Date), (t.head || t.body).appendChild(e) }()</script>
  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script>
  <script>$(document).ready(function () {
      let imgs = $('article img');
      imgs.attr('src', '/' + imgs.attr('src'))
    }
  //利用 FancyBox 实现点击图片放大
  $(document).ready(function () {
      $('article img').not('[hidden]').not('.panel-body img').each(function () {
        var $image = $(this);
        var imageCaption = $image.attr('alt');
        var $imageWrapLink = $image.parent('a');
        if ($imageWrapLink.length < 1) {
          var src = this.getAttribute('src');
          var idx = src.lastIndexOf('?');
          if (idx != -1) {
            src = src.substring(0, idx);
          }
          $imageWrapLink = $image.wrap('<a href="' + src + '"></a>').parent('a');
        }
        $imageWrapLink.attr('data-fancybox', 'images');
        if (imageCaption) {
          $imageWrapLink.attr('data-caption', imageCaption);
        }
      });
      $().fancybox({
        selector: '[data-fancybox="images"]',
        hash: false,
        loop: false,
      });
    });</script>
  <script src="https://cdn.jsdelivr.net/npm/d3@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/markmap-lib@0.7.4/dist/browser/view.min.js"></script>
  <script>const mindmaps = document.querySelectorAll(".markmap-svg"); for (const a of mindmaps) markmap.markmap(a, JSON.parse(a.innerHTML))</script>
</body>

</html>