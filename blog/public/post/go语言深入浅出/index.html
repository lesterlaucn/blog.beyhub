<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="renderer" content="webkit"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="theme-color" content="#000000"><meta http-equiv="window-target" content="_top"><title>Go语言深入浅出 | 采菊东篱</title><meta name="description" content="Go的语法接近C语言，但对于变量的声明有所不同。Go支持垃圾回收功能。Go的并行计算模型是以东尼·霍尔的通信顺序进程（CSP）为基础，采取类似模型的其他语言包括Occam和Limbo[3]，Go也具有这个模型的特征，比如通道传输。通过goroutine和通道等并行构造可以建造线程池和管道等[8]。在1.8版本中开放插件（Plugin）的支持，这意味着现在能从Go中动态加载部分函数。   与C++相"><meta property="og:type" content="article"><meta property="og:title" content="Go语言深入浅出"><meta property="og:url" content="https://blog.beyhub.com/post/go%E8%AF%AD%E8%A8%80%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/index.html"><meta property="og:site_name" content="采菊东篱"><meta property="og:description" content="Go的语法接近C语言，但对于变量的声明有所不同。Go支持垃圾回收功能。Go的并行计算模型是以东尼·霍尔的通信顺序进程（CSP）为基础，采取类似模型的其他语言包括Occam和Limbo[3]，Go也具有这个模型的特征，比如通道传输。通过goroutine和通道等并行构造可以建造线程池和管道等[8]。在1.8版本中开放插件（Plugin）的支持，这意味着现在能从Go中动态加载部分函数。   与C++相"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog.beyhub.com/post/go%E8%AF%AD%E8%A8%80%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/images/Golang.png"><meta property="article:published_time" content="2022-04-13T01:15:21.000Z"><meta property="article:modified_time" content="2022-04-20T01:19:14.737Z"><meta property="article:author" content="刘远程 (Lester Lau)"><meta property="article:tag" content="Go"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://blog.beyhub.com/post/go%E8%AF%AD%E8%A8%80%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/images/Golang.png"><link rel="canonical" href="https://blog.beyhub.com/post/go%E8%AF%AD%E8%A8%80%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/index.html"><link rel="alternate" href="/atom.xml" title="采菊东篱" type="application/atom+xml"><link rel="icon" href="/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css" rel="stylesheet"><meta name="generator" content="Hexo 5.4.0"></head><body class="main-center theme-purple" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="slimContent"><div class="navbar-header"><div class="profile-block text-center"><a id="avatar" href="/about/"><img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200"></a><h2 id="name" class="hidden-xs hidden-sm">Lester Lau</h2><h3 id="title" class="hidden-xs hidden-sm hidden-md" style="margin-top:13px;margin-bottom:6px">采菊东篱下，悠然见南山</h3><small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> NanJing, China</small></div><div class="search" id="search-form-wrap"><form class="search-form sidebar-form"><div class="input-group"><input type="text" class="search-form-input form-control" placeholder="搜索"> <span class="input-group-btn"><button type="submit" class="search-form-submit btn btn-flat" onclick="return!1"><i class="icon icon-search"></i></button></span></div></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech> <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div></div><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button></div><nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation"><ul class="nav navbar-nav main-nav menu-highlight"><li class="menu-item menu-item-home"><a href="/."><i class="icon icon-home-fill"></i> <span class="menu-title">首页</span></a></li><li class="menu-item menu-item-archives"><a href="/archives"><i class="icon icon-archives-fill"></i> <span class="menu-title">归档</span></a></li><li class="menu-item menu-item-categories"><a href="/categories"><i class="icon icon-folder"></i> <span class="menu-title">文章分类</span></a></li><li class="menu-item menu-item-tags"><a href="/tags"><i class="icon icon-tags"></i> <span class="menu-title">标签</span></a></li><li class="menu-item menu-item-links"><a href="/links"><i class="icon icon-friendship"></i> <span class="menu-title">常用网址</span></a></li><li class="menu-item menu-item-about"><a href="/about"><i class="icon icon-cup-fill"></i> <span class="menu-title">关于我</span></a></li></ul><ul class="social-links"><li><a href="https://github.com/lesterlaucn" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="http://weibo.com/lyc90" target="_blank" title="Weibo" data-toggle="tooltip" data-placement="top"><i class="icon icon-weibo"></i></a></li><li><a href="https://twitter.com/lesterlaucn" target="_blank" title="Twitter" data-toggle="tooltip" data-placement="top"><i class="icon icon-twitter"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul></nav></div></header><aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><div class="widget"><h3 class="widget-title">公告</h3><div class="widget-body"><div id="board"><div class="content"><p>Those who cannot remember the past are condemned to repeat it.<br>—George Santayana.</p></div></div></div></div><div class="widget"><h3 class="widget-title">标签云</h3><div class="widget-body tagcloud"><a href="/tags/BPMN/" style="font-size:13px">BPMN</a> <a href="/tags/Go/" style="font-size:13px">Go</a> <a href="/tags/JVM/" style="font-size:13px">JVM</a> <a href="/tags/Java/" style="font-size:13.67px">Java</a> <a href="/tags/K3s/" style="font-size:13px">K3s</a> <a href="/tags/Kubernetes/" style="font-size:13px">Kubernetes</a> <a href="/tags/MySQL/" style="font-size:14px">MySQL</a> <a href="/tags/Proxy/" style="font-size:13px">Proxy</a> <a href="/tags/Spring/" style="font-size:13px">Spring</a> <a href="/tags/Traefik/" style="font-size:13px">Traefik</a> <a href="/tags/java/" style="font-size:13px">java</a> <a href="/tags/zookeeper/" style="font-size:13px">zookeeper</a> <a href="/tags/%E4%BA%8C%E5%88%86%E6%B3%95/" style="font-size:13px">二分法</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size:13.33px">分布式</a> <a href="/tags/%E5%88%86%E6%B2%BB/" style="font-size:13px">分治</a> <a href="/tags/%E5%8E%9F%E7%90%86/" style="font-size:13.33px">原理</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/" style="font-size:13px">学习方法</a> <a href="/tags/%E5%B7%A5%E4%BD%9C%E6%B5%81/" style="font-size:13px">工作流</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size:13px">数据库</a> <a href="/tags/%E9%94%81/" style="font-size:13.67px">锁</a> <a href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/" style="font-size:13px">高并发</a></div></div><div class="widget"><h3 class="widget-title">分类</h3><div class="widget-body"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/">个人成长</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/">云原生</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81/">源码</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span class="category-list-count">1</span></li></ul></div></div><div class="widget"><h3 class="widget-title">最新文章</h3><div class="widget-body"><ul class="recent-post-list list-unstyled no-thumbnail"><li><div class="item-inner"><p class="item-title"><a href="/post/go%E8%AF%AD%E8%A8%80%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/" class="title">Go语言深入浅出</a></p><p class="item-date"><time datetime="2022-04-13T01:15:21.000Z" itemprop="datePublished">2022-04-13</time></p></div></li><li><div class="item-inner"><p class="item-title"><a href="/post/kubernetes%E5%AE%9E%E7%8E%B0traefik%E4%BB%A3%E7%90%86mysql%E6%B5%81%E9%87%8F/" class="title">Kubernetes实现Traefik代理MySQL流量</a></p><p class="item-date"><time datetime="2022-04-12T07:44:46.000Z" itemprop="datePublished">2022-04-12</time></p></div></li><li><div class="item-inner"><p class="item-title"><a href="/post/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95%E4%B8%8E%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95/" class="title">关系型数据库的单列索引与联合索引</a></p><p class="item-date"><time datetime="2021-08-21T19:51:02.000Z" itemprop="datePublished">2021-08-22</time></p></div></li><li><div class="item-inner"><p class="item-title"><a href="/post/%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/" class="title">二分法查找深入解析</a></p><p class="item-date"><time datetime="2021-08-12T02:45:18.000Z" itemprop="datePublished">2021-08-12</time></p></div></li><li><div class="item-inner"><p class="item-title"><a href="/post/java-sdk%E4%B8%AD%E7%9A%84spi%E6%9C%BA%E5%88%B6/" class="title">Java SDK中的SPI机制</a></p><p class="item-date"><time datetime="2021-04-12T15:12:43.000Z" itemprop="datePublished">2021-04-12</time></p></div></li></ul></div></div></div></aside><aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><nav id="toc" class="article-toc"><h3 class="toc-title">文章目录</h3><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">背景知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%92%8CGo%E7%9A%84%E8%AF%AD%E6%B3%95%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.</span> <span class="toc-text">Java和Go的语法区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A"><span class="toc-number">1.2.</span> <span class="toc-text">名词解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">编译器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C"><span class="toc-number">3.1.</span> <span class="toc-text">命令行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#go-mod"><span class="toc-number">3.1.1.</span> <span class="toc-text">go mod</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#go-build"><span class="toc-number">3.1.2.</span> <span class="toc-text">go build</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#go-install"><span class="toc-number">3.1.3.</span> <span class="toc-text">go install</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#go-tool"><span class="toc-number">3.1.4.</span> <span class="toc-text">go tool</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-number">3.2.</span> <span class="toc-text">变量声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.1.</span> <span class="toc-text">值类型和引用类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%EF%BC%9A%E6%95%B0%E7%BB%84"><span class="toc-number">3.3.2.</span> <span class="toc-text">值类型：数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%9A%E5%88%87%E7%89%87"><span class="toc-number">3.3.3.</span> <span class="toc-text">引用类型：切片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%9AInterface"><span class="toc-number">3.3.4.</span> <span class="toc-text">引用类型：Interface</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%9Amap%E5%AD%97%E5%85%B8"><span class="toc-number">3.3.5.</span> <span class="toc-text">引用类型：map字典</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%9A%E9%80%9A%E9%81%93channel"><span class="toc-number">3.3.6.</span> <span class="toc-text">引用类型：通道channel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%EF%BC%9A%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.7.</span> <span class="toc-text">值类型：函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%9A%E6%8C%87%E9%92%88"><span class="toc-number">3.3.8.</span> <span class="toc-text">引用类型：指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%EF%BC%9Aint%E7%B3%BB%E5%88%97"><span class="toc-number">3.3.9.</span> <span class="toc-text">值类型：int系列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%EF%BC%9Afloat%E7%B3%BB%E5%88%97"><span class="toc-number">3.3.10.</span> <span class="toc-text">值类型：float系列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%EF%BC%9A%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">3.3.11.</span> <span class="toc-text">值类型：结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%EF%BC%9A%E5%A4%8D%E6%95%B0"><span class="toc-number">3.3.12.</span> <span class="toc-text">值类型：复数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.4.</span> <span class="toc-text">控制语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#defer"><span class="toc-number">3.4.1.</span> <span class="toc-text">defer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#switch"><span class="toc-number">3.4.2.</span> <span class="toc-text">switch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#select"><span class="toc-number">3.4.3.</span> <span class="toc-text">select</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#if"><span class="toc-number">3.4.4.</span> <span class="toc-text">if</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for"><span class="toc-number">3.4.5.</span> <span class="toc-text">for</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">3.5.</span> <span class="toc-text">异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#error"><span class="toc-number">3.5.1.</span> <span class="toc-text">error</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#panic"><span class="toc-number">3.5.2.</span> <span class="toc-text">panic</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#recover"><span class="toc-number">3.5.3.</span> <span class="toc-text">recover</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E7%9A%84%E6%96%B9%E6%B3%95%E9%9B%86"><span class="toc-number">3.6.</span> <span class="toc-text">组合的方法集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CGO"><span class="toc-number">3.7.</span> <span class="toc-text">CGO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5"><span class="toc-number">4.1.</span> <span class="toc-text">嵌入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E5%90%88"><span class="toc-number">4.2.</span> <span class="toc-text">聚合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SDK%E6%A0%B8%E5%BF%83%E5%8C%85"><span class="toc-number">5.</span> <span class="toc-text">SDK核心包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fmt"><span class="toc-number">5.1.</span> <span class="toc-text">fmt</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#v-v-v%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.1.1.</span> <span class="toc-text">%v %+v %#v的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#math"><span class="toc-number">5.2.</span> <span class="toc-text">math</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#runtime"><span class="toc-number">5.3.</span> <span class="toc-text">runtime</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#runtime-x2F-pprof-%EF%BC%88net-x2F-http-x2F-pprof%EF%BC%89"><span class="toc-number">5.3.1.</span> <span class="toc-text">runtime&#x2F;pprof （net&#x2F;http&#x2F;pprof）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bytes"><span class="toc-number">5.4.</span> <span class="toc-text">bytes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strings"><span class="toc-number">5.5.</span> <span class="toc-text">strings</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#utf8"><span class="toc-number">5.6.</span> <span class="toc-text">utf8</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strconv"><span class="toc-number">5.7.</span> <span class="toc-text">strconv</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unsafe"><span class="toc-number">5.8.</span> <span class="toc-text">unsafe</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#atomic"><span class="toc-number">5.9.</span> <span class="toc-text">atomic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sync"><span class="toc-number">5.10.</span> <span class="toc-text">sync</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81-sync-Mutex%EF%BC%88%E5%85%A8%E5%B1%80%E9%94%81%EF%BC%89"><span class="toc-number">5.10.1.</span> <span class="toc-text">互斥锁 sync.Mutex（全局锁）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81-sync-RWMutex"><span class="toc-number">5.10.2.</span> <span class="toc-text">读写锁 sync.RWMutex</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sync-WaitGroup"><span class="toc-number">5.10.3.</span> <span class="toc-text">sync.WaitGroup</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sync-Once-Do"><span class="toc-number">5.10.4.</span> <span class="toc-text">sync.Once.Do()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sync-Map"><span class="toc-number">5.10.5.</span> <span class="toc-text">sync.Map</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#testing"><span class="toc-number">5.11.</span> <span class="toc-text">testing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reflect"><span class="toc-number">5.12.</span> <span class="toc-text">reflect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#context"><span class="toc-number">5.13.</span> <span class="toc-text">context</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#os"><span class="toc-number">5.14.</span> <span class="toc-text">os</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#net"><span class="toc-number">5.15.</span> <span class="toc-text">net</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http"><span class="toc-number">5.16.</span> <span class="toc-text">http</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#encoding"><span class="toc-number">5.17.</span> <span class="toc-text">encoding</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#json"><span class="toc-number">5.18.</span> <span class="toc-text">json</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#time"><span class="toc-number">5.19.</span> <span class="toc-text">time</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84"><span class="toc-number">6.</span> <span class="toc-text">工程结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8E%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95"><span class="toc-number">6.1.</span> <span class="toc-text">环境变量与项目目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86"><span class="toc-number">6.2.</span> <span class="toc-text">源代码管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#WorkSpace"><span class="toc-number">6.2.1.</span> <span class="toc-text">WorkSpace</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Module"><span class="toc-number">6.2.2.</span> <span class="toc-text">Module</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A%E8%A7%84%E8%8C%83"><span class="toc-number">6.3.</span> <span class="toc-text">注释规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">6.4.</span> <span class="toc-text">命名规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95"><span class="toc-number">6.5.</span> <span class="toc-text">基准测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93"><span class="toc-number">7.</span> <span class="toc-text">第三方库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EOpenCV%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0GUI%E8%87%AA%E5%8A%A8%E5%8C%96%E5%BA%93"><span class="toc-number">7.1.</span> <span class="toc-text">基于OpenCV的跨平台GUI自动化库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Web%E6%A1%86%E6%9E%B6"><span class="toc-number">7.2.</span> <span class="toc-text">Web框架</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">8.</span> <span class="toc-text">常见问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">8.1.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-number">8.1.1.</span> <span class="toc-text">函数的参数传递是值传递还是引用传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E7%9A%84%E5%BB%B6%E6%97%B6%E7%BB%91%E5%AE%9A%E9%97%AE%E9%A2%98"><span class="toc-number">8.1.2.</span> <span class="toc-text">匿名函数的延时绑定问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%9C%89%E7%B1%BB%E5%90%97%EF%BC%9F"><span class="toc-number">8.1.3.</span> <span class="toc-text">Go语言中有类吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-1"><span class="toc-number">8.2.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E7%89%87%E7%9A%84%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99"><span class="toc-number">8.2.1.</span> <span class="toc-text">切片的扩容规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.2.2.</span> <span class="toc-text">什么是鸭子类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Is-Go-an-object-oriented-language"><span class="toc-number">8.2.3.</span> <span class="toc-text">Is Go an object-oriented language?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">9.</span> <span class="toc-text">参考资料</span></a></li></ol></nav></div></aside><main class="main" role="main"><div class="content"><article id="post-2022/Go语言深入浅出" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting"><div class="article-header"><h1 class="article-title" itemprop="name">Go语言深入浅出</h1><div class="article-meta"><span class="article-date"><i class="icon icon-calendar-check"></i> <a href="/post/go%E8%AF%AD%E8%A8%80%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/" class="article-date"><time datetime="2022-04-13T01:15:21.000Z" itemprop="datePublished">2022-04-13</time> </a></span><span class="article-category"><i class="icon icon-folder"></i> <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</a> </span><span class="article-tag"><i class="icon icon-tags"></i> <a class="article-tag-link-link" href="/tags/Go/" rel="tag">Go</a> </span><span class="post-comment"><i class="icon icon-comment"></i> <a href="/post/go%E8%AF%AD%E8%A8%80%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/#comments" class="article-comment-link">评论 </a></span><span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 3.3k(字)</span> <span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 13(分)</span></div></div><div class="article-entry marked-body" itemprop="articleBody"><p>Go的语法接近C语言，但对于变量的声明有所不同。Go支持垃圾回收功能。Go的并行计算模型是以东尼·霍尔的通信顺序进程（CSP）为基础，采取类似模型的其他语言包括Occam和Limbo[3]，Go也具有这个模型的特征，比如通道传输。通过goroutine和通道等并行构造可以建造线程池和管道等[8]。在1.8版本中开放插件（Plugin）的支持，这意味着现在能从Go中动态加载部分函数。</p><img src="images/Golang.png" alt="img" style="zoom:50%"><p>与C++相比，Go并不包括如枚举、异常处理、继承、泛型、断言、虚函数等功能，但增加了 切片(Slice) 型、并发、管道、垃圾回收功能、接口等特性的语言级支持[3]。Go 2.0版本将支持泛型[9]，对于断言的存在，则持负面态度，同时也为自己不提供类型继承来辩护。</p><p>不同于Java，Go原生提供了关联数组（也称为哈希表（Hashes）或字典（Dictionaries））。</p><span id="more"></span><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="Java和Go的语法区别"><a href="#Java和Go的语法区别" class="headerlink" title="Java和Go的语法区别"></a>Java和Go的语法区别</h3><ol><li>Go语言中函数是一等公民</li><li>不支持Overload重载</li><li>不支持@Override重写，因此math.Max(float64,float64) 不支持int</li></ol><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><table><thead><tr><th>名词</th><th>解释</th></tr></thead><tbody><tr><td>gc</td><td>Go compiler</td></tr><tr><td>GOGC</td><td>Garbage Collection</td></tr></tbody></table><h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><h4 id="go-mod"><a href="#go-mod" class="headerlink" title="go mod"></a>go mod</h4><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>go mod tidy</td><td></td></tr><tr><td>go mod proxy</td><td></td></tr></tbody></table><h4 id="go-build"><a href="#go-build" class="headerlink" title="go build"></a>go build</h4><h4 id="go-install"><a href="#go-install" class="headerlink" title="go install"></a>go install</h4><h4 id="go-tool"><a href="#go-tool" class="headerlink" title="go tool"></a>go tool</h4><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>go tool pprof</td><td></td></tr></tbody></table><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><ul><li><p>变量的作用域</p><blockquote><ol><li>花括号标识一个代码块，一般都存在作用域划分的作用（花括号内的局部变量互相屏蔽）</li><li>全局变量在代码块内部可以被覆盖声明，因此要避免重名（在开发规范中约定）</li></ol></blockquote></li><li><p>常量</p><blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MaxUint = ^<span class="keyword">uint</span>(<span class="number">0</span>) </span><br></pre></td></tr></table></figure></blockquote></li><li><p>变量</p><blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明多个</span></span><br><span class="line"><span class="keyword">var</span> maxCount,base,count <span class="keyword">int</span></span><br><span class="line"><span class="comment">// 短式声明（只能在函数内使用）</span></span><br><span class="line">v:=<span class="number">999</span></span><br><span class="line">s:=<span class="string">&quot;hello world!&quot;</span></span><br><span class="line"><span class="comment">// 多赋值</span></span><br><span class="line">base, count,s := <span class="number">1</span>, <span class="number">0</span>,<span class="string">&quot;hello world!&quot;</span></span><br></pre></td></tr></table></figure></blockquote></li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h4><ul><li><p>值类型的特点是</p><blockquote><ol><li>变量直接存储值，内存通常在<strong>栈中分配</strong></li><li>使用内置函数new(T)分配内存空间，并置为0值</li></ol></blockquote></li><li><p>引用类型的特点是</p><blockquote><ol><li>变量存储的是一个地址，这个地址对应的空间里才是真正存储的值，内存通常在<strong>堆中分配</strong></li><li>使用内置函数make(T)分配内存空间：make( []Type, size, cap )</li><li>零值为nil</li></ol></blockquote></li></ul><h4 id="值类型：数组"><a href="#值类型：数组" class="headerlink" title="值类型：数组"></a>值类型：数组</h4><p>空接口可以标识任意类型（切片也有相同的特性）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// will print [1,a]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;,<span class="number">0</span>) <span class="comment">// 空接口可以标识任意类型</span></span><br><span class="line">   a = <span class="built_in">append</span>(a, <span class="number">1</span>)</span><br><span class="line">   a = <span class="built_in">append</span>(a, <span class="string">`a`</span>)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;%+v&quot;</span>, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="引用类型：切片"><a href="#引用类型：切片" class="headerlink" title="引用类型：切片"></a>引用类型：切片</h4><p>切片的底层是数组。添加成员时，容量是2的指数递增的，2，4，8，16，32。而且是在长度要超过容量时，才增加容量。cap(slice)查看容量，len(slice)查看。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用make初始化（推荐）make( []Type, size, cap )</span></span><br><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// 使用字面量初始化</span></span><br><span class="line">a = []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">var</span> a= <span class="built_in">new</span>([]<span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// append</span></span><br><span class="line"><span class="comment">// copy</span></span><br><span class="line">slice1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">slice2 := []<span class="keyword">int</span>&#123;<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">copy</span>(slice2, slice1) <span class="comment">// 只会复制slice1的前3个元素到slice2中</span></span><br><span class="line"><span class="built_in">copy</span>(slice1, slice2) <span class="comment">// 只会复制slice2的3个元素到slice1的前3个位置</span></span><br></pre></td></tr></table></figure><ul><li><p>从切片和数组生成新的切片</p><blockquote><p>从连续内存区域生成切片是常见的操作，格式如下：slice [开始位置 : 结束位置]</p></blockquote></li></ul><h4 id="引用类型：Interface"><a href="#引用类型：Interface" class="headerlink" title="引用类型：Interface"></a>引用类型：Interface</h4><p>接口定义了一组抽象方法的集合，但是没有实现。所有类型（包括自定义类型）都实现了空接口interface{}，所以空接口可以被当做任意类型的数值。interface的初始化零值为nil。</p><p>Go语言通过interface实现了面向对象的很多特性，这些接口通常只包含0-3个方法。</p><ul><li>特点</li></ul><blockquote><ol><li>类型不用显示的声明实现了接口，只需要实现接口的所有方法，这样的隐式实现解耦了实现接口的包和定义接口的包；</li><li>同一接口可以被多个不同类型实现；</li><li>类型需要实现接口方法集中的所有方法。</li><li>与Java和C++相比，Go中的接口有强大的灵活性</li><li>一个接口可以包含一个或多个其它接口，但不能嵌入自身，也不能嵌入结构体</li></ol></blockquote><ul><li><p>定义并实现接口示例</p><blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">interface</span> &#123;</span><br><span class="line">	a()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">interface</span> &#123;</span><br><span class="line">	A				<span class="comment">// 内嵌 interface A</span></span><br><span class="line">	b()    <span class="comment">// B的抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> C <span class="keyword">struct</span> &#123;</span><br><span class="line">	B      <span class="comment">// 结构体C实现接口B</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *C)</span> <span class="title">a</span><span class="params">()</span></span> &#123;	   <span class="comment">// 具体实现</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *C)</span> <span class="title">b</span><span class="params">()</span></span>  &#123;   <span class="comment">// 具体实现</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c:=C&#123;&#125;</span><br><span class="line">	c.a()</span><br><span class="line">	c.b()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// print</span></span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br></pre></td></tr></table></figure></blockquote></li></ul><h4 id="引用类型：map字典"><a href="#引用类型：map字典" class="headerlink" title="引用类型：map字典"></a>引用类型：map字典</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从字典m删除键为k的元素</span></span><br><span class="line"><span class="built_in">delete</span>(m, k)</span><br></pre></td></tr></table></figure><h4 id="引用类型：通道channel"><a href="#引用类型：通道channel" class="headerlink" title="引用类型：通道channel"></a>引用类型：通道channel</h4><p>channel是协程之间共享数据的通道（而非Java中的共享内存），可以通过内置的close()函数关闭</p><table><thead><tr><th>通道类型</th><th>阻塞条件</th><th>是否同步</th></tr></thead><tbody><tr><td>无缓冲区</td><td>发送和接收的协程没有同时准备好</td><td>同步消息</td></tr><tr><td>有缓冲区</td><td>缓冲区满时发送方阻塞 &#x2F; 通道中没有新的值时接收方阻塞</td><td>异步消息</td></tr><tr><td>nil</td><td>总是阻塞</td><td>-</td></tr></tbody></table><p>通道关闭后，无法向通道继续发送数据。</p><h4 id="值类型：函数"><a href="#值类型：函数" class="headerlink" title="值类型：函数"></a>值类型：函数</h4><p>函数中的return操作并不具备原子性，其可能被defer修改。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span> # 声明一个函数类型</span></span><br></pre></td></tr></table></figure><ul><li><p>递归：函数体内间接或直接的调用自身</p></li><li><p>回调：一个函数作为参数传入另一个参数，并在另一个函数中调用</p></li><li><p>匿名函数（闭包）：</p></li></ul><blockquote><p>闭包函数的作用域：可以捕获其所在代码块上下文中的变量的引用，而与实际使用时，表面的作用域无关。</p></blockquote><h4 id="引用类型：指针"><a href="#引用类型：指针" class="headerlink" title="引用类型：指针"></a>引用类型：指针</h4><h4 id="值类型：int系列"><a href="#值类型：int系列" class="headerlink" title="值类型：int系列"></a>值类型：int系列</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint8</span>  : <span class="number">0</span> to <span class="number">255</span> </span><br><span class="line"><span class="keyword">uint16</span> : <span class="number">0</span> to <span class="number">65535</span> </span><br><span class="line"><span class="keyword">uint32</span> : <span class="number">0</span> to <span class="number">4294967295</span> </span><br><span class="line"><span class="keyword">uint64</span> : <span class="number">0</span> to <span class="number">18446744073709551615</span> </span><br><span class="line"><span class="keyword">int8</span>   : <span class="number">-128</span> to <span class="number">127</span> </span><br><span class="line"><span class="keyword">int16</span>  : <span class="number">-32768</span> to <span class="number">32767</span> </span><br><span class="line"><span class="keyword">int32</span>/<span class="keyword">int</span>  : <span class="number">-2147483648</span> to <span class="number">2147483647</span> </span><br><span class="line"><span class="keyword">int64</span>  : <span class="number">-9223372036854775808</span> to <span class="number">9223372036854775807</span></span><br></pre></td></tr></table></figure><h4 id="值类型：float系列"><a href="#值类型：float系列" class="headerlink" title="值类型：float系列"></a>值类型：float系列</h4><h4 id="值类型：结构体"><a href="#值类型：结构体" class="headerlink" title="值类型：结构体"></a>值类型：结构体</h4><p>特点</p><ol><li><p>结构体及其包含的数据在内存中是连续的，这带来很大的性能优势</p></li><li><p>递归结构体，通过引用自身的指针来定义（二叉树和链表）</p></li><li><p>field的可见性：名称首字母的大小写</p></li><li><p>结构体标签（tag）</p><blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span> <span class="string">&quot;学生名字&quot;</span></span><br><span class="line">	Age  <span class="keyword">int</span>    <span class="string">&quot;学生年龄&quot;</span></span><br><span class="line">	Room <span class="keyword">int</span>    <span class="string">&quot;json:Roomid&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	st := Student&#123;<span class="string">&quot;Li&quot;</span>, <span class="number">14</span>, <span class="number">102</span>&#125;</span><br><span class="line">	fmt.Println(reflect.TypeOf(st).Field(<span class="number">0</span>).Tag)</span><br><span class="line">	fmt.Println(reflect.TypeOf(st).Field(<span class="number">1</span>).Tag)</span><br><span class="line">	fmt.Println(reflect.TypeOf(st).Field(<span class="number">2</span>).Tag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>匿名字段：没有显式的名字，类型就是字段（所以，每个结构体中同一类型只能有一个匿名字段）</p><blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">   name <span class="keyword">string</span> <span class="string">&quot;学生名字&quot;</span></span><br><span class="line">   Age  <span class="keyword">int</span>    <span class="string">&quot;学生年龄&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">   Person  <span class="comment">// 匿名字段，只有类型</span></span><br><span class="line">   Room <span class="keyword">int</span> <span class="string">&quot;json:Roomid&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>嵌入与聚合：结构体中包含匿名（内嵌）字段叫做嵌入或者内嵌。如果结构体中字段包含了类型名和字段名，则叫做聚合。</p><blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human   		<span class="comment">// 内嵌</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Person2 <span class="keyword">struct</span> &#123;</span><br><span class="line">	*Human			<span class="comment">// 内嵌</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Person3 <span class="keyword">struct</span> &#123;</span><br><span class="line">	human Human			<span class="comment">// 聚合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嵌入方式：</p><ol><li>接口中嵌入接口：</li><li>接口中嵌入结构体：不合法，无法通过编译</li><li>结构体中内嵌接口：</li><li>结构体中嵌入结构体：不可嵌入自身的值类型（指针可以）</li></ol></blockquote></li><li><p>方法</p><blockquote><p>通过接收器与结构体绑定的函数</p></blockquote></li></ol><h4 id="值类型：复数"><a href="#值类型：复数" class="headerlink" title="值类型：复数"></a>值类型：复数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造一个实部为1，虚部为2的复数</span></span><br><span class="line">c := <span class="built_in">complex</span>(<span class="number">-1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 读取实部</span></span><br><span class="line">r := <span class="built_in">real</span>(c)</span><br><span class="line"><span class="comment">// 读取虚部</span></span><br><span class="line">i := <span class="built_in">imag</span>(c)</span><br><span class="line"><span class="comment">// cmplx包，复数操作函数包</span></span><br><span class="line">cmplx.Abs(c)</span><br></pre></td></tr></table></figure><h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><p>后进先出</p><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><p>在switch或select语句中，break的作用是跳过整个代码块，执行swith或select之后的代码。</p><p>Go语言中的break，fallthrough</p><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><h4 id="error"><a href="#error" class="headerlink" title="error"></a>error</h4><h4 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h4><p>表示严重且不可恢复的异常。</p><h4 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h4><p>从panic或error场景中恢复。</p><h3 id="组合的方法集"><a href="#组合的方法集" class="headerlink" title="组合的方法集"></a>组合的方法集</h3><p>golang中没有继承的概念，代码复用是通过组合的方式实现。</p><h3 id="CGO"><a href="#CGO" class="headerlink" title="CGO"></a>CGO</h3><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="嵌入"><a href="#嵌入" class="headerlink" title="嵌入"></a>嵌入</h3><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><h2 id="SDK核心包"><a href="#SDK核心包" class="headerlink" title="SDK核心包"></a>SDK核心包</h2><h3 id="fmt"><a href="#fmt" class="headerlink" title="fmt"></a>fmt</h3><h4 id="v-v-v的区别"><a href="#v-v-v的区别" class="headerlink" title="%v %+v %#v的区别"></a>%v %+v %#v的区别</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := &amp;student&#123;<span class="string">&quot;jiafu&quot;</span>, <span class="number">123456</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%%v的方式  = %v\n&quot;</span>, s)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%%+v的方式 = %+v\n&quot;</span>, s)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%%#v的方式 = %#v\n&quot;</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// %v的方式  = &amp;&#123;jiafu 123456&#125;</span></span><br><span class="line"><span class="comment">// %+v的方式 = &amp;&#123;name:jiafu id:123456&#125;</span></span><br><span class="line"><span class="comment">// %#v的方式 = &amp;main.student&#123;name:&quot;jiafu&quot;, id:123456&#125;</span></span><br><span class="line"><span class="comment">// %v 只输出所有的值</span></span><br><span class="line"><span class="comment">// %+v 先输出字段类型，再输出该字段的值</span></span><br><span class="line"><span class="comment">// %#v 先输出结构体名字值，再输出结构体（字段类型+字段的值）</span></span><br></pre></td></tr></table></figure><h3 id="math"><a href="#math" class="headerlink" title="math"></a>math</h3><h3 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h3><h4 id="runtime-x2F-pprof-（net-x2F-http-x2F-pprof）"><a href="#runtime-x2F-pprof-（net-x2F-http-x2F-pprof）" class="headerlink" title="runtime&#x2F;pprof （net&#x2F;http&#x2F;pprof）"></a>runtime&#x2F;pprof （net&#x2F;http&#x2F;pprof）</h4><p>用于监控Go的堆栈、CPU的耗时等性能信息。</p><h3 id="bytes"><a href="#bytes" class="headerlink" title="bytes"></a>bytes</h3><h3 id="strings"><a href="#strings" class="headerlink" title="strings"></a>strings</h3><h3 id="utf8"><a href="#utf8" class="headerlink" title="utf8"></a>utf8</h3><h3 id="strconv"><a href="#strconv" class="headerlink" title="strconv"></a>strconv</h3><h3 id="unsafe"><a href="#unsafe" class="headerlink" title="unsafe"></a>unsafe</h3><h3 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h3><p>提供了原子操作的方法，类似JDK juc包中的原子类。</p><h3 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h3><h4 id="互斥锁-sync-Mutex（全局锁）"><a href="#互斥锁-sync-Mutex（全局锁）" class="headerlink" title="互斥锁 sync.Mutex（全局锁）"></a>互斥锁 sync.Mutex（全局锁）</h4><p>传统的并发程序通常使用互斥锁对共享资源进行访问，而Go提倡使用通道实现资源共享和通信。</p><p>Mutex只有两个方法：调用Lock()获得锁（同一个协程不能重复Lock），UnLock()释放锁。只允许一个协程的读或者写。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lck sync.Mutex <span class="comment">// 定义一个互斥锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">  lck.Lock() <span class="comment">// 会阻塞到获取锁</span></span><br><span class="line">  <span class="keyword">defer</span> lck.Unlock() <span class="comment">// defer语句在函数返回时获取锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读写锁-sync-RWMutex"><a href="#读写锁-sync-RWMutex" class="headerlink" title="读写锁 sync.RWMutex"></a>读写锁 sync.RWMutex</h4><p>多读单写的互斥锁</p><h4 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h4><p>主线程使用Add()方法设置等待的协程数量，并在完成后调用Done()方法。同时Wait方法可以阻塞主线程，直到所有协程完成后才会向下执行。</p><h4 id="sync-Once-Do"><a href="#sync-Once-Do" class="headerlink" title="sync.Once.Do()"></a>sync.Once.Do()</h4><p>保证Do()方法只执行一次</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;sync&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 只会打印一次</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> once sync.Once</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">      fun1 := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;i:=%d\n&quot;</span>, i)</span><br><span class="line">      &#125;</span><br><span class="line">      once.Do(fun1)</span><br><span class="line">    &#125;(i)</span><br><span class="line">  &#125;</span><br><span class="line">  time.Sleep(<span class="number">50</span> * time.Millisecond) <span class="comment">// 为了防止主goroutine直接运行完了，啥都看不到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h4><p>线程安全的字典。</p><h3 id="testing"><a href="#testing" class="headerlink" title="testing"></a>testing</h3><p>*_test.go</p><h3 id="reflect"><a href="#reflect" class="headerlink" title="reflect"></a>reflect</h3><h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><h3 id="os"><a href="#os" class="headerlink" title="os"></a>os</h3><h3 id="net"><a href="#net" class="headerlink" title="net"></a>net</h3><h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><h3 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h3><h3 id="json"><a href="#json" class="headerlink" title="json"></a>json</h3><h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><h2 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h2><h3 id="环境变量与项目目录"><a href="#环境变量与项目目录" class="headerlink" title="环境变量与项目目录"></a>环境变量与项目目录</h3><ul><li><p>GOROOT 安装目录</p></li><li><p>GOPATH 工程目录</p></li></ul><blockquote><ol><li>GOPATH在项目管理中非常重要，创建项目必须确保目录在GOPATH中，多个项目用分号分隔</li><li>src 源代码</li><li>pkg 存放编译后生成的文件</li><li>bin 存放编译后生成的可执行文件</li></ol></blockquote><h3 id="源代码管理"><a href="#源代码管理" class="headerlink" title="源代码管理"></a>源代码管理</h3><blockquote><ol><li>Go中使用package来结构化的组织代码</li><li>Init()函数常用于包的初始化，不能被其它函数调用，在main()方法之前自动执行</li><li>Init()函数有多个时，其执行顺序是无法确定的</li><li>import关键字将当前文件与package关联</li></ol></blockquote><h4 id="WorkSpace"><a href="#WorkSpace" class="headerlink" title="WorkSpace"></a>WorkSpace</h4><p>go语言中的workspace使你在不编辑mod.go的情况下（不需要单独编辑每个go.mod文件），维护工程目录下的多个module。在解决依赖时workspace会被作为root模块。</p><blockquote><p>go.work 文件包含的指令与go.mod类似<br>go&#x2F;use&#x2F;replace</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生产 go.work 文件</span></span><br><span class="line">go work init</span><br><span class="line"><span class="meta">#</span><span class="bash"> 递归的将目录下包含go.mod的文件夹导入</span></span><br><span class="line">go work use -r</span><br><span class="line"><span class="meta">#</span><span class="bash"> go.work中定义的依赖同步至go.mod</span></span><br><span class="line">go work sync</span><br><span class="line"><span class="meta">#</span><span class="bash"> go.work命令行编辑</span></span><br><span class="line">go work edit</span><br></pre></td></tr></table></figure><p>go.work文件示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="number">1.18</span></span><br><span class="line">use (</span><br><span class="line">		 path-to-your-mode</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod init</span><br></pre></td></tr></table></figure><h3 id="注释规范"><a href="#注释规范" class="headerlink" title="注释规范"></a>注释规范</h3><p>在包中创建doc.go文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 启动本地文档服务</span><br><span class="line">godoc -http=:6060 -play</span><br></pre></td></tr></table></figure><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><p>go中的变量和类型通过名称的首字母的大小写控制包外的可见性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包外可见</span></span><br><span class="line"><span class="keyword">var</span> Value1 <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">type</span> DemoType &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *X)</span> <span class="title">Set</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x.a = i</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 包外不可见</span></span><br><span class="line"><span class="keyword">var</span> value2 <span class="keyword">int</span> = <span class="number">3</span></span><br><span class="line"><span class="keyword">type</span> fooType&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h3><p>如果开发的是Web程序，可以引入包_ “net&#x2F;http&#x2F;pprof”，在浏览器中访问 <a href="http://localhost:port/debug/pprof/">http://localhost:port/debug/pprof/</a></p><h2 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h2><h3 id="基于OpenCV的跨平台GUI自动化库"><a href="#基于OpenCV的跨平台GUI自动化库" class="headerlink" title="基于OpenCV的跨平台GUI自动化库"></a>基于OpenCV的跨平台GUI自动化库</h3><p><a target="_blank" rel="noopener" href="https://github.com/go-vgo/robotgo">https://github.com/go-vgo/robotgo</a></p><h3 id="Web框架"><a href="#Web框架" class="headerlink" title="Web框架"></a>Web框架</h3><p><a target="_blank" rel="noopener" href="https://github.com/gin-gonic/gin">https://github.com/gin-gonic/gin</a></p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数的参数传递是值传递还是引用传递"><a href="#函数的参数传递是值传递还是引用传递" class="headerlink" title="函数的参数传递是值传递还是引用传递"></a>函数的参数传递是值传递还是引用传递</h4><h4 id="匿名函数的延时绑定问题"><a href="#匿名函数的延时绑定问题" class="headerlink" title="匿名函数的延时绑定问题"></a>匿名函数的延时绑定问题</h4><h4 id="Go语言中有类吗？"><a href="#Go语言中有类吗？" class="headerlink" title="Go语言中有类吗？"></a>Go语言中有类吗？</h4><p>在经典的面向对象语言中（Java、C++、C#等），将数据和方法封装为类，类中包含两者且不能剥离。而Go语言中，数据和方法是正交关系。</p><p>结构体可以看做类的简化形式。</p><h3 id="数据类型-1"><a href="#数据类型-1" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="切片的扩容规则"><a href="#切片的扩容规则" class="headerlink" title="切片的扩容规则"></a>切片的扩容规则</h4><h4 id="什么是鸭子类型"><a href="#什么是鸭子类型" class="headerlink" title="什么是鸭子类型"></a>什么是鸭子类型</h4><h4 id="Is-Go-an-object-oriented-language"><a href="#Is-Go-an-object-oriented-language" class="headerlink" title="Is Go an object-oriented language?"></a>Is Go an object-oriented language?</h4><p>Yes and no. Although Go has types and methods and allows an object-oriented style of programming, there is no type hierarchy. The concept of “interface” in Go provides a different approach that we believe is easy to use and in some ways more general. There are also ways to embed types in other types to provide something analogous—but not identical—to subclassing. Moreover, methods in Go are more general than in C++ or Java: they can be defined for any sort of data, even built-in types such as plain, “unboxed” integers. They are not restricted to structs (classes).</p><p>Also, the lack of a type hierarchy makes “objects” in Go feel much more lightweight than in languages such as C++ or Java.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a target="_blank" rel="noopener" href="https://go.dev/doc/">https://go.dev/doc/</a></li></ol><p>持续完善中….</p><link rel="stylesheet" href="/css/markmap.css" type="text/css"></div><div class="article-footer"><blockquote class="mt-2x"><ul class="post-copyright list-unstyled"><li class="post-copyright-link hidden-xs"><strong>本文链接：</strong> <a href="https://blog.beyhub.com/post/go%E8%AF%AD%E8%A8%80%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/" title="Go语言深入浅出" target="_blank" rel="external">https://blog.beyhub.com/post/go语言深入浅出/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！</li></ul></blockquote><hr></div></article><section id="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section></div><nav class="bar bar-footer clearfix" data-stick-bottom><div class="bar-inner"><ul class="pager pull-left"><li class="next"><a href="/post/kubernetes%E5%AE%9E%E7%8E%B0traefik%E4%BB%A3%E7%90%86mysql%E6%B5%81%E9%87%8F/" title="Kubernetes实现Traefik代理MySQL流量"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a></li><li class="toggle-toc"><a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button"><span>[&nbsp;</span><span>文章目录</span> <i class="text-collapsed icon icon-anchor"></i> <i class="text-in icon icon-close"></i> <span>]</span></a></li></ul><div class="bar-right"></div></div></nav></main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter"><ul class="social-links"><li><a href="https://github.com/lesterlaucn" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="http://weibo.com/lyc90" target="_blank" title="Weibo" data-toggle="tooltip" data-placement="top"><i class="icon icon-weibo"></i></a></li><li><a href="https://twitter.com/lesterlaucn" target="_blank" title="Twitter" data-toggle="tooltip" data-placement="top"><i class="icon icon-twitter"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul><div class="copyright">&copy; 2022 刘远程 (Lester Lau)<div class="publishby">Theme by <a href="https://github.com/cofess" target="_blank">me </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.</div></div></footer><script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script><script>window.jQuery||document.write('<script src="js/jquery.min.js"><\/script>')</script><script src="/js/plugin.min.js"></script><script src="/js/application.js"></script><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(未命名)"},ROOT_URL:"/",CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script><script defer>var disqus_config=function(){this.page.url="https://blog.beyhub.com/post/go%E8%AF%AD%E8%A8%80%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/",this.page.identifier="2022/Go语言深入浅出"};!function(){var t=document,e=t.createElement("script");e.src="//cai-ju-dong-li.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script><script>$(document).ready(function () {
      let imgs = $('article img');
      imgs.attr('src', '/' + imgs.attr('src'))
    }
  //利用 FancyBox 实现点击图片放大
  $(document).ready(function () {
      $('article img').not('[hidden]').not('.panel-body img').each(function () {
        var $image = $(this);
        var imageCaption = $image.attr('alt');
        var $imageWrapLink = $image.parent('a');
        if ($imageWrapLink.length < 1) {
          var src = this.getAttribute('src');
          var idx = src.lastIndexOf('?');
          if (idx != -1) {
            src = src.substring(0, idx);
          }
          $imageWrapLink = $image.wrap('<a href="' + src + '"></a>').parent('a');
        }
        $imageWrapLink.attr('data-fancybox', 'images');
        if (imageCaption) {
          $imageWrapLink.attr('data-caption', imageCaption);
        }
      });
      $().fancybox({
        selector: '[data-fancybox="images"]',
        hash: false,
        loop: false,
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/d3@5"></script><script src="https://cdn.jsdelivr.net/npm/markmap-lib@0.7.4/dist/browser/view.min.js"></script><script>const mindmaps=document.querySelectorAll(".markmap-svg");for(const a of mindmaps)markmap.markmap(a,JSON.parse(a.innerHTML))</script></body></html>