---
title: 深度优先搜索与广度优先搜索
tags:
  - DFS
  - BFS
categories:
  - 算法
toc: true
date: 2022-04-19 17:52:45

---

### 相同的树-DFS[leetcode 100]

给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。


```go
func isSameTree(p *TreeNode, q *TreeNode) bool {
   if p == nil && q == nil {
      return true
   }
   if p == nil || q == nil {
      return false
   }
   if p.Val != q.Val {
      return false
   }
   // 如果p.Val=q.Val 继续递归子树
   return isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)
}
```

### 对称的二叉树

https://leetcode-cn.com/problems/symmetric-tree/

```go
func isSymmetric(root *TreeNode) bool {
   if root == nil {
      return true
   }
   var dfs func(left, right *TreeNode) bool
   dfs = func(left, right *TreeNode) bool {
      if left == nil && right == nil {
         return true
      }
      if left == nil || right == nil {
         return false
      }
      if left.Val != right.Val {
         return false
      }
      // 重点
      return dfs(left.Left, right.Right) && dfs(left.Right, right.Left)
   }
   return dfs(root.Left, root.Right)
}
```

### 二叉树的最大深度

https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/

```go
func maxDepth(root *TreeNode) int {
   if root == nil {
      return 0
   }
   var queue []*TreeNode
   queue = append(queue, root)
   cnt := 0
   for len(queue) > 0 {
      // 每一层的节点数量
      size := len(queue)
      for size > 0 {
         node := queue[0:1][0]
         queue = queue[1:]
         if node.Left != nil {
            queue = append(queue, node.Left)
         }
         if node.Right != nil {
            queue = append(queue, node.Right)
         }
         size--
      }
      cnt++
   }
   return cnt
}
```

### 二叉树的最小深度

https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/

首先可以想到使用深度优先搜索的方法，遍历整棵树，**记录最小深度**。对于每一个非叶子节点，我们只需要分别计算其左右子树的最小叶子节点深度。这样就将一个大问题转化为了小问题，可以递归地解决该问题。

```go
// 深度优先搜索
func minDepth(root *TreeNode) int {
   if root == nil {
      return 0
   }
   if root.Left == nil && root.Right == nil {
      return 1
   }
   minD := math.MaxInt
   if root.Left != nil {
      minD = min(minD, minDepth(root.Left))
   }
   if root.Right != nil {
      minD = min(minD, minDepth(root.Right))
   }
   return minD + 1
}
func min(a, b int) int {
   if a > b {
      return b
   }
   return a
}
```