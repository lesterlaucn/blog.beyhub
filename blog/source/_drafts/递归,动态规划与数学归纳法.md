---
title: 递归,动态规划与数学归纳法
date: 2022-04-12 10:42:30
tags:
  - 动态规划
  - 数学归纳法
categories:
  - 算法
toc: true

---

乔治·桑塔亚纳说过，“**那些遗忘过去的人，注定要重蹈覆辙。**”这句话放在问题求解过程中也同样适用。动态规划是对普通递归的一种优化。只要我们看到一个对相同输入有重复调用的递归解决方案，我们就可以用动态规划来优化它。这个想法是简单地**存储子问题的结果**，这样我们就不必在以后需要的时候重新计算它们。这种简单的优化将时间的复杂性从指数级降低到多项式。

例如，如果我们为斐波那契数编写简单的递归解决方案，我们会得到指数级的时间复杂度，如果我们通过存储子问题的解决方案来优化它，时间复杂度就会降低到线性。

<img src="images/image-20220420095012475.png" alt="image-20220420095012475" style="zoom: 33%;" />

<!--more-->

而对应到动态规划的递归写法

上文中的1对应的正好是边界条件
上文中的2这对应的正是我们假定已经知道的信息（都可以通过1中的边界求出来）
上文中对应的三正是偶们要求的目标
那么解决动态规划这类的问题就变成了以下三步：

抓住边界（作为递归边界，是数学归纳时候的初始状态）
**找到状态转移方程**（也就是数学归纳法中第k项和第k-1项或者前k-1项的关系）
之后进行根据上面两点写出递归函数，进行适当的优化。

## 递归【分治法】

BaseCase

如果是严格的非条件状态转移，可以使用斐波那契数列

如果每次计算是有条件的，使用动态规划

### 改写为迭代

## 动态规划

动态规划也是一种分治思想（比如其状态转移方程就是一种分治），但与分治算法不同的是，分治算法是把原问题分解为若干个子问题，自顶向下求解子问题，合并子问题的解，从而得到原问题的解。动态规划也是把原始问题分解为若干个子问题，然后自底向上，**先求解最小的子问题，把结果存在表格中**，在求解大的子问题时，直接从表格中查询小的子问题的解，避免重复计算，从而提高算法效率。

所有的暴力递归，都可以改写为动态规划，先写dp数组，基于递归算法改写（所以要先），从小问题。

我们区分动态规划和分支的关键在于，是否有重复子问题！

## 典型题目分析

### 不同的二叉搜索树【leetcode 96】

#### 题目

https://leetcode-cn.com/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode-solution/

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

示例1：输入n=3  输出5

![img](images/uniquebstn3.jpg)

示例2：输入n=1 输出1

#### 题解

##### 思路

给定一个有序序列 `1⋯n`，为了构建出一棵二叉搜索树，我们可以遍历每个数字 `i`，将该数字作为树根，将 `1 ⋯(i−1)` 序列作为左子树，将 `(i+1)⋯n` 序列作为右子树。接着我们可以按照同样的方式递归构建左子树和右子树。

在上述构建的过程中，由于根的值不同，因此我们能保证每棵二叉搜索树是唯一的。

由此可见，原问题可以分解成规模较小的两个子问题，且子问题的解可以复用。因此，我们可以想到使用动态规划来求解本题。

##### 算法【动态规划】

题目要求是计算不同二叉搜索树的个数。为此，我们可以定义两个函数：

`G(n)G(n`): 长度为 nn 的序列能构成的不同二叉搜索树的个数。

`F(i, n)F(i,n)`: 以 ii 为根、序列长度为 nn 的不同二叉搜索树个数 (1 \leq i \leq n)(1≤i≤n)。

可见，``G(n)G(n)`` 是我们求解需要的函数。

稍后我们将看到，G(n)G(n) 可以从 F(i, n)F(i,n) 得到，而 `F(i, n)F(i,n)` 又会递归地依赖于 `G(n)G(n)`。

首先，根据上一节中的思路，不同的二叉搜索树的总数 `G(n)G(n)`，是对遍历所有 `i (1≤i≤n)` 的 `F(i, n)F(i,n) `之和。换言之：

$$
G(n) = \sum_{i=1}^{n} F(i, n)\qquad \qquad (1)
G(n)= 
i=1
∑
n
F(i,n) (1)
$$
对于边界情况，当序列长度为 1（只有根）或为 0（空树）时，只有一种情况，即：
$$
G(0) = 1, \qquad G(1)=1
$$
给定序列 `1⋯n`，我们选择数字 i作为根，则根为 ii 的所有二叉搜索树的集合是左子树集合和右子树集合的笛卡尔积，对于笛卡尔积中的每个元素，加上根节点之后形成完整的二叉搜索树，如下图所示：

举例而言，创建以 33 为根、长度为 77 的不同二叉搜索树，整个序列是 [1, 2, 3, 4, 5, 6, 7][1,2,3,4,5,6,7]，我们需要从左子序列 [1, 2][1,2] 构建左子树，从右子序列 [4, 5, 6, 7][4,5,6,7] 构建右子树，然后将它们组合（即笛卡尔积）。

对于这个例子，不同二叉搜索树的个数为 F(3, 7)F(3,7)。我们将 [1,2][1,2] 构建不同左子树的数量表示为 `G(2)G(2)`, 从 [4, 5, 6, 7][4,5,6,7] 构建不同右子树的数量表示为 G(4)G(4)，注意到 G(n)G(n) 和序列的内容无关，只和序列的长度有关。于是，``F(3,7)=G(2)⋅G(4)``。 因此，我们可以得到以下公式：

$$
F(i, n) = G(i-1) \cdot G(n-i) \qquad \qquad (2)
F(i,n)=G(i−1)⋅G(n−i)(2)
$$
将公式 (1)(1)，(2)(2) 结合，可以得到 G(n)G(n) 的递归表达式：

$$
G(n) = \sum_{i=1}^{n}G(i-1) \cdot G(n-i) \qquad \qquad (3)
G(n)= 
i=1
∑
n

 G(i−1)⋅G(n−i)(3)
$$
至此，我们从小到大计算 G 函数即可，因为 `G(n)G(n)` 的值依赖于``G(0)⋯G(n−1)``。

```go
func numTrees(n int) int {
    G := make([]int, n + 1)
    G[0], G[1] = 1, 1
    for i := 2; i <= n; i++ {
        for j := 1; j <= i; j++ {
            G[i] += G[j-1] * G[i-j]
        }
    }
    return G[n]
}
```
##### 复杂度分析

时间复杂度 : `O(n^2)`，其中 n 表示二叉搜索树的节点个数。``G(n)`` 函数一共有 n 个值需要求解，每次求解需要 `O(n)` 的时间复杂度，因此总时间复杂度为`O(n^2)`。

空间复杂度 : `O(n)`。我们需要 `O(n) `的空间存储 G 数组。





