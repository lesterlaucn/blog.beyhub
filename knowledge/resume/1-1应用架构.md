## 架构设计思想

### 模型驱动设计 MDD

MDA

### 领域驱动设计

#### 为什么要DDD

领域驱动设计是一种以业务为导向的软件设计方法和思路。我们在开发前，通常需要进行大量的业务知识梳理，而后到达软件设计的层面，最后才是开发。而在业务知识梳理的过程中，我们必然会形成某个领域知识，根据领域知识来一步步驱动软件设计，就是领域驱动设计的基本概念。而领域驱动设计的核心就在于建立正确的领域驱动模型。

微服务盛行的今天，多层SOA架构已经完全不能满足微服务架构应用的需求，它存在这么一些问题：

1. 臃肿的servcie
2. 三层分层后文件的随意组装方式
3. 技术导向分层，导致业务分离，不能快速定位。

#### DDD分层架构介绍

- 分层

DDD 分层架构包含用户接口层、应用层、领域层和基础层。通过这些层次划分，我们可以明确微服务各层的职能，划定各领域对象的边界，确定各领域对象的协作方式。DDD的分层架构如图：从上到下依次是：用户接口层、应用层、领域层和基础层。

<img src="images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3cxbGd5,size_16,color_FFFFFF,t_70-20210928160459892.jpeg" style="zoom:60"/>

- 各层次之间的调用关系

![在这里插入图片描述](images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3cxbGd5,size_16,color_FFFFFF,t_70-20210928161106200.jpg)

- 特别说明
  
  > 1. 用户接口层负责向用户显示信息和解释用户指令，并将数据传递给 Application 层。数据的组装、数据传输格式以及 Facade 接口等代码都会放在这一层目录里。这里的用户可能是：用户、程序、自动化测试和批处理脚本等等。
  > 2. 应用层是很薄的一层，理论上不应该有业务规则或逻辑，主要面向用例和流程相关的操作。但应用层又位于领域层之上，因为领域层包含多个聚合，所以它可以协调多个聚合的服务和领域对象完成服务编排和组合，协作完成业务操作。
  > 3. 应用层也是微服务之间交互的通道，它可以调用其它微服务的应用服务，完成微服务之间的服务组合和编排。
  > 4. 实现领域的核心业务逻辑。这一层聚集了领域模型的聚合、聚合根、实体、值对象、领域服务和事件等领域对象，以及它们组合所形成的业务能力。
  > 5. 基础层是贯穿所有层的，它的作用就是为其它各层提供通用的技术和基础服务，包括第三方工具、驱动、消息中间件、网关、文件、缓存以及数据库等。比较常见的功能还是提供数据库持久化。

- 参考阅读：https://blog.csdn.net/w1lgy/article/details/111566243

#### DDD术语：聚合与聚合根

#### 实体、值对象

#### 充血模型和失血模型

贫血模型：是指领域对象里只有get和set方法，或者包含少量的CRUD方法，所有的业务逻辑都不包含在内而是放在Business Logic层。

> 好处
> 
> 1. 每个贫血对象职责单一，所以模块解藕程度很高，有利于错误的隔离。
> 2. 非常重要的是，这种模型非常适合于软件外包和大规模软件团队的协作。每个编程个体只需要负责单一职责的小对象模块编写，不会互相影响。
> 
> 坏处
> 
> 1. 由于对象状态和行为分离，所以一个完整的业务逻辑的描述不能够在一个类当中完成，而是一组互相协作的类共同完成的。因此可复用的颗粒度比较小，代码量膨胀的很厉害，最重要的是业务逻辑的描述能力比较差，一个稍微复杂的业务逻辑，就需要太多类和太多代码去表达。
> 2. 对象协作依赖于外部容器的组装，因此裸写代码是不可能的了，必须借助于外部的IoC容器。 

充血模型：层次结构和上面的差不多，不过大多业务逻辑和持久化放在Domain Object里面，Business Logic（业务逻辑层）只是简单封装部分业务逻辑以及控制事务、权限等。

> 好处
> 
> 1. 对象自洽程度很高，表达能力很强，因此非常适合于复杂的企业业务逻辑的实现，以及可复用程度比较高。
> 2. 不必依赖外部容器的组装，所以RoR没有IoC的概念。
> 
> 坏处
> 
> 1. 对象高度自洽的结果是不利于大规模团队分工协作。一个编程个体至少要完成一个完整业务逻辑的功能。对于单个完整业务逻辑，无法再细分下去了。
> 2. 随着业务逻辑的变动，领域模型可能会处于比较频繁的变动状态中，领域模型不够稳定也会带来web层代码频繁变动。

#### 说说VO、PO、DO、DTO这些概念

VO（View Object）： 视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。

DTO（Data Transfer Object）： 数据传输对象，这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，我泛指用于展示层与服务层之间的数据传输对象。

DO（Domain Object）： 领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。

PO（Persistent Object）： 持久化对象，它跟持久层（通常是关系型数据库）的数据结构形成一一对应的映射关系，如果持久层是关系型数据库，那么，数据表中的每个字段（或若干个）就对应PO的一个（或若干个）属性。

### 设计模式

### 约定优于配置

其实在开发中，处处都用到了“约定大于配置”这一思想

就是在开发中，如果有些值你没有配置的话，那程序会取一个默认值，换句话说，能取默认值的配置，就不需要配置了，这个默认值就是约定。
约定可以减少很多配置
比如说在maven的结构中:

/src/main/java目录用来存放java源文件
src/main/resources目录用来存放资源文件，如application.yml文件，mybatis的*mapper.xml文件
/src/test/java目录用来存放java测试文件
/src/test/resources目录用来存放测试资源文件
/target目录为项目的输出位置
java 项目 www.fhadmin.org
其实呢，maven为你做了很多事情，只是它都对用户隐藏了起来，你只需要遵循它的约定即可
约定大于配置是一个简单的概念。系统，类库，框架假定其合理的默认值，而非要求提供不必要的配置。在大部分情况下，使用框架提供的默认值会让项目运行的更快。
在springboot中，只要导入了web-stater，spring mvc、json、spring核心容器等web场景需要的所有依赖都会导入，并控制好版本

spring boot的理念就是约定大于配置，在spring boot中提供了一套默认配置，不需要手动去写xml配置文件，只有默认配置不能满足我们的需求时，才会去修改配置。

### 架构设计原则

#### 合适原则:『合适优于业界领先』

- 是否『领先』，是否『亿级』都不重要，脚踏实地的实现架构是最重要的
- 有多少人干多少活，十个人团队想做几十人才能完成的事情，失败机率太大
- 领先的方案不是拍脑袋灵机一动得来的，而是经过长时间的发展逐步完善的
- 业界领先的方案都是业务发展到一定阶段才催生出来的，不是一蹴而就的

> 真正优秀的架构都是在企业当前人力、条件、业务等各种约束下设计出来的，能够合理地将资源整合在一起并发挥出最大功效，并且能够快速落地。

#### 简单原则:『简单优于复杂』

- 技术越来越精细和复杂，导致架构设计时也想把架构做精美、做复杂，以便体现技术实力
- 团队压力也会促使架构走向复杂，因为评价方案水平高低时，复杂性是重要参考指标
- 『复杂』在软件领域，代表的不是领先或者先进，而是『问题』
- 软件领域的复杂性有两个：结构的复杂性、逻辑的复杂性
- 结构复杂的特点是组件数量多、组件之间的关系复杂；因而可能导致：组件故障率高、一个组件改动影响关联的所有组件、定位问题更加困难。
- 逻辑复杂的特点是单个组件承担了太多功能、采用了复杂算法；因而导致难以实现、难以修改、问题无法快速解决。
- 如果简单方案和复杂方案都可以满足要求，架构设计应选择简单方案

> 《UNIX 编程艺术》总结的 KISS（Keep It Simple, Stupid!）原则一样适应于架构设计。

#### 演化原则:『演化优于一步到位』

- 软件架构与建筑架构在定义和理解上有相似性，但存在本质差异：软件需要不断变化
- 架构设计的误区：一步到位的设计一个软件架构，期望不管业务如何变化都能适应
- 软件架构设计更类似于『设计』一个生物：通过演化让生物适应环境，并逐步变得强大
- 明确当前业务特点和主要问题才是设计的根本，不符合业务的架构再领先也没用

> 架构师在进行架构设计时需要牢记这个原则，时刻提醒自己不要贪大求全，或者盲目照搬大公司的做法。

## 云原生

### 为什么要云原生

1. 声明式定义环境
2. 标准化
3. 弹性扩容
4. 业务开发可以直接

### 词汇概念

#### **API Group**

Kubernetes API 中的一组相关路径。 [[-\]](javascript:void(0))

通过更改 API server 的配置，可以启用或禁用每个 API Group。 你还可以禁用或启用指向特定资源的路径。 API group 使扩展 Kubernetes API 更加的容易。 API group 在 REST 路径和序列化对象的 `apiVersion` 字段中指定。

- 阅读 [API Group](https://kubernetes.io/zh/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning) 了解更多信息。

#### **API 发起的驱逐**

API 发起的驱逐是一个先调用 [Eviction API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#create-eviction-pod-v1-core) 创建 `Eviction` 对象，再由该对象体面地中止 Pod 的过程。 [[-\]](javascript:void(0))

你可以通过 kube-apiserver 的客户端，比如 `kubectl drain` 这样的命令，直接调用 Eviction API 发起驱逐。 当 `Eviction` 对象创建出来之后，该对象将驱动 API 服务器终止选定的Pod。

API 发起的驱逐不同于 [节点压力引发的驱逐](https://kubernetes.io/zh/docs/concepts/scheduling-eviction/eviction/#kubelet-eviction)。

#### **cAdvisor**

cAdvisor (Container Advisor) 为容器用户提供对其运行中的[容器](https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/#why-containers) 的资源用量和性能特征的知识。 [[-\]](javascript:void(0))

cAdvisor 是一个守护进程，负责收集、聚合、处理并输出运行中容器的信息。 具体而言，针对每个容器，该进程记录容器的资源隔离参数、历史资源用量、 完整历史资源用量和网络统计的直方图。这些数据可以按容器或按机器层面输出。

#### **CIDR**

CIDR (无类域间路由) 是一种描述 IP 地址块的符号，被广泛使用于各种网络配置中。CIDR 标记使用一个斜线`/`分隔符，后面跟一个十进制数值表示地址中网络部分所占的位数。例如，205.123.196.183/25 中的 25 表示地址中 25 位用于网络 ID，相应的掩码为 255.255.255.128。

在 Kubernetes 的上下文中，每个[节点](https://kubernetes.io/zh/docs/concepts/architecture/nodes/) 以 CIDR 形式（含起始地址和子网掩码）获得一个 IP 地址段， 从而能够为每个 [Pod](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/) 分配一个独一无二的 IP 地址。 虽然其概念最初源自 IPv4，CIDR 已经被扩展为涵盖 IPv6。

#### ConfigMap

ConfigMap 是一种 API 对象，用来将非机密性的数据保存到键值对中。使用时， [Pods](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/) 可以将其用作环境变量、命令行参数或者存储卷中的配置文件。 [[-\]](javascript:void(0))

ConfigMap 将您的环境配置信息和 [容器镜像](https://kubernetes.io/zh/docs/reference/glossary/?all=true#term-image) 解耦，便于应用配置的修改。

#### **containerd**

强调简单性、健壮性和可移植性的一种容器运行时 [[-\]](javascript:void(0))

containerd 是一种[容器](https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/#why-containers)运行时，能在 Linux 或者 Windows 后台运行。 containerd 能取回、存储容器镜像，执行容器实例，提供网络访问等。

#### **CRI-O**

该工具可让你通过 Kubernetes CRI 使用 OCI 容器运行时。 [[-\]](javascript:void(0))

CRI-O 是 [CRI](https://kubernetes.io/zh/docs/concepts/overview/components/#container-runtime) 的一种实现， 使得你可以使用与开放容器倡议（Open Container Initiative，OCI） [运行时规范](https://www.github.com/opencontainers/runtime-spec) 兼容的[容器](https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/#why-containers)。

部署 CRI-O 允许 Kubernetes 使用任何符合 OCI 要求的运行时作为容器运行时 去运行 [Pods](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/)， 并从远程容器仓库获取 OCI 容器镜像。

#### **CustomResourceDefinition**

通过定制化的代码给您的 Kubernetes API 服务器增加资源对象，而无需编译完整的定制 API 服务器。 [[-\]](javascript:void(0))

当 Kubernetes 公开支持的 API 资源不能满足您的需要时，定制资源对象（Custom Resource Definitions）让您可以在您的环境上扩展 Kubernetes API。

#### DaemonSet

确保 [Pod](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/) 的副本在[集群](https://kubernetes.io/zh/docs/reference/glossary/?all=true#term-cluster)中的一组节点上运行。 [[-\]](javascript:void(0))

用来部署系统守护进程，例如日志搜集和监控代理，这些进程通常必须运行在每个[节点](https://kubernetes.io/zh/docs/concepts/architecture/nodes/)上。javascript:void(0))

#### **Deployment**

Deployment 是管理应用副本的 API 对象，通常通过运行没有本地状态的Pods来实现。 [[+\]](javascript:void(0))

#### **Docker**

Docker（这里特指 Docker 引擎） 是一种可以提供操作系统级别虚拟化（也称作[容器](https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/#why-containers)）的软件技术。 [[-\]](javascript:void(0))

Docker 使用了 Linux 内核中的资源隔离特性（如 cgroup 和内核命名空间）以及支持联合文件系统（如 OverlayFS 和其他）， 允许多个相互独立的“容器”一起运行在同一 Linux 实例上，从而避免启动和维护虚拟机（VMs）的开销。

#### **EndpointSlice**

一种将网络端点与 Kubernetes 资源组合在一起的方法。 [[+\]](javascript:void(0))

#### **etcd**

etcd 是兼具一致性和高可用性的键值数据库，可以作为保存 Kubernetes 所有集群数据的后台数据库。 [[-\]](javascript:void(0))

您的 Kubernetes 集群的 etcd 数据库通常需要有个备份计划。javascript:void(0))

#### **Finalizer**

Finalizer 是带有命名空间的键，告诉 Kubernetes 等到特定的条件被满足后， 再完全删除被标记为删除的资源。 Finalizer 提醒[控制器](https://kubernetes.io/zh/docs/concepts/architecture/controller/)清理被删除的对象拥有的资源。

当你告诉 Kubernetes 删除一个指定了 Finalizer 的对象时， Kubernetes API 通过填充 `.metadata.deletionTimestamp` 来标记要删除的对象， 并返回`202`状态码 (HTTP "已接受") 使其进入只读状态。 此时控制平面或其他组件会采取 Finalizer 所定义的行动， 而目标对象仍然处于终止中（Terminating）的状态。 这些行动完成后，控制器会删除目标对象相关的 Finalizer。 当 `metadata.finalizers` 字段为空时，Kubernetes 认为删除已完成。

#### **FlexVolume**

FlexVolume 是一个已弃用的接口，用于创建树外卷插件。 [容器存储接口（CSI）](https://kubernetes.io/zh/docs/concepts/storage/volumes/#csi) 是比 Flexvolume 更新的接口，它解决了 Flexvolume 的一些问题。 [[-\]](javascript:void(0))

Flexvolume 允许用户编写自己的驱动程序，并在 Kubernetes 中加入对用户自己的数据卷的支持。 FlexVolume 驱动程序的二进制文件和依赖项必须安装在主机上。 这需要 root 权限。如果可能的话，SIG Storage 建议实现 [CSI](https://kubernetes.io/zh/docs/concepts/storage/volumes/#csi) 驱动程序， 因为它解决了 Flexvolumes 的限制。

- [Kubernetes 文档中的 Flexvolume](https://kubernetes.io/zh/docs/concepts/storage/volumes/#flexvolume)
- [更多关于 Flexvolumes 的信息](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-storage/flexvolume.md)
- [存储供应商的卷插件 FAQ](https://github.com/kubernetes/community/blob/master/sig-storage/volume-plugin-faq.md)

#### **Helm Chart**

Helm Chart 是一组预先配置的 Kubernetes 资源所构成的包，可以使用 Helm 工具对其进行管理。 [[-\]](javascript:void(0))

Chart 提供了一种可重现的用来创建和共享 Kubernetes 应用的方法。 单个 Chart 可用来部署简单的系统（例如一个 memcached Pod）， 也可以用来部署复杂的系统（例如包含 HTTP 服务器、数据库、缓存等组件的完整 Web 应用堆栈）。

#### **HostAliases**

主机别名 (HostAliases) 是一组 IP 地址和主机名的映射，用于注入到 [Pod](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/) 内的 hosts 文件。 [[-\]](javascript:void(0))

[HostAliases](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#hostalias-v1-core) 是一个包含主机名和 IP 地址的可选列表，配置后将被注入到 Pod 内的 hosts 文件中。 该选项仅适用于没有配置 hostNetwork 的 Pod.

#### **Ingress**

Ingress 是对集群中服务的外部访问进行管理的 API 对象，典型的访问方式是 HTTP。 [[-\]](javascript:void(0))

Ingress 可以提供负载均衡、SSL 终结和基于名称的虚拟托管。

#### **Istio**

Istio 是个开放平台（非 Kubernetes 特有），提供了一种统一的方式来集成微服务、管理流量、实施策略和汇总度量数据。 [[-\]](javascript:void(0))

添加 Istio 时不需要修改应用代码。它是基础设施的一层，介于服务和网络之间。 当它和服务的 Deployment 相结合时，就构成了通常所谓的服务网格（Service Mesh）。 Istio 的控制面抽象掉了底层的集群管理平台，这一集群管理平台可以是 Kubernetes、Mesosphere 等。

#### **Job**

Job 是需要运行完成的确定性的或批量的任务。 [[-\]](javascript:void(0))

Job 创建一个或多个 [Pod](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/) 对象，并确保指定数量的 Pod 成功终止。 随着各 Pod 成功结束，Job 会跟踪记录成功完成的个数。

#### **Kops**

kops 是一个命令行工具，可以帮助您创建、销毁、升级和维护生产级，高可用性的 Kubernetes 集群。 [[-\]](javascript:void(0))

注意：官方仅支持 AWS，GCE 和 VMware vSphere 的支持还处于 alpha* 阶段。

`kops` 为您的集群提供了：

- 全自动化安装
- 基于 DNS 的集群标识
- 自愈功能：所有组件都在自动伸缩组（Auto-Scaling Groups）中运行
- 有限的操作系统支持 (推荐使用 Debian，支持 Ubuntu 16.04，试验性支持 CentOS & RHEL)
- 高可用 (HA) 支持
- 直接提供或者生成 Terraform 清单文件的能力

您也可以将自己的集群作为一个构造块，使用 [Kubeadm](https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/) 构造集群。`kops` 是建立在 kubeadm 之上的。

#### **kube-apiserver**

API 服务器是 Kubernetes [控制面](https://kubernetes.io/zh/docs/reference/glossary/?all=true#term-control-plane)的组件， 该组件公开了 Kubernetes API。 API 服务器是 Kubernetes 控制面的前端。 [[-\]](javascript:void(0))

Kubernetes API 服务器的主要实现是 [kube-apiserver](https://kubernetes.io/zh/docs/reference/command-line-tools-reference/kube-apiserver/)。 kube-apiserver 设计上考虑了水平伸缩，也就是说，它可通过部署多个实例进行伸缩。 你可以运行 kube-apiserver 的多个实例，并在这些实例之间平衡流量。

#### **kube-controller-manager**

运行[控制器](https://kubernetes.io/zh/docs/concepts/architecture/controller/)进程的控制平面组件。 [[-\]](javascript:void(0))

从逻辑上讲，每个[控制器](https://kubernetes.io/zh/docs/concepts/architecture/controller/)都是一个单独的进程， 但是为了降低复杂性，它们都被编译到同一个可执行文件，并在一个进程中运行。

#### **kube-proxy**

[kube-proxy](https://kubernetes.io/zh/docs/reference/command-line-tools-reference/kube-proxy/) 是集群中每个节点上运行的网络代理， 实现 Kubernetes [服务（Service）](https://kubernetes.io/zh/docs/concepts/services-networking/service/) 概念的一部分。 [[-\]](javascript:void(0))

kube-proxy 维护节点上的网络规则。这些网络规则允许从集群内部或外部的网络会话与 Pod 进行网络通信。

如果操作系统提供了数据包过滤层并可用的话，kube-proxy 会通过它来实现网络规则。否则， kube-proxy 仅转发流量本身。

#### **kube-scheduler**

控制平面组件，负责监视新创建的、未指定运行[节点（node）](https://kubernetes.io/zh/docs/concepts/architecture/nodes/)的 [Pods](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/)，选择节点让 Pod 在上面运行。 [[-\]](javascript:void(0))

调度决策考虑的因素包括单个 Pod 和 Pod 集合的资源需求、硬件/软件/策略约束、亲和性和反亲和性规范、数据位置、工作负载间的干扰和最后时限。

#### **Kubeadm**

用来快速安装 Kubernetes 并搭建安全稳定的集群的工具。 [[-\]](javascript:void(0))

你可以使用 kubeadm 安装控制面和 [工作节点](https://kubernetes.io/zh/docs/concepts/architecture/nodes/) 组件。



#### **Kubectl**

亦称作:*kubectl*
kubectl 是使用 Kubernetes API 与 Kubernetes 集群的[控制面](https://kubernetes.io/zh/docs/reference/glossary/?all=true#term-control-plane)进行通信的命令行工具。 [[-\]](javascript:void(0))

你可以使用 `kubectl` 创建、检视、更新和删除 Kubernetes 对象。



#### **Kubelet**

一个在集群中每个[节点（node）](https://kubernetes.io/zh/docs/concepts/architecture/nodes/)上运行的代理。 它保证[容器（containers）](https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/#why-containers)都 运行在 [Pod](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/) 中。 [[-\]](javascript:void(0))

kubelet 接收一组通过各类机制提供给它的 PodSpecs，确保这些 PodSpecs 中描述的容器处于运行状态且健康。 kubelet 不会管理不是由 Kubernetes 创建的容器。

#### **Kubernetes API**

Kubernetes API 是通过 RESTful 接口提供 Kubernetes 功能服务并负责集群状态存储的应用程序。 [[-\]](javascript:void(0))

Kubernetes 资源和"意向记录"都是作为 API 对象储存的，并可以通过调用 RESTful 风格的 API 进行修改。 API 允许以声明方式管理配置。 用户可以直接和 Kubernetes API 交互，也可以通过 `kubectl` 这样的工具进行交互。 核心的 Kubernetes API 是很灵活的，可以扩展以支持定制资源。

#### **LimitRange**

提供约束来限制命名空间中每个 [容器（Containers）](https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/#why-containers) 或 [Pod](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/) 的资源消耗。 [[-\]](javascript:void(0))

LimitRange 按照类型来限制命名空间中对象能够创建的数量，以及单个 [容器（Containers）](https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/#why-containers) 或 [Pod](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/) 可以请求/使用的计算资源量。

#### **Master**

遗留术语，作为运行 [控制平面](https://kubernetes.io/zh/docs/reference/glossary/?all=true#term-control-plane) 的 [节点](https://kubernetes.io/zh/docs/concepts/architecture/nodes/) 的同义词使用。 [[-\]](javascript:void(0))

该术语仍被一些配置工具使用，如 [kubeadm](https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/) 以及托管的服务，为 [节点（nodes）](https://kubernetes.io/zh/docs/concepts/architecture/nodes/) 添加 `kubernetes.io/role` 的 [标签（label）](https://kubernetes.io/zh/docs/concepts/overview/working-with-objects/labels/)，以及管理控制平面 Pod 的调度。

#### **Minikube**

Minikube 是用来在本地运行 Kubernetes 的一种工具。 [[-\]](javascript:void(0))

Minikube 在用户计算机上的一个虚拟机内运行单节点 Kubernetes 集群。 你可以使用 Minikube [在学习环境中尝试 Kubernetes](https://kubernetes.io/zh/docs/setup/learning-environment/).

#### **Operator 模式**

[operator 模式](https://kubernetes.io/zh/docs/concepts/extend-kubernetes/operator/) 是一种系统设计, 将 [控制器（Controller）](https://kubernetes.io/zh/docs/concepts/architecture/controller/) 关联到一个或多个自定义资源。 [[-\]](javascript:void(0))

除了使用作为 Kubernetes 自身一部分的内置控制器之外，你还可以通过 将控制器添加到集群中来扩展 Kubernetes。

如果正在运行的应用程序能够充当控制器并通过 API 访问的方式来执行任务操控 那些在控制平面中定义的自定义资源，这就是一个 operator 模式的示例。

#### **Pod**

Pod 是 Kubernetes 的原子对象。Pod 表示您的集群上一组正在运行的[容器（containers）](https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/#why-containers)。 [[-\]](javascript:void(0))

通常创建 Pod 是为了运行单个主容器。Pod 还可以运行可选的边车（sidecar）容器，以添加诸如日志记录之类的补充特性。通常用 [Deployment](https://kubernetes.io/zh/docs/concepts/workloads/controllers/deployment/) 来管理 Pod。

#### **Pod Disruption Budget**

亦称作:*PDB*
[Pod 干扰预算（Pod Disruption Budget，PDB）](https://kubernetes.io/zh/docs/concepts/workloads/pods/disruptions/) 使应用所有者能够为多实例应用创建一个对象，来确保一定数量的具有指定标签的 Pod 在任何时候都不会被主动驱逐。 [[+\]](javascript:void(0))

#### **Pod 优先级（Pod Priority）**

Pod 优先级表示一个 [Pod](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/) 相对于其他 Pod 的重要性。 [[-\]](javascript:void(0))

[Pod 优先级](https://kubernetes.io/zh/docs/concepts/scheduling-eviction/pod-priority-preemption/#pod-priority) 允许用户为 Pod 设置高于或低于其他 Pod 的优先级 -- 这对于生产集群 工作负载而言是一个重要的特性。

#### **Pod 安全策略**

为 [Pod](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/) 的创建和更新操作启用细粒度的授权。 [[-\]](javascript:void(0))

Pod 安全策略是集群级别的资源，它控制着 Pod 规约中的安全性敏感的内容。 `PodSecurityPolicy`对象定义了一组条件以及相关字段的默认值，Pod 运行时必须满足这些条件。Pod 安全策略控制实现上体现为一个可选的准入控制器。

#### **Pod 干扰**

[pod 干扰](https://kubernetes.io/zh/docs/concepts/workloads/pods/disruptions/) 是指节点上的 pod 被自愿或非自愿终止的过程。 [[-\]](javascript:void(0))

自愿干扰是由应用程序所有者或集群管理员有意启动的。非自愿干扰是无意的，可能由不可避免的问题触发，如节点耗尽资源或意外删除。

#### **Pod 水平自动扩缩器（Horizontal Pod Autoscaler）**

亦称作:*HPA*
Horizontal Pod Autoscaler（Pod 水平自动扩缩器）是一种 API 资源，它根据目标 CPU 利用率或自定义度量目标扩缩 Pod 副本的数量。 [[-\]](javascript:void(0))

HPA 通常用于 [ReplicationControllers](https://kubernetes.io/zh/docs/reference/glossary/?all=true#term-replication-controller) 、[Deployments](https://kubernetes.io/zh/docs/concepts/workloads/controllers/deployment/) 或者 [ReplicaSets](https://kubernetes.io/zh/docs/concepts/workloads/controllers/replicaset/) 上。 HPA 不能用于不支持扩缩的对象，例如 [DaemonSets](https://kubernetes.io/zh/docs/concepts/workloads/controllers/daemonset/)。

#### **Pod 生命周期**

关于 Pod 在其生命周期中处于哪个阶段的更高层次概述。 [[-\]](javascript:void(0))

[Pod 生命周期](https://kubernetes.io/zh/docs/concepts/workloads/pods/pod-lifecycle/) 是关于 Pod 处于哪个阶段的概述。包含了下面5种可能的的阶段: Running、Pending、Succeeded、 Failed、Unknown。关于 Pod 的阶段的更高级描述请查阅 [PodStatus](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#podstatus-v1-core) `phase` 字段。

#### **QoS 类（QoS Class）**

QoS Class（Quality of Service Class）为 Kubernetes 提供了一种将集群中的 Pod 分为几个类型并做出有关调度和驱逐决策的方法。 [[-\]](javascript:void(0))

Pod 的 QoS 类是基于 Pod 在创建时配置的计算资源请求和限制。QoS 类用于制定有关 Pod 调度和逐出的决策。 Kubernetes 可以为 Pod 分配以下 QoS 类：`Guaranteed`，`Burstable` 或者 `BestEffort`。

#### **ReplicaSet**

ReplicaSet 是下一代副本控制器。 [[-\]](javascript:void(0))

ReplicaSet 就像 ReplicationController 那样，确保一次运行指定数量的 Pod 副本。ReplicaSet 支持新的基于集合的选择器需求（在标签的用户指南中有相关描述），而副本控制器只支持基于等值的选择器需求。

#### **Secret**

Secret 用于存储敏感信息，如密码、 OAuth 令牌和 SSH 密钥。 [[-\]](javascript:void(0))

Secret 允许用户对如何使用敏感信息进行更多的控制，并减少信息意外暴露的风险。 默认情况下，Secret 值被编码为 base64 字符串并以非加密的形式存储，但可以配置为 [静态加密（Encrypt at rest）](https://kubernetes.io/zh/docs/tasks/administer-cluster/encrypt-data/#ensure-all-secrets-are-encrypted)。 [Pod](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/) 通过挂载卷中的文件的方式引用 Secret，或者通过 kubelet 为 pod 拉取镜像时引用。 Secret 非常适合机密数据使用，而 [ConfigMaps](https://kubernetes.io/zh/docs/tasks/configure-pod-container/configure-pod-configmap/) 适用于非机密数据。

#### **ServiceAccount**

为在 [Pod](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/) 中运行的进程提供标识。 [[-\]](javascript:void(0))

当 Pod 中的进程访问集群时，API 服务器将它们作为特定的服务帐户进行身份验证， 例如 `default` ，创建 Pod 时，如果你没有指定服务帐户，它将自动被赋予同一个 [名字空间](https://kubernetes.io/zh/docs/concepts/overview/working-with-objects/namespaces/)中的 default 服务账户。

#### **StatefulSet**

StatefulSet 用来管理某 [Pod](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/) 集合的部署和扩缩， 并为这些 Pod 提供持久存储和持久标识符。 [[-\]](javascript:void(0))

和 [Deployment](https://kubernetes.io/zh/docs/concepts/workloads/controllers/deployment/) 类似， StatefulSet 管理基于相同容器规约的一组 Pod。但和 Deployment 不同的是， StatefulSet 为它们的每个 Pod 维护了一个有粘性的 ID。这些 Pod 是基于相同的规约来创建的， 但是不能相互替换：无论怎么调度，每个 Pod 都有一个永久不变的 ID。

如果希望使用存储卷为工作负载提供持久存储，可以使用 StatefulSet 作为解决方案的一部分。 尽管 StatefulSet 中的单个 Pod 仍可能出现故障， 但持久的 Pod 标识符使得将现有卷与替换已失败 Pod 的新 Pod 相匹配变得更加容易。

#### **StorageClass**

StorageClass 是管理员用来描述不同的可用存储类型的一种方法。 [[-\]](javascript:void(0))

StorageClass 可以映射到服务质量等级（QoS）、备份策略、或者管理员任意定义的策略。 每个 StorageClass 对象包含的字段有 `provisioner`、`parameters` 和 `reclaimPolicy`。 动态制备该存储类别的[持久卷](https://kubernetes.io/zh/docs/concepts/storage/persistent-volumes/)时需要用到这些字段值。 通过设置 StorageClass 对象的名称，用户可以请求特定存储类别。

#### **UID**

Kubernetes 系统生成的字符串，唯一标识对象。 [[-\]](javascript:void(0))

在 Kubernetes 集群的整个生命周期中创建的每个对象都有一个不同的 uid，它旨在区分类似实体的历史事件。

#### **上游（Uptream）**

可能指的是：核心 Kubernetes 仓库或作为当前仓库派生来源的仓库。 [[-\]](javascript:void(0))

- 在 **Kubernetes社区**：对话中通常使用 *upstream* 来表示核心 Kubernetes 代码库，也就是更广泛的 kubernetes 生态系统、其他代码或第三方工具所依赖的仓库。 例如，[社区成员](https://kubernetes.io/zh/docs/reference/glossary/?all=true#term-member)可能会建议将某个功能特性贡献到 upstream，使其位于核心代码库中，而不是维护于插件或第三方工具中。
- 在 **GitHub** 或 **git** 中：约定是将源仓库称为 *upstream*，而派生的仓库则被视为 *downstream*。

#### **下游（Downstream）**

可以指：Kubernetes 生态系统中依赖于核心 Kubernetes 代码库或分支代码库的代码。 [[-\]](javascript:void(0))

- 在 **Kubernetes 社区**中：*下游(downstream)* 在人们交流中常用来表示那些依赖核心 Kubernetes 代码库的生态系统、代码或者第三方工具。例如，Kubernete 的一个新特性可以被*下游(downstream)* 应用采用，以提升它们的功能性。
- 在 **GitHub** 或 **git** 中：约定用*下游(downstream)* 表示分支代码库，源代码库被认为是*上游(upstream)*。

#### **临时容器（Ephemeral Container）**

您可以在 [Pod](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/) 中临时运行的一种 [容器（Container）](https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/#why-containers) 类型。 [[-\]](javascript:void(0))

如果想要调查运行中有问题的 Pod，可以向该 Pod 添加一个临时容器并进行诊断。 临时容器没有资源或调度保证，因此不应该使用它们来运行任何部分的工作负荷本身。

#### **事件（Event）**

每个 Event 是[集群](https://kubernetes.io/zh/docs/reference/glossary/?all=true#term-cluster)中某处发生的事件的报告。 它通常用来表述系统中的某种状态变化。 [[-\]](javascript:void(0))

事件的保留时间有限，随着时间推进，其触发方式和消息都可能发生变化。 事件用户不应该对带有给定原因（反映下层触发源）的时间特征有任何依赖， 也不要寄希望于对应该原因的事件会一直存在。

事件应该被视为一种告知性质的、尽力而为的、补充性质的数据。

在 Kubernetes 中，[审计](https://kubernetes.io/zh/docs/tasks/debug-application-cluster/audit/) 机制会生成一种不同种类的 Event 记录（API 组为 `audit.k8s.io`）。

#### **云供应商（Cloud Provider）**

亦称作:*云服务供应商（Cloud Service Provider）*
一个提供云计算平台的商业机构或其他组织。 [[-\]](javascript:void(0))

云供应商，有时也称作云服务供应商（CSPs）提供云计算平台或服务。

很多云供应商提供托管的基础设施（也称作基础设施即服务或 IaaS）。 针对托管的基础设施，云供应商负责服务器、存储和网络，而用户（你） 负责管理其上运行的各层软件，例如运行一个 Kubernetes 集群。

你也会看到 Kubernetes 被作为托管服务提供；有时也称作平台即服务或 PaaS。 针对托管的 Kubernetes，你的云供应商负责 Kubernetes 的控制面以及 [节点](https://kubernetes.io/zh/docs/concepts/architecture/nodes/) 及他们所依赖的基础设施： 网络、存储以及其他一些诸如负载均衡器之类的元素。

#### **云原生计算基金会（CNCF）**

云原生计算基金会（CNCF）建立了可持续的生态系统，并在围绕着 [项目](https://www.cncf.io/projects/) 建立一个社区，将容器编排微服务架构的一部分。 Kubernetes 是一个云原生计算基金会项目. [[-\]](javascript:void(0))

云原生计算基金会（CNCF）是 [Linux 基金会](https://www.linuxfoundation.org/) 的下属基金会。它的使命是让云原生计算无处不在。

#### **云控制器管理器（Cloud Controller Manager）**

云控制器管理器是指嵌入特定云的控制逻辑的 [控制平面](https://kubernetes.io/zh/docs/reference/glossary/?all=true#term-control-plane)组件。 云控制器管理器使得你可以将你的集群连接到云提供商的 API 之上， 并将与该云平台交互的组件同与你的集群交互的组件分离开来。 [[-\]](javascript:void(0))

通过分离 Kubernetes 和底层云基础设置之间的互操作性逻辑， 云控制器管理器组件使云提供商能够以不同于 Kubernetes 主项目的 步调发布新特征。

#### **亲和性（Affinity）**

在 Kubernetes 中，_亲和性（affinity）_是一组规则，它们为调度程序提供在何处放置 Pods 提示信息。 [[-\]](javascript:void(0))

亲和性有两种：

- [节点亲和性](https://kubernetes.io/zh/docs/concepts/scheduling-eviction/assign-pod-node/#node-affinity)
- [Pod 间亲和性](https://kubernetes.io/zh/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity)

这些规则是使用 Kubernetes [标签](https://kubernetes.io/zh/docs/concepts/overview/working-with-objects/labels/)（label） 和 [pods](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/) 中指定的 [选择算符](https://kubernetes.io/zh/docs/concepts/overview/working-with-objects/labels/)定义的， 这些规则可以是必需的或首选的，这取决于你希望调度程序执行它们的严格程度。

#### **代理（Proxy）**

在计算机领域，代理指的是充当远程服务中介的服务器。 [[-\]](javascript:void(0))

客户端与代理进行交互；代理将客户端的数据复制到实际服务器；实际服务器回复代理；代理将实际服务器的回复发送给客户端。

[kube-proxy](https://kubernetes.io/zh/docs/reference/command-line-tools-reference/kube-proxy/) 是集群中每个节点上运行的网络代理，实现了部分 Kubernetes [服务（Service）](https://kubernetes.io/zh/docs/concepts/services-networking/service/) 概念。

你可以将 kube-proxy 作为普通的用户态代理服务运行。 如果你的操作系统支持，则可以在混合模式下运行 kube-proxy；该模式使用较少的系统资源即可达到相同的总体效果。

**准入控制器（Admission Controller）**

在对象持久化之前拦截 Kubernetes Api 服务器请求的一段代码 [[+\]](javascript:void(0))

- 

  **初始化容器（Init Container）**

  应用[容器](https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/#why-containers)运行前必须先运行完成的一个或多个初始化容器。 [[+\]](javascript:void(0))

- 

  **副本控制器（Replication Controller）**

  一种工作管理多副本应用的负载资源，能够确保特定个数的 [Pod](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/) 实例处于运行状态。 [[+\]](javascript:void(0))

- 

  **动态卷供应（Dynamic Volume Provisioning）**

  允许用户请求自动创建存储 [卷](https://kubernetes.io/zh/docs/concepts/storage/volumes/)。 [[+\]](javascript:void(0))

- 

  **卷插件（Volume Plugin）**

  卷插件可以让 [Pod](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/) 集成存储。 [[+\]](javascript:void(0))

#### **卷（Volume）**

A directory containing data, accessible to the containers in a pod. aka: tags: - core-object - fundamental --- -- containers in a Pod. -- 包含可被 Pod 中容器访问的数据的目录。 每个 Kubernetes 卷在所处的 Pod 存在期间保持存在状态。 因此，卷的生命期会超出 Pod 中运行的容器， 并且保证容器重启之后仍保留数据。 更多信息可参考storage [[+\]](javascript:void(0))

#### **名字空间（Namespace）**

名字空间是 Kubernetes 用来支持隔离单个 [集群](https://kubernetes.io/zh/docs/reference/glossary/?all=true#term-cluster)中的资源组的一种抽象。 [[+\]](javascript:void(0))

#### **名称（Name）**

客户端提供的字符串，引用资源 url 中的对象，如`/api/v1/pods/some name`。 [[+\]](javascript:void(0))

#### **周期调度任务（CronJob）**

管理定期运行的 [任务](https://kubernetes.io/zh/docs/concepts/workloads/controllers/job/)。 [[+\]](javascript:void(0))

#### **垃圾收集**

垃圾收集是 Kubernetes 用于清理集群资源的各种机制的统称。 [[-\]](javascript:void(0))

Kubernetes 使用垃圾收集机制来清理资源，例如： [未使用的容器和镜像](https://kubernetes.io/zh/docs/concepts/workloads/controllers/garbage-collection/#containers-images)、 [失败的 Pod](https://kubernetes.io/zh/docs/concepts/workloads/pods/pod-lifecycle/#pod-garbage-collection)、 [目标资源拥有的对象](https://kubernetes.io/zh/docs/concepts/overview/working-with-objects/owners-dependents/)、 [已完成的 Job](https://kubernetes.io/zh/docs/concepts/workloads/controllers/ttlafterfinished/)、 过期或出错的资源。

#### **基于角色的访问控制（RBAC）**

管理授权决策，允许管理员通过 [Kubernetes API](https://kubernetes.io/zh/docs/concepts/overview/kubernetes-api/) 动态配置访问策略。 [[+\]](javascript:void(0))

#### **安全上下文（Security Context）**

securityContext 字段定义 [Pod](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/) 或 [容器](https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/#why-containers)的特权和访问控制设置。 [[-\]](javascript:void(0))

在一个 `securityContext` 字段中，你可以设置进程所属用户和用户组、权限相关设置。你也可以设置安全策略（例如：SELinux、AppArmor、seccomp）。

`PodSpec.securityContext` 字段配置会应用到一个 Pod 中的所有的 container 。

#### **容器存储接口（Container Storage Interface，CSI）**

容器存储接口 （CSI） 定义了存储系统暴露给容器的标准接口。 [[-\]](javascript:void(0))

CSI 允许存储驱动提供商为 Kubernetes 创建定制化的存储插件， 而无需将这些插件的代码添加到 Kubernetes 代码仓库（外部插件）。 要使用某个存储提供商的 CSI 驱动，你首先要 [将它部署到你的集群上](https://kubernetes-csi.github.io/docs/deploying.html)。 然后你才能创建使用该 CSI 驱动的 [Storage Class](https://kubernetes.io/zh/docs/concepts/storage/storage-classes/) 。

- [Kubernetes 文档中关于 CSI 的描述](https://kubernetes.io/zh/docs/concepts/storage/volumes/#csi)
- [可用的 CSI 驱动列表](https://kubernetes-csi.github.io/docs/drivers.html)

#### **容器环境变量（Container Environment Variables）**

容器环境变量提供了 name=value 形式的、在 [pod](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/) 中运行的容器所必须的一些重要信息。 [[-\]](javascript:void(0))

容器环境变量为运行中的容器化应用提供必要的信息，同时还提供与 [容器](https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/#why-containers) 重要资源相关的其他信息，例如：文件系统信息、容器自身的信息以及其他像服务端点（Service endpoints）这样的集群资源信息。javascript:void(0))

#### **容器生命周期钩子（Container Lifecycle Hooks）**

生命周期钩子暴露[容器](https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/#why-containers)管理生命周期中的事件，允许用户在事件发生时运行代码。 [[+\]](javascript:void(0))

#### **容器网络接口（CNI）**

容器网络接口 (CNI) 插件是遵循 appc/CNI 协议的一类网络插件。 [[+\]](javascript:void(0))

#### **容器运行时接口（CRI）**

容器运行时接口 (CRI) 是一组与节点上 kubelet 集成的容器运行时 API [[+\]](javascript:void(0))

#### **容器运行时（Container Runtime）**

容器运行环境是负责运行容器的软件。 [[+\]](javascript:void(0))

#### **容器（Container）**

容器是可移植、可执行的轻量级的镜像，包含其中的软件及其相关依赖。 [[+\]](javascript:void(0))

#### **容忍度（Toleration）**

一个核心对象，由三个必需的属性组成：key、value 和 effect。 容忍度允许将 Pod 调度到具有对应[污点](https://kubernetes.io/zh/docs/concepts/scheduling-eviction/taint-and-toleration/) 的节点或节点组上。 [[+\]](javascript:void(0))

#### **对象（Object）**

Kubernetes 系统中的实体。Kubernetes API 用这些实体表示集群的状态。 [[+\]](javascript:void(0))

#### **工作组（Working Group，WG）**

工作组是为了方便讨论和（或）推进执行一些短周期、窄范围、或者从委员会和 SIG 分离出来的项目、以及跨 SIG 的活动。 [[+\]](javascript:void(0))

#### **工作负载（Workload）**

工作负载是在 Kubernetes 上运行的应用程序。 [[+\]](javascript:void(0))

#### **干扰（Disruption）**

干扰是指导致一个或者多个 [Pod](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/) 服务停止的事件。 干扰会影响工作负载资源，比如 [Deployment](https://kubernetes.io/zh/docs/concepts/workloads/controllers/deployment/) 这种依赖于受影响 Pod 的资源。 [[+\]](javascript:void(0))

#### **平台开发人员（Platform Developer）**

定制 Kubernetes 平台以满足自己的项目需求的人。 [[+\]](javascript:void(0))

#### **应用开发者（Application Developer）**

编写可以在 Kubernetes 集群上运行的应用的人。 [[+\]](javascript:void(0))

#### **应用架构师（Application Architect）**

应用架构师是负责应用高级设计的人。 [[+\]](javascript:void(0))

#### **应用程序容器（App Container）**

应用程序 [容器](https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/#why-containers) （或 app 容器）在 [pod](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/) 中，在 [初始化容器](https://kubernetes.io/zh/docs/reference/glossary/?all=true#term-init-container) 启动完毕后才开始启动。 [[+\]](javascript:void(0))

#### **应用（Applications）**

The layer where various containerized applications run. aka: tags: - fundamental --- -- 各种容器化应用运行所在的层。 [[-\]](javascript:void(0))

各种容器化应用运行所在的层。

#### **抢占（Preemption）**

Kubernetes 中的抢占逻辑通过驱逐[节点（Node）](https://kubernetes.io/zh/docs/concepts/architecture/nodes/) 上的低优先级[Pod](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/) 来帮助悬决的 Pod 找到合适的节点。 [[+\]](javascript:void(0))

#### **持久卷申领（Persistent Volume Claim）**

申领[持久卷（PersistentVolume）](https://kubernetes.io/zh/docs/concepts/storage/persistent-volumes/)中定义的存储资源，以便可以将其挂载为[容器（container）](https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/#why-containers)中的卷。 [[+\]](javascript:void(0))

#### **持久卷（Persistent Volume）**

持久卷是代表集群中一块存储空间的 API 对象。 它是通用的、可插拔的、并且不受单个 [Pod](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/) 生命周期约束的持久化资源。 [[+\]](javascript:void(0))

#### **控制器（Controller）**

在 Kubernetes 中，控制器通过监控[集群](https://kubernetes.io/zh/docs/reference/glossary/?all=true#term-cluster) 的公共状态，并致力于将当前状态转变为期望的状态。 [[-\]](javascript:void(0))

控制器（[控制平面](https://kubernetes.io/zh/docs/reference/glossary/?all=true#term-control-plane)的一部分） 通过 [apiserver](https://kubernetes.io/zh/docs/reference/command-line-tools-reference/kube-apiserver/) 监控你的集群中的公共状态。

其中一些控制器是运行在控制平面内部的，对 Kubernetes 来说，他们提供核心控制操作。 比如：部署控制器（deployment controller）、守护控制器（daemonset controller）、 命名空间控制器（namespace controller）、持久化数据卷控制器（persistent volume controller）（等）都是运行在 [kube-controller-manager](https://kubernetes.io/docs/reference/generated/kube-controller-manager/) 中的。

#### **控制平面（Control Plane）**

控制平面（Control Plane）是指容器编排层，它暴露 API 和接口来定义、 部署容器和管理容器的生命周期。 [[-\]](javascript:void(0))

这个编排层是由多个不同的组件组成，例如以下（但不限于）几种：

- [etcd](https://kubernetes.io/zh/docs/tasks/administer-cluster/configure-upgrade-etcd/)
- [API 服务器](https://kubernetes.io/zh/docs/reference/command-line-tools-reference/kube-apiserver/)
- [调度器](https://kubernetes.io/zh/docs/reference/command-line-tools-reference/kube-scheduler/)
- [控制器管理器](https://kubernetes.io/docs/reference/generated/kube-controller-manager/)
- [云控制器管理器](https://kubernetes.io/zh/docs/concepts/architecture/cloud-controller/)

这些组件可以以传统的系统服务运行也可以以容器的形式运行.运行这些组件的主机过去称为 master 节点。

#### **控制组（cgroup）**

一组具有可选资源隔离、审计和限制的 Linux 进程。 [[-\]](javascript:void(0))

Cgroup 是一个 Linux 内核特性，对一组进程的资源使用（CPU、内存、磁盘 I/O 和网络等）进行限制、审计和隔离。

#### **数据平面（Data Plane）**

提供诸如 CPU，内存，网络和存储的能力，以便容器可以运行并连接到网络。 [[-\]](javascript:void(0))

#### **日志（Logging）**

日志是 [集群（cluster）](https://kubernetes.io/zh/docs/reference/glossary/?all=true#term-cluster) 或应用程序记录的事件列表。 [[-\]](javascript:void(0))

应用程序和系统日志可以帮助您了解集群内部发生的情况。日志对于调试问题和监视集群活动非常有用。

#### **服务代理（Service Broker）**

由第三方提供并维护的一组[托管服务](https://kubernetes.io/zh/docs/reference/glossary/?all=true#term-managed-service)的访问端点。 [[+\]](javascript:void(0))

#### **服务目录（Service Catalog）**

服务目录是一种扩展 API，它能让 Kubernetes 集群中运行的应用易于使用外部托管的的软件服务，例如云供应商提供的数据仓库服务。 [[+\]](javascript:void(0))

#### **服务（Service）**

将运行在一组 [Pods](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/) 上的应用程序公开为网络服务的抽象方法。 [[-\]](javascript:void(0))

服务所针对的 Pod 集（通常）由[选择算符](https://kubernetes.io/zh/docs/concepts/overview/working-with-objects/labels/)确定。 如果有 Pod 被添加或被删除，则与选择算符匹配的 Pod 集合将发生变化。 服务确保可以将网络流量定向到该工作负载的当前 Pod 集合。

#### **标签（Label）**

用来为对象设置可标识的属性标记；这些标记对用户而言是有意义且重要的。 [[-\]](javascript:void(0))

标签是一些关联到 [Pods](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/) 这类对象上的键值对。 它们通常用来组织和选择对象子集。

#### **污点（Taint）**

污点是一种一个核心对象，包含三个必需的属性：key、value 和 effect。 污点会阻止在[节点](https://kubernetes.io/zh/docs/concepts/architecture/nodes/) 或节点组上调度 [Pods](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/)。 [[-\]](javascript:void(0))

污点和[容忍度](https://kubernetes.io/zh/docs/concepts/scheduling-eviction/taint-and-toleration/)一起工作， 以确保不会将 Pod 调度到不适合的节点上。 同一[节点](https://kubernetes.io/zh/docs/concepts/architecture/nodes/)上可标记一个或多个污点。 节点应该仅调度那些带着能与污点相匹配容忍度的 Pod。

#### **注解（Annotation）**

注解是以键值对的形式给资源对象附加随机的无法标识的元数据。 [[-\]](javascript:void(0))

注解中的元数据可大可小，可以是结构化的也可以是非结构化的， 并且能包含[标签](https://kubernetes.io/zh/docs/concepts/overview/working-with-objects/labels/)不允许使用的字符。 像工具和软件库这样的客户端可以检索这些元数据。

#### **混排切片（Shuffle Sharding）**

混排切片（Shuffle Sharding）是指一种将请求指派给队列的技术，其隔离性好过对队列个数哈希取模的方式。 [[-\]](javascript:void(0))

我们通常会关心不同的请求序列间的相互隔离问题，目的是为了确保密度较高的 请求序列不会湮没密度较低的序列。 将请求放入不同队列的一种简单方法是对请求的某些特征值执行哈希函数， 将结果对队列的个数取模，从而得到要使用的队列的索引。 这一哈希函数使用请求的与其序列相对应的特征作为其输入。例如，在因特网上， 这一特征通常指的是由源地址、目标地址、协议、源端口和目标端口所组成的 五元组。

这种简单的基于哈希的模式有一种特性，高密度的请求序列（流）会湮没那些被 哈希到同一队列的其他低密度请求序列（流）。 为大量的序列提供较好的隔离性需要提供大量的队列，因此是有问题的。 混排切片是一种更为灵活的机制，能够更好地将低密度序列与高密度序列隔离。 混排切片的术语采用了对一叠扑克牌进行洗牌的类比，每个队列可类比成一张牌。 混排切片技术首先对请求的特定于所在序列的特征执行哈希计算，生成一个长度 为十几个二进制位或更长的哈希值。 接下来，用该哈希值作为信息熵的来源，对一叠牌来混排，并对整个一手牌（队列）来洗牌。 最后，对所有处理过的队列进行检查，选择长度最短的已检查队列作为请求的目标队列。 在队列数量适中的时候，检查所有已处理的牌的计算量并不大，对于任一给定的 低密度的请求序列而言，有相当的概率能够消除给定高密度序列的湮没效应。 当队列数量较大时，检查所有已处理队列的操作会比较耗时，低密度请求序列 消除一组高密度请求序列的湮没效应的机会也随之降低。因此，选择队列数目 时要颇为谨慎。

#### **清单（Manifest）**

JSON 或 YAML 格式的 Kubernetes API 对象规范。 [[-\]](javascript:void(0))

清单指定了在应用该清单时 kubernetes 将维护的对象的期望状态。每个配置文件可包含多个清单。

#### **特别兴趣小组（SIG）**

共同管理大范畴 Kubernetes 开源项目中某组件或方面的一组[社区成员](https://kubernetes.io/zh/docs/reference/glossary/?all=true#term-member)。 [[-\]](javascript:void(0))

SIG 中的成员对推进某个领域（如体系结构、API 机制构件或者文档）具有相同的兴趣。 SIGs 必须遵从 [governance guidelines](https://github.com/kubernetes/community/blob/master/committee-steering/governance/sig-governance.md) 的规定， 不过可以有自己的贡献策略以及通信渠道（方式）。

更多的详细信息可参阅 [kubernetes/community](https://github.com/kubernetes/community) 仓库以及 [SIGs 和工作组（Working Groups）](https://github.com/kubernetes/community/blob/master/sig-list.md)的最新列表。

#### **用户名字空间**

用来模拟 root 用户的内核功能特性。用来支持“Rootless 容器”。 [[-\]](javascript:void(0))

用户名字空间（User Namespace）是一种 Linux 内核功能特性，允许非 root 用户 模拟超级用户（"root"）的特权，例如用来运行容器却不必成为容器之外的超级用户。

用户名字空间对于缓解因潜在的容器逃逸攻击而言是有效的。

在用户名字空间语境中，名字空间是 Linux 内核的功能特性而不是 Kubernetes 意义上的 [名字空间](https://kubernetes.io/zh/docs/concepts/overview/working-with-objects/namespaces/)概念。

#### **端点（Endpoints）**

端点负责记录与服务的[选择器](https://kubernetes.io/zh/docs/concepts/overview/working-with-objects/labels/)相匹配的 Pods 的 IP 地址。 [[-\]](javascript:void(0))

端点可以手动配置到[服务（Service）](https://kubernetes.io/zh/docs/concepts/services-networking/service/)上，而不必指定选择器标识。

[EndpointSlice](https://kubernetes.io/zh/docs/concepts/services-networking/endpoint-slices/)提供了一种可伸缩、可扩展的替代方案。

#### **网络策略**

网络策略是一种规范，规定了允许 Pod 组之间、Pod 与其他网络端点之间以怎样的方式进行通信。 [[-\]](javascript:void(0))

网络策略帮助您声明式地配置允许哪些 Pod 之间接、哪些命名空间之间允许进行通信，并具体配置了哪些端口号来执行各个策略。`NetworkPolicy` 资源使用标签来选择 Pod，并定义了所选 Pod 可以接受什么样的流量。网络策略由网络提供商提供的并被 Kubernetes 支持的网络插件实现。请注意，当没有控制器实现网络资源时，创建网络资源将不会生效。

#### **聚合层（Aggregation Layer）**

聚合层允许您在自己的集群上安装额外的 Kubernetes 风格的 API。 [[-\]](javascript:void(0))

当您配置了 [Kubernetes API Server](https://kubernetes.io/zh/docs/reference/command-line-tools-reference/kube-apiserver/) 来 [支持额外的 API](https://kubernetes.io/zh/docs/tasks/extend-kubernetes/configure-aggregation-layer/)，您就可以在 Kubernetes API 中增加 `APIService` 对象来 "申领（Claim）" 一个 URL 路径。

#### **节点压力驱逐**

亦称作:*kubelet eviction*
节点压力驱逐是 [kubelet](https://kubernetes.io/docs/reference/generated/kubelet) 主动终止 Pod 以回收节点上资源的过程。 [[-\]](javascript:void(0))

kubelet 监控集群节点上的 CPU、内存、磁盘空间和文件系统 inode 等资源。 当这些资源中的一个或多个达到特定消耗水平时， kubelet 可以主动使节点上的一个或多个 Pod 失效，以回收资源并防止饥饿。

节点压力驱逐不用于 [API 发起的驱逐](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/)。

#### **节点（Node）**

Kubernetes 中的工作机器称作节点。 [[-\]](javascript:void(0))

工作机器可以是虚拟机也可以是物理机，取决于集群的配置。 其上部署了运行 [Pods](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/) 所必需的本地守护进程或服务， 并由主控组件来管理。 节点上的的守护进程包括 [kubelet](https://kubernetes.io/docs/reference/generated/kubelet)、 [kube-proxy](https://kubernetes.io/zh/docs/reference/command-line-tools-reference/kube-proxy/) 以及一个 [Docker](https://kubernetes.io/zh/docs/reference/kubectl/docker-cli-to-kubectl/) 这种 实现了 [CRI](https://kubernetes.io/zh/docs/concepts/overview/components/#container-runtime) 的容器运行时。

在早期的 Kubernetes 版本中，节点也称作 "Minions"。

#### **设备插件（Device Plugin）**

设备插件工作在节点主机上，给 [Pods](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/) 提供访问资源的权限，比如特定厂商初始化或者安装的本地硬件。 [[-\]](javascript:void(0))

设备插件将资源告知 [kubelet](https://kubernetes.io/docs/reference/generated/kubelet) ，以便相关节点上运行的工作负载Pod可以访问硬件功能。

更多信息请查阅[设备插件](https://kubernetes.io/zh/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/)

#### **证书（Certificate）**

证书是个安全加密文件，用来确认对 Kubernetes 集群访问的合法性。 [[-\]](javascript:void(0))

证书可以让 Kubernetes 集群中运行的应用程序安全的访问 Kubernetes API。证书可以确认客户端是否被允许访问 API。

#### **资源配额（Resource Quotas）**

资源配额提供了限制每个 [命名空间](https://kubernetes.io/zh/docs/concepts/overview/working-with-objects/namespaces/) 的资源消耗总和的约束。 [[-\]](javascript:void(0))

限制了命名空间中每种对象可以创建的数量，也限制了项目中可被资源对象利用的计算资源总数。

#### **选择算符（Selector）**

选择算符允许用户通过[标签（labels）](https://kubernetes.io/zh/docs/concepts/overview/working-with-objects/labels/)对一组资源对象进行筛选过滤。 [[-\]](javascript:void(0))

在查询资源列表时，选择算符可以通过标签对资源进行过滤筛选。

#### **量纲（Quantity）**

使用全数字来表示较小数值或使用 [SI](https://zh.wikipedia.org/wiki/International_System_of_Units) 后缀表示较大数值的表示法。 [[-\]](javascript:void(0))

量纲是使用紧凑的全数字表示法来表示小数值或带有国际计量单位制（SI） 的大数值的表示法。 小数用 milli 单位表示，而大数用 kilo、mega 或 giga 单位表示。

例如，数字 `1.5` 表示为 `1500m`， 而数字 `1000` 表示为 `1k`，`1000000` 表示为 `1M`。 你还可以指定二进制表示法后缀；数字 2048 可以写成 `2Ki`。

公认的十进制（10 的幂数）单位是 `m`（milli）、`k`（kilo，有意小写）、 `M`（mega）、`G`（giga）、`T`（terra）、`P`（peta）、`E`（exa）。

公认的二进制（2 的幂数）单位是 `Ki` (kibi)、`Mi` (mebi)、`Gi` (gibi)、 `Ti` (tebi)、 `Pi` (pebi)、 `Ei` (exbi)

#### **镜像（Image）**

镜像是保存的[容器](https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/#why-containers)实例，它打包了应用运行所需的一组软件。 [[-\]](javascript:void(0))

镜像是软件打包的一种方式，可以将镜像存储在容器镜像仓库、拉取到本地系统并作为应用来运行。 镜像中包含的元数据指明了运行什么可执行程序、是由谁构建的以及其他信息。javascript:void(0))

[安装附加组件](https://kubernetes.io/zh/docs/concepts/cluster-administration/addons/) 阐释了更多关于如何在集群内使用附加组件，并列出了一些流行的附加组件。

#### **集群（Cluster）**

集群由一组被称作节点的机器组成。这些节点上运行 Kubernetes 所管理的容器化应用。集群具有至少一个工作节点。 [[-\]](javascript:void(0))

工作节点托管作为应用负载的组件的 Pod 。控制平面管理集群中的工作节点和 Pod 。 为集群提供故障转移和高可用性，这些控制平面一般跨多主机运行，集群跨多个节点运行。

#### **静态 Pod（Static Pod）**

由特定节点上的 kubelet 守护进程直接管理的 [pod](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/)， [[-\]](javascript:void(0))

API 服务器不了解它的存在。

#### **驱逐**

驱逐即终止节点上一个或多个 Pod 的过程。 [[-\]](javascript:void(0))

驱逐的两种类型

- [节点压力驱逐](https://kubernetes.io/zh/docs/concepts/scheduling-eviction/pod-priority-preemption/)
- [API 发起的驱逐](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/)

### Traefik

#### Traefik是啥？

Traefic可以等价于Nginx，它是一个边缘路由器会拦截外部的请求并根据逻辑规则选择不同的操作方式，这些规则决定着这些请求到底该如何处理。Traefik提供自动发现能力，会实时检测服务，并自动更新路由规则。

![img](images/98aa36bc6341e5dd9e48b8e4ef2f1954.jpg)

#### Traefic技术架构

![img](images/ad012ad170058a5163b9ca9d8459c59f.jpg)

请求首先会连接到entrypoints，然后分析这些请求是否与定义的rules匹配，如果匹配，则会通过一系列middlewares，再到对应的services上。这就涉及到以下几个重要的核心组件：

> | 组件        | 功能                                                         |
> | ----------- | ------------------------------------------------------------ |
> | Providers   | Providers是基础组件，Traefik的配置发现是通过它来实现的，它可以是协调器，容器引擎，云提供商或者键值存储。Traefik通过查询Providers的API来查询路由的相关信息，一旦检测到变化，就会动态的更新路由。 |
> | Entrypoints | Entrypoints是Traefik的网络入口，它定义接收请求的接口，以及是否监听TCP或者UDP。 |
> | Routers     | Routers主要用于分析请求，并负责将这些请求连接到对应的服务上去，在这个过程中，Routers还可以使用Middlewares来更新请求，比如在把请求发到服务之前添加一些Headers。 |
> | Services    | Services负责配置如何到达最终将处理传入请求的实际服务。       |
> | Middlewares | Middlewares用来修改请求或者根据请求来做出一些判断(authentication, rate limiting, headers, ...)，中间件被附件到路由上，是一种在请求发送到你的服务之前(或者在服务的响应发送到客户端之前)调整请求的一种方法。 |

#### IngressRoute

https://github.com/xxradar/traefik_k8s_ingressrouter_learnings

## 消息中间件

### 基本概念

#### 死信

#### 延时队列

#### Stream

### Kafka

#### 数据存储架构

#### Kafka的脑裂问题

#### Address Space原理

#### 文件读写基本流程

#### mmap文件读写方式

#### PageCache的异步刷新策略

#### 零拷贝

Zero Copy对应的是sendfile这个函数（以Linux为例），这个函数接受

- out_fd作为输出（一般及时socket的句柄）
- in_fd作为输入文件句柄
- off_t表示in_fd的偏移（从哪里开始读取）
- size_t表示读取多少个

### RocketMQ

### Pulsar

#### 存储分离架构（优于Kafka）

pulsar相对于kafka来说，在存储上有优势，kafka的单个partition的存储容量受到了部署kafka的broker的硬盘容量限制，当有大量的数据需要MQ支持时，partition可能会遇到瓶颈而无法扩展。

Pulsar 的多层架构影响了存储数据的方式。Pulsar 将 topic 分区划分为分片（segment），然后将这些分片存储在 Apache BookKeeper 的存储节点上，以提高性能、可伸缩性和可用性。

### RabbitMQ

## RPC框架

### Dubbo

#### Dubbo 支持哪些协议，每种协议的应用场景，优缺点？

dubbo： 单一长连接和 NIO 异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议 TCP，异步， Hessian 序列化；

rmi： 采用 JDK 标准的 rmi 协议实现，传输参数和返回参数对象需要实现Serializable 接口，使用 java 标准序列化机制，使用阻塞式短连接，传输数据包大小混合，消费者和提供者个数差不多，可传文件，传输协议 TCP。多个短连接， TCP 协议传输，同步传输，适用常规的远程服务调用和 rmi 互操作。在依赖低版本的 Common-Collections 包， java 序列化存在安全漏洞；

http： 基于 Http 表单提交的远程调用协议，使用 Spring 的 HttpInvoke 实现。多个短连接，传输协议 HTTP，传入参数大小混合，提供者个数多于消费者，需要给应用程序和浏览器 JS 调用；

webservice： 基于 WebService 的远程调用协议，集成 CXF 实现，提供和原生 WebService 的互操作。多个短连接，基于 HTTP 传输，同步传输，适用系统集成和跨语言调用；

hessian： 集成 Hessian 服务，基于 HTTP 通讯，采用 Servlet 暴露服务，Dubbo 内嵌 Jetty 作为服务器时默认实现，提供与 Hession 服务互操作。多个短连接，同步 HTTP 传输， Hessian 序列化，传入参数较大，提供者大于消费者，提供者压力较大，可传文件；

Redis： 基于 Redis 实现的 RPC 协议

#### Dubbo 超时时间怎样设置？Dubbo 超时时间设置有两种方式：

服务提供者端设置超时时间，在 Dubbo 的用户文档中，推荐如果能服务端多配置就尽量多配置，因为服务提供者比消费者更清楚自己提供的服务特性。

服务消费者端设置超时时间，如果在消费者端设置了超时时间，以消费者端为主，即优先级更高。因为服务调用方设置超时时间控制性更灵活。如果消费方超时，服务端线程不会定制，会产生警R告。

#### Dubbo 有些哪些注册中心？

Multicast 注册中心： Multicast 注册中心不需要任何中心节点，只要广播地址，就能进行服务注册和发现。基于网络中组播传输实现；

Zookeeper 注册中心： 基于分布式协调系统 Zookeeper 实现，采用Zookeeper 的 watch 机制实现数据变更；

redis 注册中心： 基于 redis 实现，采用 key/Map 存储，住 key 存储服务名和类型， Map 中 key 存储服务 URL， value 服务过期时间。基于 redis 的发布/订阅模式通知数据变更；

Simple 注册中心

#### Dubbo 集群的负载均衡有哪些策略?Dubbo 提供了常见的集群策略实现，并预扩展点予以自行实现。

Random LoadBalance: 随机选取提供者策略，有利于动态调整提供者权重。截面碰撞率高，调用次数越多，分布越均匀；RoundRobin LoadBalance: 轮循选取提供者策略，平均分布，但是存在请求累积的问题；

LeastActive LoadBalance: 最少活跃调用策略，解决慢提供者接收更少的请求；

ConstantHash LoadBalance: 一致性 Hash 策略，使相同参数请求总是发到同一提供者，一台机器宕机，可以基于虚拟节点，分摊至其他提供者，避免引起提供者的剧烈变动；

#### Dubbo 是什么？

Dubbo 是一个分布式、高性能、透明化的 RPC 服务框架，提供服务自动注册、自动发现等高效服务治理方案， 可以和Spring 框架无缝集成

#### Dubbo 的主要应用场景？

· 透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何 API 侵入。

· 软负载均衡及容错机制，可在内网替代 F5 等硬件负载均衡器，降低成本，减少单点。

· 服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的 IP 地址，并且能够平滑添加或删除服务提供者。

#### 7. Dubbo 的核心功能？主要就是如下 3 个核心功能：

Remoting： 网络通信框架，提供对多种 NIO 框架抽象封装，包括“同步转异步”和“请求-响应”模式的信息交换方式。

Cluster：服务框架，提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。

Registry：服务注册，基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。

#### Dubbo 服务注册与发现的流程？

流程说明：

· Provider(提供者)绑定指定端口并启动服务

· 指供者连接注册中心，并发本机 IP、端口、应用信息和提供服务信息发送至注册中心存储

· Consumer(消费者），连接注册中心 ，并发送应用信息、所求服务信息至注册中心

· 注册中心根据 消费 者所求服务信息匹配对应的提供者列表发送至Consumer 应用缓存。

· Consumer 在发起远程调用时基于缓存的消费者列表择其一发起调用。

· Provider 状态变更会实时通知注册中心、在由注册中心实时推送至Consumer 设计的原因：

· Consumer 与 Provider 解偶，双方都可以横向增减节点数。

· 注册中心对本身可做对等集群，可动态增减节点，并且任意一台宕掉后，将自动切换到另一台

· 去中心化，双方不直接依懒注册中心，即使注册中心全部宕机短时间内也不会影响服务的调用

· 服务提供者无状态，任意一台宕掉后，不影响使用

#### Dubbo 的架构设计

Dubbo 框架设计一共划分了 10 个层：

· 服务接口层（ Service） ：该层是与实际业务逻辑相关的，根据服务提供方和服务消费方的业务设计对应的接口和实现。

· 配置层（ Config） ：对外配置接口，以 ServiceConfig 和ReferenceConfig 为中心。

· 服务代理层（ Proxy）：服务接口透明代理，生成服务的客户端 Stub和服务器端 Skeleton

· 服务注册层（ Registry） ：封装服务地址的注册与发现，以服务 URL为中心。

· 集群层（ Cluster） ：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心。

· 监控层（ Monitor） ： RPC 调用次数和调用时间监控。

· 远程调用层（ Protocol） ：封将 RPC 调用，以 Invocation 和 Result为中心，扩展接口为 Protocol、 Invoker 和 Exporter。

· 信息交换层（ Exchange） ：封装请求响应模式，同步转异步，以Request 和 Response 为中心。

· 网络传输层（ Transport） ：抽象 mina 和 netty 为统一接口，以Message 为中心。

#### Dubbo 的服务调用流程？

#### Dubbo 的核心组件？

#### 12. Dubbo 支持哪些协议，每种协议的应用场景，优缺点？

dubbo： 单一长连接和 NIO 异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议 TCP，异步， Hessian 序列化； rmi： 采用 JDK 标准的 rmi 协议实现，传输参数和返回参数对象需要实现 Serializable 接口，使用 java 标准序列化机制，使用阻塞式短连接，传输数据包大小混合，消费者和提供者个数差不多，可传文件，传输协议 TCP。 多个短连接， TCP 协议传输，同步传输，适用常规的远程服务调用和rmi 互操作。在依赖低版本的 Common-Collections包， java 序列化存在安全漏洞； webservice： 基于 WebService 的远程调用协议，集成 CXF 实现，提供和原生 WebService 的互操作。多个短连接，基于 HTTP 传输，同步传输，适用系统集成和跨语言调用； http： 基于 Http 表单提交的远程调用协议，使用 Spring 的HttpInvoke 实现。多个短连接，传输协议 HTTP，传入参数大小混合，提供者个数多于消费者，需要给应用程序和浏览器 JS 调用； hessian： 集成 Hessian 服务，基于 HTTP 通讯，采用 Servlet 暴露服务， Dubbo 内嵌 Jetty 作为服务器时默认实现，提供与 Hession 服务互操作。多个短连接，同步 HTTP 传输， Hessian 序列化，传入参数较大，提供者大于消费者，提供者压力较大，可传文件； memcache： 基于 memcached 实现的 RPC 协议 redis： 基于 redis 实现的 RPC 协议

#### 13. dubbo 推荐用什么协议？

默认使用 dubbo 协议

#### 14. Dubbo 有些哪些注册中心？

Multicast 注册中心： Multicast 注册中心不需要任何中心节点，只要广播地址，就能进行服务注册和发现。基于网络中组播传输实现；§ Zookeeper 注册中心： 基于分布式协调系统 Zookeeper 实现，采用Zookeeper 的 watch 机制实现数据变更；

redis 注册中心： 基于 redis 实现，采用 key/Map 存储，住 key 存储服务名和类型， Map 中 key 存储服务 URL， value 服务过期时间。基于 redis 的发布/订阅模式通知数据变更；

Simple 注册中心

#### Dubbo 默认采用注册中心？

采用 Zookeeper

#### 为什么需要服务治理？

· 过多的服务 URL 配置困难

· 负载均衡分配节点压力过大的情况下也需要部署集群§ 服务依赖混乱，启动顺序不清晰

· 过多服务导致性能指标分析难度较大，需要监控

#### Dubbo 的注册中心集群挂掉，发布者和订阅者之间还能通信么？

可以的，启动 dubbo 时，消费者会从 zookeeper 拉取注册的生产者的地址接口等数据，缓存在本地。 每次调用时，按照本地存储的地址进行调用。

#### Dubbo 与 Spring 的关系？

Dubbo 采用全 Spring 配置方式，透明化接入应用，对应用没有任何API 侵入，只需用 Spring 加载 Dubbo 的配置即可， Dubbo 基于Spring 的 Schema 扩展进行加载。

#### 19. Dubbo 使用的是什么通信框架?

默认使用 NIO Netty 框架 

#### Dubbo 集群提供了哪些负载均衡策略？

· Random LoadBalance: 随机选取提供者策略，有利于动态调整提供者权重。截面碰撞率高，调用次数越多，分布越均匀；

· RoundRobin LoadBalance: 轮循选取提供者策略，平均分布，但是存在请求累积的问题；§ LeastActive LoadBalance: 最少活跃调用策略，解决慢提供者接收更少的请求；

· ConstantHash LoadBalance: 一致性 Hash 策略，使相同参数请求总是发到同一提供者，一台机器宕机，可以基于虚拟节点，分摊至其他提供者，避免引起提供者的剧烈变动；

· 缺省时为 Random 随机调用

#### Dubbo 的集群容错方案有哪些？

Failover Cluster

· 失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。

Failfast Cluster

· 快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。

Failsafe Cluster

· 失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。

Failback Cluster

· 失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。

Forking Cluster

· 并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks="2" 来设置最大并行数。

Broadcast Cluster

· 广播调用所有提供者，逐个调用，任意一台报错则报错 。通常用于通知所有提供者更新缓存或日志等本地资源信息

#### 22. Dubbo 的默认集群容错方案？

Failover Cluster 

#### 23. Dubbo 支持哪些序列化方式？

默认使用 Hessian 序列化，还有 Duddo、 FastJson、 Java 自带序列化。

#### 24. Dubbo 超时时间怎样设置？

Dubbo 超时时间设置有两种方式：

· 服务提供者端设置超时时间，在 Dubbo 的用户文档中，推荐如果能在服务端多配置就尽量多配置，因为服务提供者比消费者更清楚自己提供的服务特性。

· 服务消费者端设置超时时间，如果在消费者端设置了超时时间，以消费者端为主，即优先级更高。因为服务调用方设置超时时间控制性更灵活。如果消费方超时，服务端线程不会定制，会产生警告。

#### 服务调用超时问题怎么解决？

Dubbo 在调用服务不成功时，默认是会重试两次的。

#### Dubbo 在安全机制方面是如何解决？

Dubbo 通过 Token 令牌防止用户绕过注册中心直连，然后在注册中心上管理授权。 Dubbo 还提供服务黑白名单，来控制服务所允许的调用方。

#### Dubbo 和 Dubbox 之间的区别？

dubbox 基于 dubbo 上做了一些扩展，如加了服务可 restful 调用，更新了开源组件等。

#### 28. Dubbo 和 Spring Cloud 的关系？

Dubbo 是 SOA 时代的产物，它的关注点主要在于服务的调用，流量分发、流量监控和熔断。而 Spring Cloud 诞生于微服务架构时代，考虑的是微服务治理的方方面面，另外由于依托了 Spirng、Spirng Boot 的优势之上，两个框架在开始目标就不一致， Dubbo定位服务治理、 Spirng Cloud 是一个生态。

#### 29. Dubbo 和 Spring Cloud 的区别？

最大的区别： Dubbo 底层是使用 Netty 这样的 NIO 框架，是基于TCP 协议传输的，配合以 Hession 序列化完成 RPC 通信。 而 SpringCloud 是基于 Http 协议+Rest 接口调用远程过程的通信，相对来说， Http 请求会有更大的报文，占的带宽也会更多。但是REST 相比 RPC 更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖。

## 分布式

### 基本理论

#### BASE理论是什么？

#### CAP定理是什么？

#### 为什么要做幂等性设计？

**我们实际系统中有很多操作，是不管做多少次，都应该产生一样的效果或返回一样的结果。 例如：** 

1. 前端重复提交选中的数据，应该后台只产生对应这个数据的一个反应结果。 
2. 我们发起一笔付款请求，应该只扣用户账户一次钱，当遇到网络重发或系统bug重发，也应该只扣一次钱； 
3. 发送消息，也应该只发一次，同样的短信发给用户，用户会哭的； 
4. 创建业务订单，一次业务请求只能创建一个，创建多个就会出大问题。 

幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。 在编程中，一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“getUsername()和setTrue()”函数就是一个幂等函数. 

#### 设计微服务时需要遵循什么原则？

#### 如何维护微服务间共享的Interface和DTO

#### 介绍一下RMI

DTO是微服务间的**通信契约**，与Feign/Dubbo的Interface放在一起。此处，我们使用一个公共包`bootstrap-api`来维护。

#### 什么是分布式一致性算法

- Paxos
- Raft
- ZAB
- Gossip

### 分布式ID

#### 雪花算法生成的ID有哪些部分组成？

#### 分布式ID生成方案有哪些？

### RPC

#### RPC调用原理？

#### 介绍下常用的令牌桶算法和漏桶算法

- 漏桶

  > 把请求比作是水，水来了都先放进桶里，并以限定的速度出水，当水来得过猛而出水不够快时就会导致水直接溢出，即拒绝服务。
  >
  > ![img](file:///Users/jerrylau/workspace/writting/whoiscat.com/knowledge/resume/images/1460000015967925.png?lastModify=1637145977)

- 令牌桶

  > 对于很多应用场景来说，除了要求能够限制数据的平均传输速率外，还要求**允许某种程度的突发传输**。这时候漏桶算法可能就不合适了，令牌桶算法更为适合。
  >
  > 令牌桶算法的原理是系统以恒定的速率产生令牌，然后把令牌放到令牌桶中，令牌桶有一个容量，当令牌桶满了的时候，再向其中放令牌，那么多余的令牌会被丢弃；当想要处理一个请求的时候，需要从令牌桶中取出一个令牌，如果此时令牌桶中没有令牌，那么则拒绝该请求。
  >
  > ![img](file:///Users/jerrylau/workspace/writting/whoiscat.com/knowledge/resume/images/1460000015967926.png?lastModify=1637145977)

### 流量控制

#### 计数器算法是什么？

#### 令牌桶限流算法是什么？

#### 漏桶限流算法是什么？

#### Sentinel实现原理

责任链模式

### 分布式锁

#### MySQL如何实现分布式锁？

#### Zookeeper和Redis做分布式锁的区别是什么？

#### 基于Zookeeper分布式锁实现的原理是什么？

#### Redis如何做分布式锁？什么时候会发生死锁，如何解决？

#### 分布式锁在项目中有哪些应用场景？

### 分布式事务

#### TCC/XA/AT/Saga几种分布式事务的比较

https://tech.antfin.com/community/activities/779/review/901

| 方案 | 业务侵入 | 全局锁 | 特点                                                         | 最终一致性 |
| ---- | -------- | ------ | ------------------------------------------------------------ | ---------- |
| TCC* | 是       | 否     | 2PC，性能高，容易理解，方案成熟                              | 是         |
| XA   | 否       | 是     | 2PC，事务分支是阻塞的，会一下锁多个表                        |            |
| AT*  | 否       | 是     | 基于XA改造                                                   |            |
| SAGA | 是       | 否     | 需要引入协调者，一般用MQ或业务系协调器，顺序执行事务分支 不能保证隔离性 | 是         |

#### 如何解决TCC幂等、空回滚、悬挂问题？

- 悬挂（cancel比try先执行）

  > Cancel 比 Try 接口先执行，出现的原因是 Try 由于网络拥堵而超时，事务管理器生成回滚，触发 Cancel 接口，而最终又收到了 Try 接口调用，但是 Cancel 比 Try 先到。按照前面允许空回滚的逻辑，回滚会返回成功，事务管理器认为事务已回滚成功，则此时的 Try 接口不应该执行，否则会产生数据不一致，所以我们在 Cancel 空回滚返回成功之前先记录该条事务 xid 或业务主键，标识这条记录已经回滚过，Try 接口先检查这条事务xid或业务主键如果已经标记为回滚成功过，则不执行 Try 的业务操作。

- 空回滚（try超时、丢包）

  > Cancel 接口设计时需要允许空回滚。在 Try 接口因为丢包时没有收到，事务管理器会触发回滚，这时会触发 Cancel 接口，这时 Cancel 执行时发现没有对应的事务 xid 或主键时，需要返回回滚成功。让事务服务管理器认为已回滚，否则会不断重试，而 Cancel 又没有对应的业务数据可以进行回滚。

- 幂等（try-catch-cancel都需要保证幂等性）

  > 对同一个系统，使用同样的条件，一次请求和重复的多次请求对系统资源的影响是一致的。因为网络抖动或拥堵可能会超时，事务管理器会对资源进行重试操作，所以很可能一个业务操作会被重复调用，为了不因为重复调用而多次占用资源，需要对服务设计时进行幂等控制，通常我们可以用事务 xid 或业务主键判重来控制。

#### TCC解决方案是什么？

TCC是Try、Confirm、Cancel三个词语的缩写，TCC要求每个分支事务实现三个操作：预处理Try、确认Confirm、撤销Cancel。Try操作做业务检查及资源预留，Confirm做业务确认操作，Cancel实现一个与Try相反的操作即回滚操作。TM首先发起所有的分支事务的try操作，任何一个分支事务的try操作执行失败，TM将会发起所有分支事务的Cancel操作，若try操作全部成功，TM将会发起所有分支事务的Confirm操作，其中Confirm/Cancel操作若执行失败，TM会进行重试。

![img](file:///Users/jerrylau/workspace/writting/whoiscat.com/knowledge/resume/images/1243133-20191101180737096-1636349878.png?lastModify=1637145977)

分支事务失败的情况：

![img](file:///Users/jerrylau/workspace/writting/whoiscat.com/knowledge/resume/images/1243133-20191101192717249-2033068949.png?lastModify=1637145977)

TCC分为三个阶段：

> 1. Try 阶段是做业务检查(一致性)及资源预留(隔离)，此阶段仅是一个初步操作，它和后续的Confirm 一起才能真正构成一个完整的业务逻辑。
> 2. Confirm 阶段是做确认提交，Try阶段所有分支事务执行成功后开始执行 Confirm。通常情况下，采用TCC则认为 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。若Confirm阶段真的出错了，需引入重试机制或人工处理。
> 3. Cancel 阶段是在业务执行错误需要回滚的状态下执行分支事务的业务取消，预留资源释放。通常情况下，采用TCC则认为Cancel阶段也是一定成功的。若Cancel阶段真的出错了，需引入重试机制或人工处理。

#### 什么是DTP分布式事务模型？

X/Open DTP(X/Open Distributed Transaction Processing Reference Model) 是X/Open 这个组织定义的一套分布式事务的标准，也就是了定义了规范和API接口，由这个厂商进行具体的实现。这个思想在java 平台里面到处都是。

X/Open DTP 定义了三个组件： AP，TM，RM

> AP(Application Program)：也就是应用程序，可以理解为使用DTP的程序
>
> RM(Resource Manager)：资源管理器，这里可以理解为一个DBMS系统，或者消息服务器管理系统，应用程序通过资源管理器对资源进行控制。资源必须实现XA定义的接口
>
> TM(Transaction Manager)：事务管理器，负责协调和管理事务，提供给AP应用程序编程接口以及管理资源管理器

其中，AP 可以和TM 以及 RM 通信，TM 和 RM 互相之间可以通信，DTP模型里面定义了XA接口，TM 和 RM 通过XA接口进行双向通信，例如:TM通知RM提交事务或者回滚事务，RM把提交结果通知给TM。AP和RM之间则通过RM提供的Native API 进行资源控制，这个没有进行约API和规范，各个厂商自己实现自己的资源控制，比如Oracle自己的数据库驱动程序。

![img](file:///Users/jerrylau/workspace/writting/whoiscat.com/knowledge/resume/images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzMyODIx,size_16,color_FFFFFF,t_70.png?lastModify=1637145977)

#### XA分布式协议

XA 规范 是 X/Open 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准。

XA 规范 描述了全局的事务管理器与局部的资源管理器之间的接口。 XA规范 的目的是允许的多个资源（如数据库，应用服务器，消息队列等）在同一事务中访问，这样可以使 ACID 属性跨越应用程序而保持有效。XA 规范 使用两阶段提交（2PC，Two-Phase Commit）来保证所有资源同时提交或回滚任何特定的事务。XA 规范 在上世纪 90 年代初就被提出。目前，几乎所有主流的数据库都对 XA 规范 提供了支持。

- XA协议语法

  > 三阶段的第一阶段：开启 xa 事务，这里 xid 为全局事务 id： XA {START|BEGIN} xid [JOIN|RESUME] 结束 xa 事务：XA END xid [SUSPEND [FOR MIGRATE]] 三阶段的第二阶段，即 prepare：XA PREPARE xid 三阶段的第三阶段，即 commit/rollback：XA COMMIT xid [ONE PHASE];XA ROLLBACK xid 查看处于 PREPARE 阶段的所有事务：XA RECOVER XA RECOVER [CONVERT XID]

#### 2PC和3PC提交协议是什么？

**两阶段提交（不支持NoSQL）**

分布式事务的两阶段提交是把整个事务提交分为 prepare 和 commit 两个阶段。以电商系统为例，分布式系统中有订单、账户和库存三个服务，如下图：

![1.png](file:///Users/jerrylau/workspace/writting/whoiscat.com/knowledge/resume/images/454228ca218640b690665d6c664b741a.png?lastModify=1637145977)

第一阶段，事务协调者向事务参与者发送 prepare 请求，事务参与者收到请求后，如果可以提交事务，回复 yes，否则回复 no。

第二阶段，如果所有事务参与者都回复了 yes，事务协调者向所有事务参与者发送 commit 请求，否则发送 rollback 请求。

两阶段提交存在三个问题：

- 同步阻塞，本地事务在 prepare 阶段锁定资源，如果有其他事务也要修改 xiaoming 这个账户，就必须等待前面的事务完成。这样就造成了系统性能下降。
- 协调节点单点故障，如果第一个阶段 prepare 成功了，但是第二个阶段协调节点发出 commit 指令之前宕机了，所有服务的数据资源处于锁定状态，事务将无限期地等待。
- 数据不一致，如果第一阶段 prepare 成功了，但是第二阶段协调节点向某个节点发送 commit 命令时失败，就会导致数据不一致。

**三阶段提交**

为了解决两阶段提交的问题，三阶段提交做了改进：

- 在协调节点和事务参与者都引入了超时机制。
- 第一阶段的 prepare 阶段分成了两步，canCommit 和 preCommit。

如下图：

![img](file:///Users/jerrylau/workspace/writting/whoiscat.com/knowledge/resume/images/1a07db6e5d6048c8b35bd56c9c2a75c0-20211015090615949.png?lastModify=1637145977)

引入 preCommit 阶段后，协调节点会在 commit 之前再次检查各个事务参与者的状态，保证它们的状态是一致的。但是也存在问题，那就是如果第三阶段发出 rollback 请求，有的节点没有收到，那没有收到的节点会在超时之后进行提交，造成数据不一致。

#### Saga分布式事务

*Saga* 设计模式是一种跨分布式事务方案中的微服务管理数据一致性的方式。 Saga 是一个事务序列，用于更新每个服务并发布消息或事件以触发下一个事务步骤。 如果某个步骤失败，saga 会执行补偿事务，这些事务会应对前面的事务。

Saga有何TCC类似的空补偿，悬挂问题。

![img](file:///Users/jerrylau/workspace/writting/whoiscat.com/knowledge/resume/images/webp?lastModify=1637145977)

Saga 模式使用 *本地事务* 序列来提供事务管理。 本地事务是 saga 参与者执行的原子工作工作量。 每个本地事务更新数据库，并发布消息或事件以触发 saga 中的下一个本地事务。 如果本地事务失败，saga 将执行一系列 *补偿事务* ，这些事务可撤消前面的本地事务所做的更改。

![Saga 概述。](file:///Users/jerrylau/workspace/writting/whoiscat.com/knowledge/resume/images/saga-overview.png?lastModify=1637145977)

在 saga 模式中：

- *可补偿事务* 是可以通过相反效果处理另一个事务的事务。
- *透视事务* 是 saga 中的 "中转"/"无" 点。 如果透视事务提交，saga 将一直运行，直到完成。 透视事务可以是既不是可补偿也不能重试的事务，也可以是 saga 中的最后一个可补偿事务或第一个可重试事务。
- 可重 *试事务* 是指在透视事务之后的事务，并保证其成功。

有两种常见的 saga 实现方法： *choreography* 和 *业务流程*。 每种方法都有其自己的一套挑战和技术来协调工作流。

- 协调

  > Choreography 是一种协调 sagas 的方法，在此方法中，参与者无需集中控制即可交换事件。 对于 choreography，每个本地事务都会发布触发其他服务中的本地事务的域事件。
  >
  > ![Choreography 概述](file:///Users/jerrylau/workspace/writting/whoiscat.com/knowledge/resume/images/choreography-pattern.png?lastModify=1637145977)
  >
  > 优点
  >
  > - 适用于需要少量参与者且不需要协调逻辑的简单工作流。
  > - 不需要额外的服务实现和维护。
  > - 不会引入单点故障，因为责任分布在 saga 参与者。
  >
  > 缺点
  >
  > - 添加新步骤时，工作流可能会令人感到困惑，因为这样做很难跟踪哪些 saga 参与者侦听哪些命令。
  > - Saga 参与者之间存在循环依赖关系，因为它们必须使用彼此的命令。
  > - 集成测试非常困难，因为所有服务都必须运行才能模拟事务。

- 业务流程

  > 业务流程是一种协调 sagas 的方式，其中集中式控制器告知 saga 参与者要执行的本地事务。 Saga orchestrator 处理所有事务，并告诉参与者基于事件执行哪个操作。 Orchestrator 执行 saga 请求，存储和解释每个任务的状态，并处理补偿事务的故障恢复。
  >
  > ![业务流程概述](file:///Users/jerrylau/workspace/writting/whoiscat.com/knowledge/resume/images/orchestrator.png?lastModify=1637145977)
  >
  > 优点
  >
  > - 适用于涉及多个参与者的复杂工作流或随时间推移增加的新参与者。
  > - 适用于控制过程中的每个参与者，并控制活动流的情况。
  > - 不会引入循环依赖关系，因为 orchestrator 单方面依赖于 saga 参与者。
  > - Saga 参与者无需知道其他参与者的命令。 清除问题分离可简化业务逻辑。
  >
  > 缺点
  >
  > - 其他设计复杂性要求实现协调逻辑。
  > - 还有一个额外的故障点，因为 orchestrator 管理完整的工作流。

saga模式无法保证隔离性，但性能很高。

#### Atomikos分布式事务

### 消息

#### 最大努力通知方案的关键是什么？

#### 可靠消息服务方案是什么？

### 幂等性设计

#### 如何实现幂等性设计？

1. 查询操作：查一次和查多次是天然幂等的

2. 删除操作：也是天然幂等的，一个资源不会被删除多次

3. 唯一索引约束：适用于唯一的情况，例如：每个人只有一个身份证号码

4. Token机制

   > 适用场景：网络原因或重复点击导致的请求重发
   >
   > 处理流程：数据提交前向服务器申请Token->服务器校验Token处理业务的同时删除Token（只生效一次）
   >
   > Token存储：jvm、redis（可以限流）

5. 悲观锁

   > 获取数据的时候加锁获取 select * from table_xxx where id='xxx' for update;  **注意：id字段一定是主键或者唯一索引，不然是锁表**，会死人的；悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用。

6. 乐观锁

   > 乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。 
   >
   > 乐观锁的实现方式多种多样可以通过version或者其他状态条件：  1）. 通过版本号实现  update table_xxx set name=#name#,version=version+1 where version=#version#  如下图(来自网上)： 
   >
   > ![img](file:///Users/jerrylau/workspace/writting/whoiscat.com/knowledge/resume/images/cc01c65f-be67-3fdf-adba-edf7f46ce86a.jpg?lastModify=1637145977) 
   >
   > 2）. 通过条件限制  update table_xxx set avai_amount=avai_amount-#subAmount# where avai_amount-#subAmount# >= 0  要求：quality-#subQuality# >= ，这个情景适合不用版本号，只更新是做数据安全校验，适合库存模型，扣份额和回滚份额，性能更高 
   >
   > **注意：乐观锁的更新操作，最好用主键或者唯一索引来更新,这样是行锁，否则更新时会锁表，上面两个sql改成下面的两个更好  update table_xxx set name=#name#,version=version+1 where id=#id# and version=#version#  update table_xxx set avai_amount=avai_amount-#subAmount# where id=#id# and avai_amount-#subAmount# >= 0** 

7. 分布式锁

   > 还是拿插入数据的例子，如果是分布是系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定，这时候可以引入分布式锁，通过第三方的系统(redis或zookeeper)，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁，这样其实是把多线程并发的锁的思路，引入多多个系统，也就是分布式系统中得解决思路。 
   >
   > **要点：某个长流程处理过程要求不能并发执行，可以在流程执行之前根据某个标志(用户ID+后缀等)获取分布式锁，其他流程执行时获取锁就会失败，也就是同一时间该流程只能有一个能执行成功，执行完成后，释放分布式锁(分布式锁要第三方系统提供)** 

8. select + insert

   > 并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了。**注意：核心高并发流程不要用这种方法** 

9. 状态机幂等

   > 在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机(状态变更图)，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机，这时候，如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。 
   >
   > **订单等单据类业务，存在很长的状态流转，一定要深刻理解状态机，对业务系统设计能力提高有很大帮助** 

10. 对外API的幂等

    > 如银联提供的付款接口：需要接入商户提交付款请求时附带source来源和seq序列号，source+seq在数据库里面做唯一索引，防止多次付款。
    >
    > 对外提供接口为了支持幂等调用，接口有两个字段必须传，一个是来源source，一个是来源方序列号seq，这个两个字段在提供方系统里面做联合唯一索引，这样当第三方调用时，先在本方系统里面查询一下，是否已经处理过，返回相应处理结果；没有处理过，进行相应处理，返回结果。
    >
    > 注意，为了幂等友好，一定要先查询一下，是否处理过该笔业务，不查询直接插入业务系统，会报错，但实际已经处理了。

#### 对外提供的API如何保证幂等

#### 什么是幂等性？幂等有哪些技术解决方案

### 缓存

#### 什么是缓存一致性，有什么解决方案

以Redis作为MySQL的缓存为例

| 方案                                                         | 优点                                                         | 缺点                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 通过 key 的过期时间，mysql 更新时，redis 不更新。 这种方式实现简单，但不一致的时间会很长。<br />如果读请求非常频繁，且过期时间比较长，则会产生很多长期的脏数据。 | 开发成本低，易于实现； 管理成本低，出问题的概率会比较小。    | 完全依赖过期时间，时间太短容易缓存频繁失效，太长容易有长时间更新延迟（不一致） |
| 在方案一的基础上扩展，通过 key 的过期时间兜底，并且，在更新 mysql 时，同时更新 redis。 | 相对方案一，更新延迟更小。                                   | 如果更新 mysql 成功，更新 redis 却失败，就退化到了方案一； <br />在高并发场景，业务 server 需要和 mysql,redis 同时进行连接。这样是损耗双倍的连接资源，容易造成连接数过多的问题。 |
| 针对方案二的同步写 redis 进行优化，增加消息队列，将 redis 更新操作交给 kafka，由消息队列保证可靠性，再搭建一个消费服务，来异步更新 redis。 | 消息队列可以用一个句柄，很多消息队列客户端还支持本地缓存发送，有效解决了方案二连接数过多的问题； <br />使用消息队列，实现了逻辑上的解耦；<br />消息队列本身具有可靠性，通过手动提交等手段，可以至少一次消费到 redis。 | 依旧解决不了时序性问题，如果多台业务服务器分别处理针对同一行数据的两条请求，举个栗子，a = 1； a = 5;如果 mysql 中是第一条先执行，而进入 kafka 的顺序是第二条先执行，那么数据就会产生不一致。 <br />引入了消息队列，同时要增加服务消费消息，成本较高。 |
| 通过订阅 binlog 来更新 redis，把我们搭建的消费服务，作为 mysql 的一个 slave，订阅 binlog，解析出更新内容，再更新到 redis。 | 在 mysql 压力不大情况下，延迟较低；<br />和业务完全解耦；<br />解决了时序性问题。 | 要单独搭建一个同步服务，并且引入 binlog 同步机制，成本较大。 |

## 其它

### 算法题

#### 

### 场景题

#### 手写一个API Gateway

#### 手写一个生产者消费者模型

### 智力题
