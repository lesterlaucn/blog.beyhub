## 架构设计思想

### 模型驱动设计 MDD

MDA

### 领域驱动设计

#### 为什么要DDD

领域驱动设计是一种以业务为导向的软件设计方法和思路。我们在开发前，通常需要进行大量的业务知识梳理，而后到达软件设计的层面，最后才是开发。而在业务知识梳理的过程中，我们必然会形成某个领域知识，根据领域知识来一步步驱动软件设计，就是领域驱动设计的基本概念。而领域驱动设计的核心就在于建立正确的领域驱动模型。

微服务盛行的今天，多层SOA架构已经完全不能满足微服务架构应用的需求，它存在这么一些问题：

1. 臃肿的servcie
2. 三层分层后文件的随意组装方式
3. 技术导向分层，导致业务分离，不能快速定位。

#### DDD分层架构介绍

- 分层

DDD 分层架构包含用户接口层、应用层、领域层和基础层。通过这些层次划分，我们可以明确微服务各层的职能，划定各领域对象的边界，确定各领域对象的协作方式。DDD的分层架构如图：从上到下依次是：用户接口层、应用层、领域层和基础层。

<img src="images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3cxbGd5,size_16,color_FFFFFF,t_70-20210928160459892.jpeg" style="zoom:60"/>

- 各层次之间的调用关系

![在这里插入图片描述](images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3cxbGd5,size_16,color_FFFFFF,t_70-20210928161106200.jpg)

- 特别说明
  
  > 1. 用户接口层负责向用户显示信息和解释用户指令，并将数据传递给 Application 层。数据的组装、数据传输格式以及 Facade 接口等代码都会放在这一层目录里。这里的用户可能是：用户、程序、自动化测试和批处理脚本等等。
  > 2. 应用层是很薄的一层，理论上不应该有业务规则或逻辑，主要面向用例和流程相关的操作。但应用层又位于领域层之上，因为领域层包含多个聚合，所以它可以协调多个聚合的服务和领域对象完成服务编排和组合，协作完成业务操作。
  > 3. 应用层也是微服务之间交互的通道，它可以调用其它微服务的应用服务，完成微服务之间的服务组合和编排。
  > 4. 实现领域的核心业务逻辑。这一层聚集了领域模型的聚合、聚合根、实体、值对象、领域服务和事件等领域对象，以及它们组合所形成的业务能力。
  > 5. 基础层是贯穿所有层的，它的作用就是为其它各层提供通用的技术和基础服务，包括第三方工具、驱动、消息中间件、网关、文件、缓存以及数据库等。比较常见的功能还是提供数据库持久化。

- 参考阅读：https://blog.csdn.net/w1lgy/article/details/111566243

#### DDD术语：聚合与聚合根

#### 实体、值对象

#### 充血模型和失血模型

贫血模型：是指领域对象里只有get和set方法，或者包含少量的CRUD方法，所有的业务逻辑都不包含在内而是放在Business Logic层。

> 好处
> 
> 1. 每个贫血对象职责单一，所以模块解藕程度很高，有利于错误的隔离。
> 2. 非常重要的是，这种模型非常适合于软件外包和大规模软件团队的协作。每个编程个体只需要负责单一职责的小对象模块编写，不会互相影响。
> 
> 坏处
> 
> 1. 由于对象状态和行为分离，所以一个完整的业务逻辑的描述不能够在一个类当中完成，而是一组互相协作的类共同完成的。因此可复用的颗粒度比较小，代码量膨胀的很厉害，最重要的是业务逻辑的描述能力比较差，一个稍微复杂的业务逻辑，就需要太多类和太多代码去表达。
> 2. 对象协作依赖于外部容器的组装，因此裸写代码是不可能的了，必须借助于外部的IoC容器。 

充血模型：层次结构和上面的差不多，不过大多业务逻辑和持久化放在Domain Object里面，Business Logic（业务逻辑层）只是简单封装部分业务逻辑以及控制事务、权限等。

> 好处
> 
> 1. 对象自洽程度很高，表达能力很强，因此非常适合于复杂的企业业务逻辑的实现，以及可复用程度比较高。
> 2. 不必依赖外部容器的组装，所以RoR没有IoC的概念。
> 
> 坏处
> 
> 1. 对象高度自洽的结果是不利于大规模团队分工协作。一个编程个体至少要完成一个完整业务逻辑的功能。对于单个完整业务逻辑，无法再细分下去了。
> 2. 随着业务逻辑的变动，领域模型可能会处于比较频繁的变动状态中，领域模型不够稳定也会带来web层代码频繁变动。

#### 说说VO、PO、DO、DTO这些概念

VO（View Object）： 视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。

DTO（Data Transfer Object）： 数据传输对象，这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，我泛指用于展示层与服务层之间的数据传输对象。

DO（Domain Object）： 领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。

PO（Persistent Object）： 持久化对象，它跟持久层（通常是关系型数据库）的数据结构形成一一对应的映射关系，如果持久层是关系型数据库，那么，数据表中的每个字段（或若干个）就对应PO的一个（或若干个）属性。

### 设计模式

### 约定优于配置

其实在开发中，处处都用到了“约定大于配置”这一思想

就是在开发中，如果有些值你没有配置的话，那程序会取一个默认值，换句话说，能取默认值的配置，就不需要配置了，这个默认值就是约定。
约定可以减少很多配置
比如说在maven的结构中:

/src/main/java目录用来存放java源文件
src/main/resources目录用来存放资源文件，如application.yml文件，mybatis的*mapper.xml文件
/src/test/java目录用来存放java测试文件
/src/test/resources目录用来存放测试资源文件
/target目录为项目的输出位置
java 项目 www.fhadmin.org
其实呢，maven为你做了很多事情，只是它都对用户隐藏了起来，你只需要遵循它的约定即可
约定大于配置是一个简单的概念。系统，类库，框架假定其合理的默认值，而非要求提供不必要的配置。在大部分情况下，使用框架提供的默认值会让项目运行的更快。
在springboot中，只要导入了web-stater，spring mvc、json、spring核心容器等web场景需要的所有依赖都会导入，并控制好版本

spring boot的理念就是约定大于配置，在spring boot中提供了一套默认配置，不需要手动去写xml配置文件，只有默认配置不能满足我们的需求时，才会去修改配置。

### 架构设计原则

#### 合适原则:『合适优于业界领先』

- 是否『领先』，是否『亿级』都不重要，脚踏实地的实现架构是最重要的
- 有多少人干多少活，十个人团队想做几十人才能完成的事情，失败机率太大
- 领先的方案不是拍脑袋灵机一动得来的，而是经过长时间的发展逐步完善的
- 业界领先的方案都是业务发展到一定阶段才催生出来的，不是一蹴而就的

> 真正优秀的架构都是在企业当前人力、条件、业务等各种约束下设计出来的，能够合理地将资源整合在一起并发挥出最大功效，并且能够快速落地。

#### 简单原则:『简单优于复杂』

- 技术越来越精细和复杂，导致架构设计时也想把架构做精美、做复杂，以便体现技术实力
- 团队压力也会促使架构走向复杂，因为评价方案水平高低时，复杂性是重要参考指标
- 『复杂』在软件领域，代表的不是领先或者先进，而是『问题』
- 软件领域的复杂性有两个：结构的复杂性、逻辑的复杂性
- 结构复杂的特点是组件数量多、组件之间的关系复杂；因而可能导致：组件故障率高、一个组件改动影响关联的所有组件、定位问题更加困难。
- 逻辑复杂的特点是单个组件承担了太多功能、采用了复杂算法；因而导致难以实现、难以修改、问题无法快速解决。
- 如果简单方案和复杂方案都可以满足要求，架构设计应选择简单方案

> 《UNIX 编程艺术》总结的 KISS（Keep It Simple, Stupid!）原则一样适应于架构设计。

#### 演化原则:『演化优于一步到位』

- 软件架构与建筑架构在定义和理解上有相似性，但存在本质差异：软件需要不断变化
- 架构设计的误区：一步到位的设计一个软件架构，期望不管业务如何变化都能适应
- 软件架构设计更类似于『设计』一个生物：通过演化让生物适应环境，并逐步变得强大
- 明确当前业务特点和主要问题才是设计的根本，不符合业务的架构再领先也没用

> 架构师在进行架构设计时需要牢记这个原则，时刻提醒自己不要贪大求全，或者盲目照搬大公司的做法。

## 云原生

### 为什么要云原生

1. 声明式定义环境
2. 标准化
3. 弹性扩容
4. 业务开发可以直接

### K8s

#### CRD

#### DaemonSet

### Helm

### Traefic 边缘路由网关

#### Traefic是啥？

Traefic可以等价于Nginx，它是一个边缘路由器会拦截外部的请求并根据逻辑规则选择不同的操作方式，这些规则决定着这些请求到底该如何处理。Traefik提供自动发现能力，会实时检测服务，并自动更新路由规则。

![img](images/98aa36bc6341e5dd9e48b8e4ef2f1954.jpg)

#### Traefic技术架构

![img](images/ad012ad170058a5163b9ca9d8459c59f.jpg)

请求首先会连接到entrypoints，然后分析这些请求是否与定义的rules匹配，如果匹配，则会通过一系列middlewares，再到对应的services上。这就涉及到以下几个重要的核心组件：

> | 组件        | 功能                                                         |
> | ----------- | ------------------------------------------------------------ |
> | Providers   | Providers是基础组件，Traefik的配置发现是通过它来实现的，它可以是协调器，容器引擎，云提供商或者键值存储。Traefik通过查询Providers的API来查询路由的相关信息，一旦检测到变化，就会动态的更新路由。 |
> | Entrypoints | Entrypoints是Traefik的网络入口，它定义接收请求的接口，以及是否监听TCP或者UDP。 |
> | Routers     | Routers主要用于分析请求，并负责将这些请求连接到对应的服务上去，在这个过程中，Routers还可以使用Middlewares来更新请求，比如在把请求发到服务之前添加一些Headers。 |
> | Services    | Services负责配置如何到达最终将处理传入请求的实际服务。       |
> | Middlewares | Middlewares用来修改请求或者根据请求来做出一些判断(authentication, rate limiting, headers, ...)，中间件被附件到路由上，是一种在请求发送到你的服务之前(或者在服务的响应发送到客户端之前)调整请求的一种方法。 |

## 消息中间件

### 基本概念

#### 死信

#### 延时队列

#### Stream

### Kafka

#### 数据存储架构

#### Kafka的脑裂问题

#### Address Space原理

#### 文件读写基本流程

#### mmap文件读写方式

#### PageCache的异步刷新策略

#### 零拷贝

Zero Copy对应的是sendfile这个函数（以Linux为例），这个函数接受

- out_fd作为输出（一般及时socket的句柄）
- in_fd作为输入文件句柄
- off_t表示in_fd的偏移（从哪里开始读取）
- size_t表示读取多少个

### RocketMQ

### Pulsar

#### 存储分离架构（优于Kafka）

pulsar相对于kafka来说，在存储上有优势，kafka的单个partition的存储容量受到了部署kafka的broker的硬盘容量限制，当有大量的数据需要MQ支持时，partition可能会遇到瓶颈而无法扩展。

Pulsar 的多层架构影响了存储数据的方式。Pulsar 将 topic 分区划分为分片（segment），然后将这些分片存储在 Apache BookKeeper 的存储节点上，以提高性能、可伸缩性和可用性。

### RabbitMQ

## RPC框架

### Dubbo

#### Dubbo 支持哪些协议，每种协议的应用场景，优缺点？

dubbo： 单一长连接和 NIO 异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议 TCP，异步， Hessian 序列化；

rmi： 采用 JDK 标准的 rmi 协议实现，传输参数和返回参数对象需要实现Serializable 接口，使用 java 标准序列化机制，使用阻塞式短连接，传输数据包大小混合，消费者和提供者个数差不多，可传文件，传输协议 TCP。多个短连接， TCP 协议传输，同步传输，适用常规的远程服务调用和 rmi 互操作。在依赖低版本的 Common-Collections 包， java 序列化存在安全漏洞；

http： 基于 Http 表单提交的远程调用协议，使用 Spring 的 HttpInvoke 实现。多个短连接，传输协议 HTTP，传入参数大小混合，提供者个数多于消费者，需要给应用程序和浏览器 JS 调用；

webservice： 基于 WebService 的远程调用协议，集成 CXF 实现，提供和原生 WebService 的互操作。多个短连接，基于 HTTP 传输，同步传输，适用系统集成和跨语言调用；

hessian： 集成 Hessian 服务，基于 HTTP 通讯，采用 Servlet 暴露服务，Dubbo 内嵌 Jetty 作为服务器时默认实现，提供与 Hession 服务互操作。多个短连接，同步 HTTP 传输， Hessian 序列化，传入参数较大，提供者大于消费者，提供者压力较大，可传文件；

Redis： 基于 Redis 实现的 RPC 协议

#### Dubbo 超时时间怎样设置？Dubbo 超时时间设置有两种方式：

服务提供者端设置超时时间，在 Dubbo 的用户文档中，推荐如果能服务端多配置就尽量多配置，因为服务提供者比消费者更清楚自己提供的服务特性。

服务消费者端设置超时时间，如果在消费者端设置了超时时间，以消费者端为主，即优先级更高。因为服务调用方设置超时时间控制性更灵活。如果消费方超时，服务端线程不会定制，会产生警R告。

#### Dubbo 有些哪些注册中心？

Multicast 注册中心： Multicast 注册中心不需要任何中心节点，只要广播地址，就能进行服务注册和发现。基于网络中组播传输实现；

Zookeeper 注册中心： 基于分布式协调系统 Zookeeper 实现，采用Zookeeper 的 watch 机制实现数据变更；

redis 注册中心： 基于 redis 实现，采用 key/Map 存储，住 key 存储服务名和类型， Map 中 key 存储服务 URL， value 服务过期时间。基于 redis 的发布/订阅模式通知数据变更；

Simple 注册中心

#### Dubbo 集群的负载均衡有哪些策略?Dubbo 提供了常见的集群策略实现，并预扩展点予以自行实现。

Random LoadBalance: 随机选取提供者策略，有利于动态调整提供者权重。截面碰撞率高，调用次数越多，分布越均匀；RoundRobin LoadBalance: 轮循选取提供者策略，平均分布，但是存在请求累积的问题；

LeastActive LoadBalance: 最少活跃调用策略，解决慢提供者接收更少的请求；

ConstantHash LoadBalance: 一致性 Hash 策略，使相同参数请求总是发到同一提供者，一台机器宕机，可以基于虚拟节点，分摊至其他提供者，避免引起提供者的剧烈变动；

#### Dubbo 是什么？

Dubbo 是一个分布式、高性能、透明化的 RPC 服务框架，提供服务自动注册、自动发现等高效服务治理方案， 可以和Spring 框架无缝集成

#### Dubbo 的主要应用场景？

· 透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何 API 侵入。

· 软负载均衡及容错机制，可在内网替代 F5 等硬件负载均衡器，降低成本，减少单点。

· 服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的 IP 地址，并且能够平滑添加或删除服务提供者。

#### 7. Dubbo 的核心功能？主要就是如下 3 个核心功能：

Remoting： 网络通信框架，提供对多种 NIO 框架抽象封装，包括“同步转异步”和“请求-响应”模式的信息交换方式。

Cluster：服务框架，提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。

Registry：服务注册，基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。

#### Dubbo 服务注册与发现的流程？

流程说明：

· Provider(提供者)绑定指定端口并启动服务

· 指供者连接注册中心，并发本机 IP、端口、应用信息和提供服务信息发送至注册中心存储

· Consumer(消费者），连接注册中心 ，并发送应用信息、所求服务信息至注册中心

· 注册中心根据 消费 者所求服务信息匹配对应的提供者列表发送至Consumer 应用缓存。

· Consumer 在发起远程调用时基于缓存的消费者列表择其一发起调用。

· Provider 状态变更会实时通知注册中心、在由注册中心实时推送至Consumer 设计的原因：

· Consumer 与 Provider 解偶，双方都可以横向增减节点数。

· 注册中心对本身可做对等集群，可动态增减节点，并且任意一台宕掉后，将自动切换到另一台

· 去中心化，双方不直接依懒注册中心，即使注册中心全部宕机短时间内也不会影响服务的调用

· 服务提供者无状态，任意一台宕掉后，不影响使用

#### Dubbo 的架构设计

Dubbo 框架设计一共划分了 10 个层：

· 服务接口层（ Service） ：该层是与实际业务逻辑相关的，根据服务提供方和服务消费方的业务设计对应的接口和实现。

· 配置层（ Config） ：对外配置接口，以 ServiceConfig 和ReferenceConfig 为中心。

· 服务代理层（ Proxy）：服务接口透明代理，生成服务的客户端 Stub和服务器端 Skeleton

· 服务注册层（ Registry） ：封装服务地址的注册与发现，以服务 URL为中心。

· 集群层（ Cluster） ：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心。

· 监控层（ Monitor） ： RPC 调用次数和调用时间监控。

· 远程调用层（ Protocol） ：封将 RPC 调用，以 Invocation 和 Result为中心，扩展接口为 Protocol、 Invoker 和 Exporter。

· 信息交换层（ Exchange） ：封装请求响应模式，同步转异步，以Request 和 Response 为中心。

· 网络传输层（ Transport） ：抽象 mina 和 netty 为统一接口，以Message 为中心。

#### Dubbo 的服务调用流程？

#### Dubbo 的核心组件？

#### 12. Dubbo 支持哪些协议，每种协议的应用场景，优缺点？

dubbo： 单一长连接和 NIO 异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议 TCP，异步， Hessian 序列化； rmi： 采用 JDK 标准的 rmi 协议实现，传输参数和返回参数对象需要实现 Serializable 接口，使用 java 标准序列化机制，使用阻塞式短连接，传输数据包大小混合，消费者和提供者个数差不多，可传文件，传输协议 TCP。 多个短连接， TCP 协议传输，同步传输，适用常规的远程服务调用和rmi 互操作。在依赖低版本的 Common-Collections包， java 序列化存在安全漏洞； webservice： 基于 WebService 的远程调用协议，集成 CXF 实现，提供和原生 WebService 的互操作。多个短连接，基于 HTTP 传输，同步传输，适用系统集成和跨语言调用； http： 基于 Http 表单提交的远程调用协议，使用 Spring 的HttpInvoke 实现。多个短连接，传输协议 HTTP，传入参数大小混合，提供者个数多于消费者，需要给应用程序和浏览器 JS 调用； hessian： 集成 Hessian 服务，基于 HTTP 通讯，采用 Servlet 暴露服务， Dubbo 内嵌 Jetty 作为服务器时默认实现，提供与 Hession 服务互操作。多个短连接，同步 HTTP 传输， Hessian 序列化，传入参数较大，提供者大于消费者，提供者压力较大，可传文件； memcache： 基于 memcached 实现的 RPC 协议 redis： 基于 redis 实现的 RPC 协议

#### 13. dubbo 推荐用什么协议？

默认使用 dubbo 协议

#### 14. Dubbo 有些哪些注册中心？

Multicast 注册中心： Multicast 注册中心不需要任何中心节点，只要广播地址，就能进行服务注册和发现。基于网络中组播传输实现；§ Zookeeper 注册中心： 基于分布式协调系统 Zookeeper 实现，采用Zookeeper 的 watch 机制实现数据变更；

redis 注册中心： 基于 redis 实现，采用 key/Map 存储，住 key 存储服务名和类型， Map 中 key 存储服务 URL， value 服务过期时间。基于 redis 的发布/订阅模式通知数据变更；

Simple 注册中心

#### Dubbo 默认采用注册中心？

采用 Zookeeper

#### 为什么需要服务治理？

· 过多的服务 URL 配置困难

· 负载均衡分配节点压力过大的情况下也需要部署集群§ 服务依赖混乱，启动顺序不清晰

· 过多服务导致性能指标分析难度较大，需要监控

#### Dubbo 的注册中心集群挂掉，发布者和订阅者之间还能通信么？

可以的，启动 dubbo 时，消费者会从 zookeeper 拉取注册的生产者的地址接口等数据，缓存在本地。 每次调用时，按照本地存储的地址进行调用。

#### Dubbo 与 Spring 的关系？

Dubbo 采用全 Spring 配置方式，透明化接入应用，对应用没有任何API 侵入，只需用 Spring 加载 Dubbo 的配置即可， Dubbo 基于Spring 的 Schema 扩展进行加载。

#### 19. Dubbo 使用的是什么通信框架?

默认使用 NIO Netty 框架 

#### Dubbo 集群提供了哪些负载均衡策略？

· Random LoadBalance: 随机选取提供者策略，有利于动态调整提供者权重。截面碰撞率高，调用次数越多，分布越均匀；

· RoundRobin LoadBalance: 轮循选取提供者策略，平均分布，但是存在请求累积的问题；§ LeastActive LoadBalance: 最少活跃调用策略，解决慢提供者接收更少的请求；

· ConstantHash LoadBalance: 一致性 Hash 策略，使相同参数请求总是发到同一提供者，一台机器宕机，可以基于虚拟节点，分摊至其他提供者，避免引起提供者的剧烈变动；

· 缺省时为 Random 随机调用

#### Dubbo 的集群容错方案有哪些？

Failover Cluster

· 失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。

Failfast Cluster

· 快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。

Failsafe Cluster

· 失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。

Failback Cluster

· 失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。

Forking Cluster

· 并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks="2" 来设置最大并行数。

Broadcast Cluster

· 广播调用所有提供者，逐个调用，任意一台报错则报错 。通常用于通知所有提供者更新缓存或日志等本地资源信息

#### 22. Dubbo 的默认集群容错方案？

Failover Cluster 

#### 23. Dubbo 支持哪些序列化方式？

默认使用 Hessian 序列化，还有 Duddo、 FastJson、 Java 自带序列化。

#### 24. Dubbo 超时时间怎样设置？

Dubbo 超时时间设置有两种方式：

· 服务提供者端设置超时时间，在 Dubbo 的用户文档中，推荐如果能在服务端多配置就尽量多配置，因为服务提供者比消费者更清楚自己提供的服务特性。

· 服务消费者端设置超时时间，如果在消费者端设置了超时时间，以消费者端为主，即优先级更高。因为服务调用方设置超时时间控制性更灵活。如果消费方超时，服务端线程不会定制，会产生警告。

#### 服务调用超时问题怎么解决？

Dubbo 在调用服务不成功时，默认是会重试两次的。

#### Dubbo 在安全机制方面是如何解决？

Dubbo 通过 Token 令牌防止用户绕过注册中心直连，然后在注册中心上管理授权。 Dubbo 还提供服务黑白名单，来控制服务所允许的调用方。

#### Dubbo 和 Dubbox 之间的区别？

dubbox 基于 dubbo 上做了一些扩展，如加了服务可 restful 调用，更新了开源组件等。

#### 28. Dubbo 和 Spring Cloud 的关系？

Dubbo 是 SOA 时代的产物，它的关注点主要在于服务的调用，流量分发、流量监控和熔断。而 Spring Cloud 诞生于微服务架构时代，考虑的是微服务治理的方方面面，另外由于依托了 Spirng、Spirng Boot 的优势之上，两个框架在开始目标就不一致， Dubbo定位服务治理、 Spirng Cloud 是一个生态。

#### 29. Dubbo 和 Spring Cloud 的区别？

最大的区别： Dubbo 底层是使用 Netty 这样的 NIO 框架，是基于TCP 协议传输的，配合以 Hession 序列化完成 RPC 通信。 而 SpringCloud 是基于 Http 协议+Rest 接口调用远程过程的通信，相对来说， Http 请求会有更大的报文，占的带宽也会更多。但是REST 相比 RPC 更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖。

## 分布式

### 基本理论

#### BASE理论是什么？

#### CAP定理是什么？

#### 为什么要做幂等性设计？

**我们实际系统中有很多操作，是不管做多少次，都应该产生一样的效果或返回一样的结果。 例如：** 

1. 前端重复提交选中的数据，应该后台只产生对应这个数据的一个反应结果。 
2. 我们发起一笔付款请求，应该只扣用户账户一次钱，当遇到网络重发或系统bug重发，也应该只扣一次钱； 
3. 发送消息，也应该只发一次，同样的短信发给用户，用户会哭的； 
4. 创建业务订单，一次业务请求只能创建一个，创建多个就会出大问题。 

幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。 在编程中，一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“getUsername()和setTrue()”函数就是一个幂等函数. 

#### 设计微服务时需要遵循什么原则？

#### 如何维护微服务间共享的Interface和DTO

#### 介绍一下RMI

DTO是微服务间的**通信契约**，与Feign/Dubbo的Interface放在一起。此处，我们使用一个公共包`bootstrap-api`来维护。

#### 什么是分布式一致性算法

- Paxos
- Raft
- ZAB
- Gossip

### 分布式ID

#### 雪花算法生成的ID有哪些部分组成？

#### 分布式ID生成方案有哪些？

### RPC

#### RPC调用原理？

#### 介绍下常用的令牌桶算法和漏桶算法

- 漏桶

  > 把请求比作是水，水来了都先放进桶里，并以限定的速度出水，当水来得过猛而出水不够快时就会导致水直接溢出，即拒绝服务。
  >
  > ![img](file:///Users/jerrylau/workspace/writting/whoiscat.com/knowledge/resume/images/1460000015967925.png?lastModify=1637145977)

- 令牌桶

  > 对于很多应用场景来说，除了要求能够限制数据的平均传输速率外，还要求**允许某种程度的突发传输**。这时候漏桶算法可能就不合适了，令牌桶算法更为适合。
  >
  > 令牌桶算法的原理是系统以恒定的速率产生令牌，然后把令牌放到令牌桶中，令牌桶有一个容量，当令牌桶满了的时候，再向其中放令牌，那么多余的令牌会被丢弃；当想要处理一个请求的时候，需要从令牌桶中取出一个令牌，如果此时令牌桶中没有令牌，那么则拒绝该请求。
  >
  > ![img](file:///Users/jerrylau/workspace/writting/whoiscat.com/knowledge/resume/images/1460000015967926.png?lastModify=1637145977)

### 流量控制

#### 计数器算法是什么？

#### 令牌桶限流算法是什么？

#### 漏桶限流算法是什么？

#### Sentinel实现原理

责任链模式

### 分布式锁

#### MySQL如何实现分布式锁？

#### Zookeeper和Redis做分布式锁的区别是什么？

#### 基于Zookeeper分布式锁实现的原理是什么？

#### Redis如何做分布式锁？什么时候会发生死锁，如何解决？

#### 分布式锁在项目中有哪些应用场景？

### 分布式事务

#### TCC/XA/AT/Saga几种分布式事务的比较

https://tech.antfin.com/community/activities/779/review/901

| 方案 | 业务侵入 | 全局锁 | 特点                                                         | 最终一致性 |
| ---- | -------- | ------ | ------------------------------------------------------------ | ---------- |
| TCC* | 是       | 否     | 2PC，性能高，容易理解，方案成熟                              | 是         |
| XA   | 否       | 是     | 2PC，事务分支是阻塞的，会一下锁多个表                        |            |
| AT*  | 否       | 是     | 基于XA改造                                                   |            |
| SAGA | 是       | 否     | 需要引入协调者，一般用MQ或业务系协调器，顺序执行事务分支 不能保证隔离性 | 是         |

#### 如何解决TCC幂等、空回滚、悬挂问题？

- 悬挂（cancel比try先执行）

  > Cancel 比 Try 接口先执行，出现的原因是 Try 由于网络拥堵而超时，事务管理器生成回滚，触发 Cancel 接口，而最终又收到了 Try 接口调用，但是 Cancel 比 Try 先到。按照前面允许空回滚的逻辑，回滚会返回成功，事务管理器认为事务已回滚成功，则此时的 Try 接口不应该执行，否则会产生数据不一致，所以我们在 Cancel 空回滚返回成功之前先记录该条事务 xid 或业务主键，标识这条记录已经回滚过，Try 接口先检查这条事务xid或业务主键如果已经标记为回滚成功过，则不执行 Try 的业务操作。

- 空回滚（try超时、丢包）

  > Cancel 接口设计时需要允许空回滚。在 Try 接口因为丢包时没有收到，事务管理器会触发回滚，这时会触发 Cancel 接口，这时 Cancel 执行时发现没有对应的事务 xid 或主键时，需要返回回滚成功。让事务服务管理器认为已回滚，否则会不断重试，而 Cancel 又没有对应的业务数据可以进行回滚。

- 幂等（try-catch-cancel都需要保证幂等性）

  > 对同一个系统，使用同样的条件，一次请求和重复的多次请求对系统资源的影响是一致的。因为网络抖动或拥堵可能会超时，事务管理器会对资源进行重试操作，所以很可能一个业务操作会被重复调用，为了不因为重复调用而多次占用资源，需要对服务设计时进行幂等控制，通常我们可以用事务 xid 或业务主键判重来控制。

#### TCC解决方案是什么？

TCC是Try、Confirm、Cancel三个词语的缩写，TCC要求每个分支事务实现三个操作：预处理Try、确认Confirm、撤销Cancel。Try操作做业务检查及资源预留，Confirm做业务确认操作，Cancel实现一个与Try相反的操作即回滚操作。TM首先发起所有的分支事务的try操作，任何一个分支事务的try操作执行失败，TM将会发起所有分支事务的Cancel操作，若try操作全部成功，TM将会发起所有分支事务的Confirm操作，其中Confirm/Cancel操作若执行失败，TM会进行重试。

![img](file:///Users/jerrylau/workspace/writting/whoiscat.com/knowledge/resume/images/1243133-20191101180737096-1636349878.png?lastModify=1637145977)

分支事务失败的情况：

![img](file:///Users/jerrylau/workspace/writting/whoiscat.com/knowledge/resume/images/1243133-20191101192717249-2033068949.png?lastModify=1637145977)

TCC分为三个阶段：

> 1. Try 阶段是做业务检查(一致性)及资源预留(隔离)，此阶段仅是一个初步操作，它和后续的Confirm 一起才能真正构成一个完整的业务逻辑。
> 2. Confirm 阶段是做确认提交，Try阶段所有分支事务执行成功后开始执行 Confirm。通常情况下，采用TCC则认为 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。若Confirm阶段真的出错了，需引入重试机制或人工处理。
> 3. Cancel 阶段是在业务执行错误需要回滚的状态下执行分支事务的业务取消，预留资源释放。通常情况下，采用TCC则认为Cancel阶段也是一定成功的。若Cancel阶段真的出错了，需引入重试机制或人工处理。

#### 什么是DTP分布式事务模型？

X/Open DTP(X/Open Distributed Transaction Processing Reference Model) 是X/Open 这个组织定义的一套分布式事务的标准，也就是了定义了规范和API接口，由这个厂商进行具体的实现。这个思想在java 平台里面到处都是。

X/Open DTP 定义了三个组件： AP，TM，RM

> AP(Application Program)：也就是应用程序，可以理解为使用DTP的程序
>
> RM(Resource Manager)：资源管理器，这里可以理解为一个DBMS系统，或者消息服务器管理系统，应用程序通过资源管理器对资源进行控制。资源必须实现XA定义的接口
>
> TM(Transaction Manager)：事务管理器，负责协调和管理事务，提供给AP应用程序编程接口以及管理资源管理器

其中，AP 可以和TM 以及 RM 通信，TM 和 RM 互相之间可以通信，DTP模型里面定义了XA接口，TM 和 RM 通过XA接口进行双向通信，例如:TM通知RM提交事务或者回滚事务，RM把提交结果通知给TM。AP和RM之间则通过RM提供的Native API 进行资源控制，这个没有进行约API和规范，各个厂商自己实现自己的资源控制，比如Oracle自己的数据库驱动程序。

![img](file:///Users/jerrylau/workspace/writting/whoiscat.com/knowledge/resume/images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzMyODIx,size_16,color_FFFFFF,t_70.png?lastModify=1637145977)

#### XA分布式协议

XA 规范 是 X/Open 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准。

XA 规范 描述了全局的事务管理器与局部的资源管理器之间的接口。 XA规范 的目的是允许的多个资源（如数据库，应用服务器，消息队列等）在同一事务中访问，这样可以使 ACID 属性跨越应用程序而保持有效。XA 规范 使用两阶段提交（2PC，Two-Phase Commit）来保证所有资源同时提交或回滚任何特定的事务。XA 规范 在上世纪 90 年代初就被提出。目前，几乎所有主流的数据库都对 XA 规范 提供了支持。

- XA协议语法

  > 三阶段的第一阶段：开启 xa 事务，这里 xid 为全局事务 id： XA {START|BEGIN} xid [JOIN|RESUME] 结束 xa 事务：XA END xid [SUSPEND [FOR MIGRATE]] 三阶段的第二阶段，即 prepare：XA PREPARE xid 三阶段的第三阶段，即 commit/rollback：XA COMMIT xid [ONE PHASE];XA ROLLBACK xid 查看处于 PREPARE 阶段的所有事务：XA RECOVER XA RECOVER [CONVERT XID]

#### 2PC和3PC提交协议是什么？

**两阶段提交（不支持NoSQL）**

分布式事务的两阶段提交是把整个事务提交分为 prepare 和 commit 两个阶段。以电商系统为例，分布式系统中有订单、账户和库存三个服务，如下图：

![1.png](file:///Users/jerrylau/workspace/writting/whoiscat.com/knowledge/resume/images/454228ca218640b690665d6c664b741a.png?lastModify=1637145977)

第一阶段，事务协调者向事务参与者发送 prepare 请求，事务参与者收到请求后，如果可以提交事务，回复 yes，否则回复 no。

第二阶段，如果所有事务参与者都回复了 yes，事务协调者向所有事务参与者发送 commit 请求，否则发送 rollback 请求。

两阶段提交存在三个问题：

- 同步阻塞，本地事务在 prepare 阶段锁定资源，如果有其他事务也要修改 xiaoming 这个账户，就必须等待前面的事务完成。这样就造成了系统性能下降。
- 协调节点单点故障，如果第一个阶段 prepare 成功了，但是第二个阶段协调节点发出 commit 指令之前宕机了，所有服务的数据资源处于锁定状态，事务将无限期地等待。
- 数据不一致，如果第一阶段 prepare 成功了，但是第二阶段协调节点向某个节点发送 commit 命令时失败，就会导致数据不一致。

**三阶段提交**

为了解决两阶段提交的问题，三阶段提交做了改进：

- 在协调节点和事务参与者都引入了超时机制。
- 第一阶段的 prepare 阶段分成了两步，canCommit 和 preCommit。

如下图：

![img](file:///Users/jerrylau/workspace/writting/whoiscat.com/knowledge/resume/images/1a07db6e5d6048c8b35bd56c9c2a75c0-20211015090615949.png?lastModify=1637145977)

引入 preCommit 阶段后，协调节点会在 commit 之前再次检查各个事务参与者的状态，保证它们的状态是一致的。但是也存在问题，那就是如果第三阶段发出 rollback 请求，有的节点没有收到，那没有收到的节点会在超时之后进行提交，造成数据不一致。

#### Saga分布式事务

*Saga* 设计模式是一种跨分布式事务方案中的微服务管理数据一致性的方式。 Saga 是一个事务序列，用于更新每个服务并发布消息或事件以触发下一个事务步骤。 如果某个步骤失败，saga 会执行补偿事务，这些事务会应对前面的事务。

Saga有何TCC类似的空补偿，悬挂问题。

![img](file:///Users/jerrylau/workspace/writting/whoiscat.com/knowledge/resume/images/webp?lastModify=1637145977)

Saga 模式使用 *本地事务* 序列来提供事务管理。 本地事务是 saga 参与者执行的原子工作工作量。 每个本地事务更新数据库，并发布消息或事件以触发 saga 中的下一个本地事务。 如果本地事务失败，saga 将执行一系列 *补偿事务* ，这些事务可撤消前面的本地事务所做的更改。

![Saga 概述。](file:///Users/jerrylau/workspace/writting/whoiscat.com/knowledge/resume/images/saga-overview.png?lastModify=1637145977)

在 saga 模式中：

- *可补偿事务* 是可以通过相反效果处理另一个事务的事务。
- *透视事务* 是 saga 中的 "中转"/"无" 点。 如果透视事务提交，saga 将一直运行，直到完成。 透视事务可以是既不是可补偿也不能重试的事务，也可以是 saga 中的最后一个可补偿事务或第一个可重试事务。
- 可重 *试事务* 是指在透视事务之后的事务，并保证其成功。

有两种常见的 saga 实现方法： *choreography* 和 *业务流程*。 每种方法都有其自己的一套挑战和技术来协调工作流。

- 协调

  > Choreography 是一种协调 sagas 的方法，在此方法中，参与者无需集中控制即可交换事件。 对于 choreography，每个本地事务都会发布触发其他服务中的本地事务的域事件。
  >
  > ![Choreography 概述](file:///Users/jerrylau/workspace/writting/whoiscat.com/knowledge/resume/images/choreography-pattern.png?lastModify=1637145977)
  >
  > 优点
  >
  > - 适用于需要少量参与者且不需要协调逻辑的简单工作流。
  > - 不需要额外的服务实现和维护。
  > - 不会引入单点故障，因为责任分布在 saga 参与者。
  >
  > 缺点
  >
  > - 添加新步骤时，工作流可能会令人感到困惑，因为这样做很难跟踪哪些 saga 参与者侦听哪些命令。
  > - Saga 参与者之间存在循环依赖关系，因为它们必须使用彼此的命令。
  > - 集成测试非常困难，因为所有服务都必须运行才能模拟事务。

- 业务流程

  > 业务流程是一种协调 sagas 的方式，其中集中式控制器告知 saga 参与者要执行的本地事务。 Saga orchestrator 处理所有事务，并告诉参与者基于事件执行哪个操作。 Orchestrator 执行 saga 请求，存储和解释每个任务的状态，并处理补偿事务的故障恢复。
  >
  > ![业务流程概述](file:///Users/jerrylau/workspace/writting/whoiscat.com/knowledge/resume/images/orchestrator.png?lastModify=1637145977)
  >
  > 优点
  >
  > - 适用于涉及多个参与者的复杂工作流或随时间推移增加的新参与者。
  > - 适用于控制过程中的每个参与者，并控制活动流的情况。
  > - 不会引入循环依赖关系，因为 orchestrator 单方面依赖于 saga 参与者。
  > - Saga 参与者无需知道其他参与者的命令。 清除问题分离可简化业务逻辑。
  >
  > 缺点
  >
  > - 其他设计复杂性要求实现协调逻辑。
  > - 还有一个额外的故障点，因为 orchestrator 管理完整的工作流。

saga模式无法保证隔离性，但性能很高。

#### Atomikos分布式事务

### 消息

#### 最大努力通知方案的关键是什么？

#### 可靠消息服务方案是什么？

### 幂等性设计

#### 如何实现幂等性设计？

1. 查询操作：查一次和查多次是天然幂等的

2. 删除操作：也是天然幂等的，一个资源不会被删除多次

3. 唯一索引约束：适用于唯一的情况，例如：每个人只有一个身份证号码

4. Token机制

   > 适用场景：网络原因或重复点击导致的请求重发
   >
   > 处理流程：数据提交前向服务器申请Token->服务器校验Token处理业务的同时删除Token（只生效一次）
   >
   > Token存储：jvm、redis（可以限流）

5. 悲观锁

   > 获取数据的时候加锁获取 select * from table_xxx where id='xxx' for update;  **注意：id字段一定是主键或者唯一索引，不然是锁表**，会死人的；悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用。

6. 乐观锁

   > 乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。 
   >
   > 乐观锁的实现方式多种多样可以通过version或者其他状态条件：  1）. 通过版本号实现  update table_xxx set name=#name#,version=version+1 where version=#version#  如下图(来自网上)： 
   >
   > ![img](file:///Users/jerrylau/workspace/writting/whoiscat.com/knowledge/resume/images/cc01c65f-be67-3fdf-adba-edf7f46ce86a.jpg?lastModify=1637145977) 
   >
   > 2）. 通过条件限制  update table_xxx set avai_amount=avai_amount-#subAmount# where avai_amount-#subAmount# >= 0  要求：quality-#subQuality# >= ，这个情景适合不用版本号，只更新是做数据安全校验，适合库存模型，扣份额和回滚份额，性能更高 
   >
   > **注意：乐观锁的更新操作，最好用主键或者唯一索引来更新,这样是行锁，否则更新时会锁表，上面两个sql改成下面的两个更好  update table_xxx set name=#name#,version=version+1 where id=#id# and version=#version#  update table_xxx set avai_amount=avai_amount-#subAmount# where id=#id# and avai_amount-#subAmount# >= 0** 

7. 分布式锁

   > 还是拿插入数据的例子，如果是分布是系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定，这时候可以引入分布式锁，通过第三方的系统(redis或zookeeper)，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁，这样其实是把多线程并发的锁的思路，引入多多个系统，也就是分布式系统中得解决思路。 
   >
   > **要点：某个长流程处理过程要求不能并发执行，可以在流程执行之前根据某个标志(用户ID+后缀等)获取分布式锁，其他流程执行时获取锁就会失败，也就是同一时间该流程只能有一个能执行成功，执行完成后，释放分布式锁(分布式锁要第三方系统提供)** 

8. select + insert

   > 并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了。**注意：核心高并发流程不要用这种方法** 

9. 状态机幂等

   > 在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机(状态变更图)，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机，这时候，如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。 
   >
   > **订单等单据类业务，存在很长的状态流转，一定要深刻理解状态机，对业务系统设计能力提高有很大帮助** 

10. 对外API的幂等

    > 如银联提供的付款接口：需要接入商户提交付款请求时附带source来源和seq序列号，source+seq在数据库里面做唯一索引，防止多次付款。
    >
    > 对外提供接口为了支持幂等调用，接口有两个字段必须传，一个是来源source，一个是来源方序列号seq，这个两个字段在提供方系统里面做联合唯一索引，这样当第三方调用时，先在本方系统里面查询一下，是否已经处理过，返回相应处理结果；没有处理过，进行相应处理，返回结果。
    >
    > 注意，为了幂等友好，一定要先查询一下，是否处理过该笔业务，不查询直接插入业务系统，会报错，但实际已经处理了。

#### 对外提供的API如何保证幂等

#### 什么是幂等性？幂等有哪些技术解决方案

### 缓存

#### 什么是缓存一致性，有什么解决方案

以Redis作为MySQL的缓存为例

| 方案                                                         | 优点                                                         | 缺点                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 通过 key 的过期时间，mysql 更新时，redis 不更新。 这种方式实现简单，但不一致的时间会很长。<br />如果读请求非常频繁，且过期时间比较长，则会产生很多长期的脏数据。 | 开发成本低，易于实现； 管理成本低，出问题的概率会比较小。    | 完全依赖过期时间，时间太短容易缓存频繁失效，太长容易有长时间更新延迟（不一致） |
| 在方案一的基础上扩展，通过 key 的过期时间兜底，并且，在更新 mysql 时，同时更新 redis。 | 相对方案一，更新延迟更小。                                   | 如果更新 mysql 成功，更新 redis 却失败，就退化到了方案一； <br />在高并发场景，业务 server 需要和 mysql,redis 同时进行连接。这样是损耗双倍的连接资源，容易造成连接数过多的问题。 |
| 针对方案二的同步写 redis 进行优化，增加消息队列，将 redis 更新操作交给 kafka，由消息队列保证可靠性，再搭建一个消费服务，来异步更新 redis。 | 消息队列可以用一个句柄，很多消息队列客户端还支持本地缓存发送，有效解决了方案二连接数过多的问题； <br />使用消息队列，实现了逻辑上的解耦；<br />消息队列本身具有可靠性，通过手动提交等手段，可以至少一次消费到 redis。 | 依旧解决不了时序性问题，如果多台业务服务器分别处理针对同一行数据的两条请求，举个栗子，a = 1； a = 5;如果 mysql 中是第一条先执行，而进入 kafka 的顺序是第二条先执行，那么数据就会产生不一致。 <br />引入了消息队列，同时要增加服务消费消息，成本较高。 |
| 通过订阅 binlog 来更新 redis，把我们搭建的消费服务，作为 mysql 的一个 slave，订阅 binlog，解析出更新内容，再更新到 redis。 | 在 mysql 压力不大情况下，延迟较低；<br />和业务完全解耦；<br />解决了时序性问题。 | 要单独搭建一个同步服务，并且引入 binlog 同步机制，成本较大。 |

## 其它

### 算法题

#### 

### 场景题

#### 手写一个API Gateway

#### 手写一个生产者消费者模型

### 智力题
