<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>采菊东篱</title>
  
  <subtitle>东篱采菊，终见南山</subtitle>
  <link href="https://blog.beyhub.com/atom.xml" rel="self"/>
  
  <link href="https://blog.beyhub.com/"/>
  <updated>2021-09-08T06:04:12.979Z</updated>
  <id>https://blog.beyhub.com/</id>
  
  <author>
    <name>刘远程 Lester</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM-Architecture.md</title>
    <link href="https://blog.beyhub.com/p/083596e42d0e/"/>
    <id>https://blog.beyhub.com/p/083596e42d0e/</id>
    <published>2021-09-07T09:25:59.000Z</published>
    <updated>2021-09-08T06:04:12.979Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://medium.com/@ThilinaAshenGamage?source=post_page-----22c0ddf09722--------------------------------"><img src="https://miro.medium.com/fit/c/48/48/2*OPRSXMnY00Kju7oC3u6jzQ.jpeg" alt="Thilina Ashen Gamage"></a></p><p>Understanding JVM architecture and how Java really works under the hood is an important learning for every Java developer in order to effectively make use of the Java ecosystem. This blog post series will provide you with a solid foundation on JVM internals and technologies around the Java ecosystem.</p><p>理解JVM的技术架构以及Java内部是如何运作的，对于每一个Java开发者来说是一个重要的知识点，这篇文章提供了一系列Java生态中与JVM相关的技术。</p><p>Designed in 1995 by James Gosling for Sun Microsystems, Java is a multi-paradigm (i.e. object-oriented class-based, structural, imperative, generic, reflective, concurrent) programming language which is loved by millions of developers. On any given ranking index, Java becomes the most popular language for the past 15 years. Tens of thousands of enterprise applications developed in the last 15 years have been mostly written in Java, making it the language of choice for building enterprise-grade production software systems.</p><p>Java是一种多范式（以类为基础的面向对象，泛型、反射、并发、结构化、）编程语言，他在1995年由James Gosling为Sun公司设计，被数百万开发者喜爱和使用。无论按任何指标排名，Java都是过去15年最流行的编程语言。在过去15年，数以万计的企业应用在大多数情况下都是用Java编写，使它成为企业级应用开发的首选。</p><p>Even though I have been using Java since 2015, I recently realized the power of Java ecosystem while doing my final year undergraduate research on Java performance aspects and it motivated to dig deeper into the world of Java. I am planning to write a series of blog posts related to Java internals, performance profiling, server tuning, and many more interesting topics and kindly invite you to stay in touch with this blog. And that’s it for now. Let’s start from primers on Java fundamentals!</p><p>For almost any programming language, you need a specific environment which comprises of all the necessary components, application programming interfaces, and libraries in order to develop, compile, debug and execute its programs. Java has 2 such environments and everyone working with Java has to start their work after setting up one of these environments on their local development or production environment platforms.</p><ul><li><strong>JRE (Java Runtime Environment)</strong>: the minimum environment needed for running a Java application (no support for developing). It includes JVM (Java Virtual Machine) and deployment tools.</li><li><strong>JDK (Java Development Kit)</strong>: the complete development environment used for developing and executing Java applications. It includes both JRE and development tools.</li></ul><p>JRE is meant for users, while JDK is meant for programmers.</p><p>You can start writing a simple Java program with any terminal editor (vim, nano) or GUI editor (gedit, sublime). For a complex Java application, you may need an IDE (Integrated Development Environment) like IntelliJ IDEA, Eclipse, or Netbeans. A typical Java program should contain correct <strong>language syntax</strong> and <strong>.java</strong> format. It is recommended to use programming concepts like OOP (Object Oriented Programming) and appropriate architectural patterns for the convenience of structuring and maintaining your Java programs.</p><p>The major strength of Java is, it has been designed to run on variety of platforms with the concept <strong>WORA</strong> — “<strong>write once, run anywhere</strong>”. Although languages like C++ compile its source code to match only a specific platform and run natively on its OS and hardware, Java source codes are compiled into an intermediate state called <strong>bytecode</strong> (i.e. a <strong>.class</strong> file) using the Java Compiler (<strong>javac</strong>) which comes inbuilt with <strong>JDK</strong>. This bytecode is in <strong>hexadecimal</strong> format with <strong>opcode-operand</strong> lines and <strong>JVM</strong> can interpret these instructions (without further recompilations) into native machine language which can be understood by the OS and underlying hardware platform. Therefore, bytecode acts as a <strong>platform-independent</strong> intermediary state which is <strong>portable</strong> among any JVM regardless of underlying OS and hardware architecture. However, since JVMs are developed to run and communicate with the underlying hardware &amp; OS structure, we need to select the appropriate JVM version for our <strong>OS version</strong> (Windows, Linux, Mac) and <strong>processor architecture</strong> (x86, x64).</p><p>Most of us know the above story of Java and the problem here is that the most important component of this process — the JVM is taught to us as a black box which can magically interpret bytecode and perform many run-time activities like <strong>JIT</strong> (Just-in-time) compilation &amp; <strong>GC</strong> (Garbage Collection) during the program execution. In the next sections, let’s reveal how JVM works.</p><p>JVM is only a specification, and its implementation is different from vendor to vendor. For now, let’s understand the commonly-accepted architecture of JVM as defined in the specification.</p><p><img src="https://miro.medium.com/max/643/0*GMXQBZCEpGQMBjy-" alt></p><p>JVM Architecture</p><p>The <strong>JVM resides on the RAM</strong>. During execution, using the Class Loader subsystem, the class files are brought on to the RAM. This is called Java’s <strong>dynamic class loading</strong> functionality. It loads, links, and initializes the class file (.class) when it refers to a class for the first time at runtime (not compile time).</p><h2><span id="11-loading">1.1) Loading</span><a href="#11-loading" class="header-anchor">#</a></h2><p>Loading compiled classes (.class files) into memory is the major task of Class Loader. Usually, the class loading process starts from loading the main class (i.e. class with <code>static main()</code> method declaration). All the subsequent class loading attempts are done according to the class references in the already-running classes as mentioned in the following cases:</p><ul><li>When bytecode make a static reference to a class (e.g. <code>System.out</code>)</li><li>When bytecode create a class object (e.g. <code>Person person = new Person(&quot;John&quot;)</code>)</li></ul><p>There are 3 types of class loaders (connected with inheritance property) and they follow 4 major principles.</p><p><strong><em>1.1.1) Visibility Principle</em></strong></p><p>This principle states that Child Class Loader can see the class loaded by Parent Class Loader, but a Parent Class Loader cannot find the class loaded by Child Class Loader.</p><p><strong><em>1.1.2) Uniqueness Principle</em></strong></p><p>This principle states that a class loaded by parent should not be loaded by Child Class Loader again and ensure that duplicate class loading does not occur.</p><p><strong><em>1.1.3) Delegation Hierarchy Principle</em></strong></p><p>In order to satisfy above 2 principles, JVM follows a hierarchy of delegation to choose the class loader for each class loading request. Here, starting from the lowest child level, Application Class Loader delegates the received class loading request to Extension Class Loader and then Extension Class Loader delegates the request to Bootstrap Class Loader. If the requested class found in Bootstrap path, the class is loaded. Otherwise the request again transfers back to Extension Class Loader level to find the class from Extension path or custom-specified path. If it also fails, the request comes back to Application Class Loader to find the class from System class path and if Application Class Loader also fails to load the requested class, then we get the run time exception — <code>java.lang.ClassNotFoundException</code> .</p><p><strong><em>1.1.4) No Unloading Principle</em></strong></p><p>Even though a Class Loader can load a class, it cannot unload a loaded class. Instead of unloading, the current class loader can be deleted, and a new class loader can be created.</p><p><img src="https://miro.medium.com/max/30/0*MCf4PciEbMGwOL6L?q=20" alt></p><p><img src="https://miro.medium.com/max/640/0*MCf4PciEbMGwOL6L" alt></p><p><em>Java Class Loaders — Delegation Hierarchy Principle (Image: <a href="http://StackOverflow.com">StackOverflow.com</a>)</em></p><ul><li><strong>Bootstrap Class Loader</strong> loads standard JDK classes from rt.jar such as core Java API classes present in the bootstrap path — $JAVA_HOME/jre/lib directory (e.g. java.lang.* package classes). It is implemented in native languages like C/C++ and acts as parent of all class loaders in Java.</li><li><strong>Extension Class Loader</strong> delegates class loading request to its parent, Bootstrap and if unsuccessful, loads classes from the extensions directories (e.g. security extension functions) in extension path — $JAVA_HOME/jre/lib/ext or any other directory specified by the java.ext.dirs system property. This Class Loader is implemented in Java by the sun.misc.Launcher$ExtClassLoader class.</li><li><strong>System/Application Class Loader</strong> loads application specific classes from system class path, that can be set while invoking a program using -cp or -classpath command line options. It internally uses Environment Variable which mapped to java.class.path. This Class Loader is implemented in Java by the sun.misc.Launcher$AppClassLoader class.</li></ul><p><em>NOTE: Apart from the 3 major Class Loaders discussed above, a programmer can directly create a</em> <strong><em>User-defined Class Loader</em></strong> <em>on the code itself. This guarantees the independence of applications through class loader delegation model. This approach is used in web application servers like Tomcat to make web apps and enterprise solutions run independently.</em></p><p>Each Class Loader has its <strong>namespace</strong> that stores the loaded classes. When a Class Loader loads a class, it searches the class based on <strong>FQCN</strong> (<strong>Fully Qualified Class Name</strong>) stored in the namespace to check whether or not the class has been already loaded. Even if the class has an identical FQCN but a different namespace, it is regarded as a different class. A different namespace means that the class has been loaded by another Class Loader.</p><h2><span id="12-linking">1.2) Linking</span><a href="#12-linking" class="header-anchor">#</a></h2><p>Linking involves in verifying and preparing a loaded class or interface, its direct superclasses and superinterfaces, and its element type as necessary, while following the below properties.</p><ul><li>A class or interface must be completely loaded before it is linked.</li><li>A class or interface must be completely verified and prepared before it initialized (in the next step).</li><li>If an error occurs during linking, it is thrown at a point in the program where some action will be taken by the program that might, directly or indirectly, require linkage to the class or interface involved in the error.</li></ul><p>Linking occurs in 3 stages as below.</p><ul><li><strong>Verification</strong>: ensure the correctness of .class file (is the code properly written according to Java Language Specification? is it generated by a valid compiler according to JVM specifications?). This is the most complicated test process of the class load processes, and takes the longest time. Even though linking slows down the class loading process, it avoids the need to perform these checks for multiple times when executing bytecode, hence makes the overall execution efficient and effective. If verification fails, it throws runtime errors (java.lang.VerifyError). For instance, the following checks are performed.</li></ul><p>- consistent and correctly formatted symbol table<br>- final methods / classes not overridden<br>- methods respect access control keywords<br>- methods have correct number and type of parameters<br>- bytecode doesn’t manipulate stack incorrectly<br>- variables are initialized before being read<br>- variables are a value of the correct type</p><ul><li><strong>Preparation:</strong> allocate memory for static storage and any data structures used by the JVM such as method tables. Static fields are created and initialized to their default values, however, no initializers or code is executed at this stage as that happens as part of initialization.</li><li><strong>Resolution:</strong> replace symbolic references from the type with direct references. It is done by searching into method area to locate the referenced entity.</li></ul><h2><span id="13-initialization">1.3) Initialization</span><a href="#13-initialization" class="header-anchor">#</a></h2><p>Here, the initialization logic of each loaded class or interface will be executed (e.g. calling the constructor of a class). Since JVM is multi-threaded, initialization of a class or interface should happen very carefully with proper synchronization to avoid some other thread from trying to initialize the same class or interface at the same time (i.e. make it <strong>thread safe</strong>).</p><p>This is the final phase of class loading where all the static variables are assigned with their original values defined in the code and the static block will be executed (if any). This is executed line by line from top to bottom in a class and from parent to child in class hierarchy.</p><p>Runtime Data Areas are the memory areas assigned when the JVM program runs on the OS. In addition to reading .class files, the Class Loader subsystem generates corresponding binary data and save the following information in the Method area for each class separately.</p><ul><li>Fully qualified name of the loaded class and its immediate parent class</li><li>Whether .class file is related to a Class/Interface/Enum</li><li>Modifiers, static variables, and method information etc.</li></ul><p>Then, for every loaded .class file, it creates exactly one object of Class to represent the file in the Heap memory as defined in java.lang package. This Class object can be used to read class level information (class name, parent name, methods, variable information, static variables etc.) later in our code.</p><h2><span id="21-method-area-shared-among-threads">2.1) Method Area (Shared among Threads)</span><a href="#21-method-area-shared-among-threads" class="header-anchor">#</a></h2><p>This is a shared resource (only 1 method area per JVM). All JVM threads share this same Method area, so the <strong>access to the Method data and the process of dynamic linking must be thread safe</strong>.</p><p>Method area stores <strong>class level data</strong> (including <strong>static variables</strong>) such as:</p><ul><li>Classloader reference</li><li>Run time constant pool — Numeric constants, field references, method references, attributes; As well as the constants of each class and interface, it contains all references for methods and fields. When a method or field is referred to, the JVM searches the actual address of the method or field on the memory by using the runtime constant pool.</li><li>Field data — Per field: name, type, modifiers, attributes</li><li>Method data — Per method: name, return type, parameter types (in order), modifiers, attributes</li><li>Method code — Per method: bytecodes, operand stack size, local variable size, local variable table, exception table; Per exception handler in exception table: start point, end point, PC offset for handler code, constant pool index for exception class being caught</li></ul><h2><span id="22-heap-area-shared-among-threads">2.2) Heap Area (Shared among Threads)</span><a href="#22-heap-area-shared-among-threads" class="header-anchor">#</a></h2><p>This is also a shared resource (only 1 heap area per JVM). Information of all <strong>objects</strong> and their corresponding <strong>instance variables and arrays</strong> are stored in the Heap area. Since the Method and Heap areas share memory for multiple threads, the <strong>data stored in Method &amp; Heap areas are not thread safe</strong>. Heap area is a great target for GC.</p><h2><span id="23-stack-area-per-thread">2.3) Stack Area (per Thread)</span><a href="#23-stack-area-per-thread" class="header-anchor">#</a></h2><p>This is not a shared resource. For every JVM thread, when the thread starts, a separate <strong>runtime stack</strong> gets created in order to store <strong>method calls</strong>. For every such method call, one entry will be created and added (pushed) into the top of runtime stack and such entryit is called a <strong>Stack Frame</strong>.</p><p>Each stack frame has the reference for local variable array, Operand stack, and runtime constant pool of a class where the method being executed belongs. The size of local variable array and Operand stack is determined while compiling. Therefore, the size of stack frame is fixed according to the method.</p><p>The frame is removed (popped) when the method returns normally or if an uncaught exception is thrown during the method invocation. Also note that if any exception occurs, each line of the stack trace (shown as a method such as printStackTrace()) expresses one stack frame. The <strong>Stack area is thread safe</strong> since it is not a shared resource.</p><p><img src="https://miro.medium.com/max/30/0*9GyWqgKUyoo-F2_g?q=20" alt></p><p><em>JVM Stack Configuration (Image: <a href="http://Cubrid.org">Cubrid.org</a>)</em></p><p>A Stack Frame is divided into three sub-entities:</p><ul><li><strong>Local Variable Array</strong> — It has an index starting from 0. For a particular method, how many local variables are involved and the corresponding values are stored here. 0 is the reference of a class instance where the method belongs. From 1, the parameters sent to the method are saved. After the method parameters, the local variables of the method are saved.</li><li><strong>Operand Stack</strong> — This acts as a runtime workspace to perform any intermediate operation if there’s a requirement. Each method exchanges data between the Operand stack and the local variable array, and pushes or pops other method invoke results. The necessary size of the Operand stack space can be determined during compiling. Therefore, the size of the Operand stack can also be determined during compiling.</li><li><strong>Frame Data</strong> — All symbols related to the method are stored here. For exceptions, the catch block information will also be maintained in the frame data.</li></ul><p>Since these are runtime stack frames, after a thread terminates, its stack frame will also be destroyed by JVM.</p><p>A stack can be a dynamic or fixed size. If a thread requires a larger stack than allowed a StackOverflowError is thrown. If a thread requires a new frame and there isn’t enough memory to allocate it then an OutOfMemoryError is thrown.</p><h2><span id="24-pc-registers-per-thread">2.4) PC Registers (per Thread)</span><a href="#24-pc-registers-per-thread" class="header-anchor">#</a></h2><p>For each JVM thread, when the thread starts, a separate PC (Program Counter) Register gets created in order to hold the address of currently-executing instruction (memory address in the Method area). If the current method is native then the PC is undefined. Once the execution finishes, the PC register gets updated with the address of next instruction.</p><h2><span id="25-native-method-stack-per-thread">2.5) Native Method Stack (per Thread)</span><a href="#25-native-method-stack-per-thread" class="header-anchor">#</a></h2><p><strong>There is a direct mapping between a Java thread and a native operating system thread</strong>. After preparing all the state for a Java thread, a separate native stack also gets created in order to store native method information (often written in C/C++) invoked through JNI (Java Native Interface).</p><p>Once the native thread has been created and initialized, it invokes the run()method in the Java thread. When the run() method returns, uncaught exceptions (if any) are handled, then the native thread confirms whether the JVM needs to be terminated as a result of the thread terminating (i.e. is it the last non-deamon thread). When the thread terminates, all resources for both the native and Java threads are released.</p><p>The native thread is reclaimed once the Java thread terminates. The operating system is therefore responsible for scheduling all threads and dispatching them to any available CPU.</p><p>The actual execution of the bytecode occurs here. Execution Engine executes the instructions in the bytecode line-by-line by reading the data assigned to above runtime data areas.</p><h2><span id="31-interpreter">3.1) Interpreter</span><a href="#31-interpreter" class="header-anchor">#</a></h2><p>The interpreter interprets the bytecode and executes the instructions one-by-one. Hence, it can interpret one bytecode line quickly, but executing the interpreted result is a slower task. The disadvantage is that when one method is called multiple times, each time a new interpretation and a slower execution are required.</p><h2><span id="32-just-in-time-jit-compiler">3.2) Just-In-Time (JIT) Compiler</span><a href="#32-just-in-time-jit-compiler" class="header-anchor">#</a></h2><p>If only the interpreter is available, when one method is called multiple times, each time the interpretation will also occur, which is a redundant operation if handled efficiently. This has become possible with JIT compiler. First, it compiles the entire bytecode to native code (machine code). Then for repeated method calls, it directly provides the native code and the execution using native code is much faster than interpreting instructions one by one. The native code is stored in the cache, thus the compiled code can be executed quicker.</p><p>However, even for JIT compiler, it takes more time for compiling than for the interpreter to interpret. For a code segment that executes just once, it is better to interpret it instead of compiling. Also the native code is stored in the cache, which is an expensive resource. With these circumstances, JIT compiler internally checks the frequency of each method call and decides to compile each only when the selected method has occurred more than a certain level of times. This idea of <strong>adaptive compiling</strong> has been used in Oracle Hotspot VMs.</p><p>Execution Engine qualifies to become a key subsystem when introducing performance optimizations by JVM vendors. Among such efforts, the following 4 components can largely improve its performance.</p><ul><li><strong>Intermediate Code Generator</strong> produces <strong>intermediate code</strong>.</li><li><strong>Code Optimizer</strong> is responsible for optimizing the intermediate code generated above.</li><li><strong>Target Code Generator</strong> is responsible for generating <strong>Native Code</strong> (i.e. <strong>Machine Code</strong>).</li><li><strong>Profiler</strong> is a special component, responsible for finding performance bottlenecks a.k.a. <strong>hotspots</strong> (e.g. instances where one method is called multiple times)</li></ul><h2><span id="vendor-approaches-for-compiling-optimizations">Vendor Approaches for Compiling Optimizations</span><a href="#vendor-approaches-for-compiling-optimizations" class="header-anchor">#</a></h2><p><strong><em>Oracle Hotspot VMs</em></strong></p><p>Oracle has 2 implementations of their standard Java VMs with a popular JIT compiler model called <strong>Hotspot Compiler</strong>. Through <strong>profiling</strong>, it can identify the hotspots that require JIT compiling the most and then compile those performance critical portions of the code to native code. Over time, if such compiled method is no longer frequently invoked, it identifies the method as no longer a hotspot and quickly removes the native code from the cache and starts running in interpreter mode. This methodology creates a boost in performance , while avoiding unnecessary compilation of seldom used code. Additionally, on the fly, the Hotspot Compiler decides how best to optimize compiled code with techniques such as in lining. The run time analysis performed by the compiler allows it to eliminate guesswork in determining which optimizations will yield the largest performance benefit.</p><p>These VMs use an identical runtime (interpreter, memory, threads), but custom built implementations of the JIT compiler as mentioned below.</p><ul><li><strong>Oracle Java Hotspot Client VM</strong> is the default VM technology for Oracle JDK and JRE. It is tuned for best performance when running applications in a client environment by reducing application start up time and memory footprint.</li><li><strong>Oracle Java Hotspot Server VM</strong> is designed for maximum program execution speed for applications running in a server environment. The JIT compiler used here is called Advanced Dynamic Optimizing Compiler and uses more complex and diverse performance optimization techniques. The Java HotSpot Server VM is invoked by using the server command line option (e.g. java server MyApp)</li></ul><p>The Oracle’s Java Hotspot technology is famous for its rapid memory allocation, fast and efficient GC, and readily-scalable thread-handling capability in large shared memory multiprocessor servers.</p><p><strong><em>IBM AOT (Ahead-Of-Time) Compiling</em></strong></p><p>The specialty here is that these JVMs share the native code compiled through the shared cache, thus the code that has been already compiled through the AOT compiler can be used by another JVM without compiling. In addition, IBM JVM provides a fast way of execution by pre-compiling code to JXE (Java Executable) file format using the AOT compiler.</p><h2><span id="33-garbage-collector-gc">3.3) Garbage Collector (GC)</span><a href="#33-garbage-collector-gc" class="header-anchor">#</a></h2><p>As long as an object is being referenced, the JVM considers it alive. Once an object is no longer referenced and therefore is not reachable by the application code, the garbage collector removes it and reclaims the unused memory. In general, garbage collection happens under the hood, however we can trigger it by calling System.gc() method (Again the execution is not guaranteed. Hence, call Thread.sleep(1000) and wait for GC to complete).</p><p>This interface is used to interact with Native Method Libraries required for the execution and provide the capabilities of such Native Libraries (often written in C/C++). This enables JVM to call C/C++ libraries and to be called by C/C++ libraries which may be specific to hardware.</p><p>This is a collection of C/C++ Native Libraries which is required for the Execution Engine and can be accessed through the provided Native Interface.</p><p>We discussed on how a Java program gets executed, but didn’t specifically mention about the executors. Actually to perform each task we discussed earlier, the JVM concurrently runs multiple threads. Some of these threads carry the programming logic and are created by the program (<strong>application threads</strong>), while the rest is created by JVM itself to undertake background tasks in the system (<strong>system threads</strong>).</p><p>The major application thread is the <strong>main thread</strong> which is created as part of invoking public static void main(String[]) and all other application threads are created by this main thread. Application threads perform tasks such as executing instructions starting with main() method, creating objects in Heap area if it finds new keyword in any method logic etc.</p><p>The major system threads are as follows.</p><ul><li><p><strong>Compiler threads</strong>: At runtime, compilation of bytecode to native code is undertaken by these threads.</p></li><li><p><strong>GC threads</strong>: All the GC related activities are carried out by these threads.</p></li><li><p><strong>Periodic task thread</strong>: The timer events (i.e. interrupts) to schedule execution of periodic operations are performed by this thread.</p></li><li><p><strong>Signal dispatcher thread</strong>: This thread receives signals sent to the JVM process and handle them inside the JVM by calling the appropriate JVM methods.</p></li><li><p><strong>VM thread</strong>: As a pre-condition, some operations need the JVM to arrive at a safe point where modifications to the Heap area does no longer happen. Examples for such scenarios are “stop-the-world” garbage collections, thread stack dumps, thread suspension and biased locking revocation. These operations can be performed on a special thread called VM thread.</p></li><li><p>Java is considered as both interpreted and compiled Language.</p></li><li><p>By design, Java is slow due to dynamic linking and run-time interpreting.</p></li><li><p>JIT compiler compensate for the disadvantages of the interpreter for repeating operations by keeping a native code instead of bytecode.</p></li><li><p>The latest Java versions address performance bottlenecks in its original architecture.</p></li><li><p>JVM is only a specification. Vendors are free to customize, innovate, and improve its performance during the implementation.</p></li></ul><p>I have already published on”<a href="https://medium.com/platform-engineer/understanding-java-memory-model-1d0863f6d973">Understanding Java Memory Model</a>” the next post of this Java Ecosystem blog series. In the future, I will be writing on topics related to Java Performance Management. Stay excited for more awesome posts!</p><ul><li>Understanding JVM Internals (<a href="https://www.cubrid.org/blog/understanding-jvm-internals/">https://www.cubrid.org/blog/understanding-jvm-internals/</a>)</li><li>JVM Internals (<a href="https://www.cubrid.org/blog/understanding-jvm-internals/">https://www.cubrid.org/blog/understanding-jvm-internals/</a>)</li><li>JVM Explained (<a href="https://javatutorial.net/jvm-explained">https://javatutorial.net/jvm-explained</a>)</li><li>The JVM Architecture Explained (<a href="https://dzone.com/articles/jvm-architecture-explained">https://dzone.com/articles/jvm-architecture-explained</a>)</li><li>How JVM Works — JVM Architecture? (<a href="https://www.geeksforgeeks.org/jvm-works-jvm-architecture/">https://www.geeksforgeeks.org/jvm-works-jvm-architecture/</a>)</li><li>Diffrenence between AppClassloader and SystemClassloader (<a href="https://stackoverflow.com/questions/34650568/diffrenence-between-appclassloader-and-systemclassloader">https://stackoverflow.com/questions/34650568/diffrenence-between-appclassloader-and-systemclassloader</a>)</li></ul><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://medium.com/@ThilinaAshenGamage?source=post_page-----22c0ddf09722--------------------------------&quot;&gt;&lt;img src=&quot;https://miro</summary>
      
    
    
    
    <category term="后端" scheme="https://blog.beyhub.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://blog.beyhub.com/tags/Java/"/>
    
    <category term="JVM" scheme="https://blog.beyhub.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>后端/JavaMemoryModel.md</title>
    <link href="https://blog.beyhub.com/p/476907c7a509/"/>
    <id>https://blog.beyhub.com/p/476907c7a509/</id>
    <published>2021-09-07T09:14:55.000Z</published>
    <updated>2021-09-07T09:24:41.235Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://medium.com/@ThilinaAshenGamage?source=post_page-----1d0863f6d973--------------------------------"><img src="https://miro.medium.com/fit/c/48/48/2*OPRSXMnY00Kju7oC3u6jzQ.jpeg" alt="Thilina Ashen Gamage"></a></p><p>Understanding Java Memory Model is an essential learning for serious Java developers who develop, deploy, monitor, test, and tune performance of a Java application. In this blog post, we are going to discuss on Java memory model and how each part of JVM memory contributes to run our programs.</p><p>对于一个Java开发者来说，在Java应用的开发、部署、监控、测试以及性能调优过程中，JMM（Java内存模型）是非常必要的知识。在这篇文章中，我们将探讨JMM以及JVM内存如何支持我们的程序运行。</p><p>First of all, check whether you understand the following diagram of JVM architecture. If you are not familiar with it, I highly suggest you to skim through my previous post (“<a href="https://medium.com/platform-engineer/understanding-jvm-architecture-22c0ddf09722">Java Ecosystem (Part 1): Understanding JVM Architecture</a>“) and refresh your knowledge.</p><p>首先，你可以通过下面这张架构图检查你是否理解JVM的技术架构。如果你对它不熟悉，建议你阅读</p><p><img src="https://miro.medium.com/max/643/0*aO7jvEaMLhADKTqa" alt></p><p><em>JVM Architecture</em></p><p>You must have used some of the following JVM memory configurations when running resource-intensive Java programs.</p><ul><li>-XmsSetting — initial Heap size</li><li>-XmxSetting — maximum Heap size</li><li>-XX:NewSizeSetting — new generation heap size</li><li>-XX:MaxNewSizeSetting — maximum New generation heap size</li><li>-XX:MaxPermGenSetting — maximum size of Permanent generation</li><li>-XX:SurvivorRatioSetting — new heap size ratios (e.g. if Young Gen size is 10m and memory switch is –XX:SurvivorRatio=2, then 5m will be reserved for Eden space and 2.5m each for both Survivor spaces, default value = 8)</li><li>-XX:NewRatio — providing ratio of Old/New Gen sizes (default value = 2)</li></ul><p>But have you ever wondered how your JVM resides on memory? Let me show it. Just like any other software, JVM consumes the available space on host OS memory.</p><p><img src="https://miro.medium.com/max/23/0*PsZ2aKjG_tAPCQdp?q=20" alt></p><p><em>Host OS Memory and JVM</em></p><p>However, inside JVM, there exist separate memory spaces (Heap, Non-Heap, Cache) in order to store runtime data and compiled code.</p><ul><li>Heap is divided into 2 parts — <strong>Young Generation</strong> and <strong>Old Generation</strong></li><li>Heap is allocated when JVM starts up (Initial size: -Xms)</li><li>Heap size increases/decreases while the application is running</li><li>Maximum size: -Xmx</li></ul><p><img src="https://miro.medium.com/max/30/0*rzQ6-DyP-2gjiua7?q=20" alt></p><p><em>JVM Heap Memory</em></p><h2><span id="11-young-generation">1.1) Young Generation</span><a href="#11-young-generation" class="header-anchor">#</a></h2><ul><li>This is reserved for containing newly-allocated objects</li><li>Young Gen includes three parts — <strong>Eden Memory</strong> and two <strong>Survivor Memory spaces (S0, S1)</strong></li><li>Most of the newly-created objects goes Eden space.</li><li>When Eden space is filled with objects, <strong>Minor GC</strong> (a.k.a. <strong>Young Collection</strong>) is performed and all the survivor objects are moved to one of the survivor spaces.</li><li>Minor GC also checks the survivor objects and move them to the other survivor space. So at a time, one of the survivor space is always empty.</li><li>Objects that are survived after many cycles of GC, are moved to the Old generation memory space. Usually it’s done by setting a threshold for the age of the young generation objects before they become eligible to promote to Old generation.</li></ul><h2><span id="12-old-generation">1.2) Old Generation</span><a href="#12-old-generation" class="header-anchor">#</a></h2><ul><li><p>This is reserved for containing long lived objects that could survive after many rounds of Minor GC</p></li><li><p>When Old Gen space is full, <strong>Major GC</strong> (a.k.a. <strong>Old Collection</strong>) is performed (usually takes longer time)</p></li><li><p>This includes <strong>Permanent Generation</strong> (Replaced by <strong>Metaspace</strong> since Java 8)</p></li><li><p>Perm Gen stores per-class structures such as runtime constant pool, field and method data, and the code for methods and constructors, as well as interned Strings</p></li><li><p>Its size can be changed using -XX:PermSize and -XX:MaxPermSize</p></li></ul><p><img src="https://miro.medium.com/max/30/0*28wQjfFfyVZURF1D?q=20" alt></p><p><em>JVM Non-Heap &amp; Cache Memory</em></p><ul><li>This includes <strong>Code Cache</strong></li><li>Stores compiled code (i.e. native code) generated by JIT compiler, JVM internal structures, loaded profiler agent code and data, etc.</li><li>When Code Cache exceeds a threshold, it gets flushed (and objects are not relocated by the GC).</li></ul><p>So far I did not mention anything about Java Stack memory because I wanted to highlight its difference separately. First, take a look at the below image and check whether you know what’s happening here. I have already discussed on JVM Stack in my <a href="https://platformengineer.com/2018/08/18/java-ecosystem-jvm-architecture/">previous post.</a></p><p><img src="https://miro.medium.com/max/700/0*wb2jnlwFp6kRLYyh" alt></p><p><em>JVM Stack, Non-Heap, and Heap (Image: <a href="http://jamesdbloom.com">jamesdbloom.com</a>)</em></p><p>Anyway long story short, Java Stack memory is used for execution of a thread and it contains method specific values and references to other objects in Heap. Let’s put both Stack and Heap into a table and see their differences.</p><p><img src="https://miro.medium.com/max/22/1*9cAi-fSA5GpriBYWh6ZW1Q.png?q=20" alt></p><p>Here’s a nice example (from <a href="http://baeldung.com">baeldung.com</a>) on how Stack and Heap contribute to execute a simple program (Check the stack order with the code).</p><p>class Person {<br>int pid;<br>String name;// constructor, setters/getters<br>}public class Driver {<br>public static void main(String[] args) {<br>int id = 23;<br>String pName = “Jon”;<br>Person p = null;<br>p = new Person(id, pName);<br>}<br>}</p><p><img src="https://miro.medium.com/max/30/0*HWkfCG1q4DFsFfoF?q=20" alt></p><p><em>Stack Memory &amp; Heap Space in Java (Image: <a href="http://baeldung.com">baeldung.com</a>)</em></p><p>The above Java memory model is the most commonly-discussed implementation. However, the latest JVM versions have different modifications such as introducing the following new memory spaces.</p><ul><li><strong>Keep Area</strong> — a new memory space in the Young Generation to contain the most recently allocated objects. No GC is performed until the next Young Generation. This area prevents objects from being promoted just because they were allocated right before a young collection is started.</li><li><strong>Metaspace</strong> — Since Java 8, Permanent Generation is replaced by Metaspace. It can auto increase its size (up to what the underlying OS provides) even though Perm Gen always has a fixed maximum size. As long as the classloader is alive, the metadata remains alive in the Metaspace and can’t be freed.</li></ul><p><em>NOTE:</em> <em>You are always advised to go through the vendor docs to find out what works for your JVM version.</em></p><p>When there is a critical memory issue, the JVM gets crashed and throws an error indication in your program output like below.</p><ul><li><strong>java.lang.StackOverFlowError</strong> — indicates that Stack Memory is full</li><li><strong>java.lang.OutOfMemoryError: Java heap space</strong> — indicates that Heap Memory is full</li><li><strong>java.lang.OutOfMemoryError: GC Overhead limit exceeded</strong> — indicates that GC has reached its overhead limit</li><li><strong>java.lang.OutOfMemoryError: Permgen space</strong> — indicates that Permanent Generation space is full</li><li><strong>java.lang.OutOfMemoryError: Metaspace</strong> — indicates that Metaspace is full (since Java 8)</li><li><strong>java.lang.OutOfMemoryError: Unable to create new native thread</strong> — indicates that JVM native code can no longer create a new native thread from the underlying operating system because so many threads have been already created and they consume all the available memory for the JVM</li><li><strong>java.lang.OutOfMemoryError: request size bytes for reason</strong> — indicates that swap memory space is fully consumed by application</li><li><strong>java.lang.OutOfMemoryError: Requested array size exceeds VM limit</strong>– indicates that our application uses an array size more than the allowed size for the underlying platform</li></ul><p>However, what you have to thoroughly understand is that these outputs can only indicate the impact that the JVM had, not the actual error. The actual error and its root cause conditions can occur somewhere in your code (e.g. memory leak, GC issue, synchronization problem), resource allocation, or maybe even hardware setting. Therefore, I can’t advise you to simply increase the affected resource size to solve the problem. Maybe you will need to monitor resource usage, profile each category, go through heap dumps, check and debug/optimize your code etc. And if none of your efforts seems to work and/or your context knowledge indicates that you need more resources, go for it.</p><p>During my undergraduate research on JVM performance aspects, we found several approaches used by the industry to minimize the impact of performance faults like memory errors. Let’s discuss about Java Performance Management in-depth very soon. In the meantime, read the next blog post of this series in which I explain <a href="https://medium.com/platform-engineer/understanding-java-garbage-collection-54fc9230659a">how Java Garbage Collection really works</a> under the hood. Stay excited with this blog for more exciting posts!</p><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://medium.com/@ThilinaAshenGamage?source=post_page-----1d0863f6d973--------------------------------&quot;&gt;&lt;img src=&quot;https://miro</summary>
      
    
    
    
    <category term="后端" scheme="https://blog.beyhub.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://blog.beyhub.com/tags/Java/"/>
    
    <category term="JMM" scheme="https://blog.beyhub.com/tags/JMM/"/>
    
  </entry>
  
  <entry>
    <title>从ReentrantLock的实现看AQS的原理</title>
    <link href="https://blog.beyhub.com/p/74ca2f9792d3/"/>
    <id>https://blog.beyhub.com/p/74ca2f9792d3/</id>
    <published>2021-08-24T11:16:18.755Z</published>
    <updated>2021-08-25T01:05:30.131Z</updated>
    
    <content type="html"><![CDATA[<p>Java中的大部分同步类（Lock、Semaphore、ReentrantLock等）都是基于AbstractQueuedSynchronizer（简称为AQS）实现的。AQS是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架。本文会从应用层逐渐深入到原理层，并通过ReentrantLock的基本特性和ReentrantLock与AQS的关联，来深入解读AQS相关独占锁的知识点，同时采取问答的模式来帮助大家理解AQS。由于篇幅原因，本篇文章主要阐述AQS中独占锁的逻辑和Sync Queue，不讲述包含共享锁和Condition Queue的部分（本篇文章核心为AQS原理剖析，只是简单介绍了ReentrantLock，感兴趣同学可以阅读一下ReentrantLock的源码）。</p><span id="more"></span><p>下面列出本篇文章的大纲和思路，以便于大家更好地理解：<br><img src="https://p1.meituan.net/travelcube/9d182d944e0889c304ef529ba50a4fcd205214.png" alt></p><h2><span id="1-reentrantlock">1 ReentrantLock</span><a href="#1-reentrantlock" class="header-anchor">#</a></h2><h3><span id="11-reentrantlock特性概览">1.1 ReentrantLock特性概览</span><a href="#11-reentrantlock特性概览" class="header-anchor">#</a></h3><p>ReentrantLock意思为可重入锁，指的是一个线程能够对一个临界资源重复加锁。为了帮助大家更好地理解ReentrantLock的特性，我们先将ReentrantLock跟常用的Synchronized进行比较，其特性如下（蓝色部分为本篇文章主要剖析的点）：</p><p><img src="https://p0.meituan.net/travelcube/412d294ff5535bbcddc0d979b2a339e6102264.png" alt></p><p>下面通过伪代码，进行更加直观的比较：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (object) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span> <span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span> <span class="params">()</span> throw Exception </span>&#123;</span><br><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(lock.tryLock(<span class="number">100</span>, TimeUnit.MILLISECONDS))&#123; &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">lock.unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="12-reentrantlock与aqs的关联">1.2 ReentrantLock与AQS的关联</span><a href="#12-reentrantlock与aqs的关联" class="header-anchor">#</a></h3><p>通过上文我们已经了解，ReentrantLock支持公平锁和非公平锁（关于公平锁和非公平锁的原理分析，可参考《<a href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=2651749434&amp;idx=3&amp;sn=5ffa63ad47fe166f2f1a9f604ed10091&amp;chksm=bd12a5778a652c61509d9e718ab086ff27ad8768586ea9b38c3dcf9e017a8e49bcae3df9bcc8&amp;scene=38#wechat_redirect">不可不说的Java“锁”事</a>》），并且ReentrantLock的底层就是由AQS来实现的。那么ReentrantLock是如何通过公平锁和非公平锁与AQS关联起来呢？ 我们着重从这两者的加锁过程来理解一下它们与AQS之间的关系（加锁过程中与AQS的关联比较明显，解锁流程后续会介绍）。</p><p>非公平锁源码中的加锁流程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块代码的含义为：</p><ul><li><p>若通过CAS设置变量State（同步状态）成功，也就是获取锁成功，则将当前线程设置为独占线程。</p></li><li><p>若通过CAS设置变量State（同步状态）失败，也就是获取锁失败，则进入Acquire方法进行后续处理。</p></li></ul><p>第一步很好理解，但第二步获取锁失败后，后续的处理策略是怎么样的呢？这块可能会有以下思考：</p><ul><li>某个线程获取锁失败的后续流程是什么呢？有以下两种可能：</li></ul><p>(1) 将当前线程获锁结果设置为失败，获取锁流程结束。这种设计会极大降低系统的并发度，并不满足我们实际的需求。所以就需要下面这种流程，也就是AQS框架的处理流程。</p><p>(2) 存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。</p><ul><li><p>对于问题1的第二种情况，既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？</p></li><li><p>处于排队等候机制中的线程，什么时候可以有机会获取锁呢？</p></li><li><p>如果处于排队等候机制中的线程一直无法获取锁，还是需要一直等待吗，还是有别的策略来解决这一问题？</p></li></ul><p>带着非公平锁的这些问题，再看下公平锁源码中获锁的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static final class FairSync extends Sync &#123;</span><br><span class="line">  ...  </span><br><span class="line">final void lock() &#123;</span><br><span class="line">acquire(1);</span><br><span class="line">&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这块代码，我们可能会存在这种疑问：Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？</p><p>结合公平锁和非公平锁的加锁流程，虽然流程上有一定的不同，但是都调用了Acquire方法，而Acquire方法是FairSync和UnfairSync的父类AQS中的核心方法。</p><p>对于上边提到的问题，其实在ReentrantLock类源码中都无法解答，而这些问题的答案，都是位于Acquire方法所在的类AbstractQueuedSynchronizer中，也就是本文的核心——AQS。下面我们会对AQS以及ReentrantLock和AQS的关联做详细介绍（相关问题答案会在2.3.5小节中解答）。</p><h2><span id="2-aqs">2 AQS</span><a href="#2-aqs" class="header-anchor">#</a></h2><p>首先，我们通过下面的架构图来整体了解一下AQS框架：</p><p><img src="https://p1.meituan.net/travelcube/82077ccf14127a87b77cefd1ccf562d3253591.png" alt></p><ul><li><p>上图中有颜色的为Method，无颜色的为Attribution。</p></li><li><p>总的来说，AQS框架共分为五层，自上而下由浅入深，从AQS对外暴露的API到底层基础数据。</p></li><li><p>当有自定义同步器接入时，只需重写第一层所需要的部分方法即可，不需要关注底层具体的实现流程。当自定义同步器进行加锁或者解锁操作时，先经过第一层的API进入AQS内部方法，然后经过第二层进行锁的获取，接着对于获取锁失败的流程，进入第三层和第四层的等待队列处理，而这些处理方式均依赖于第五层的基础数据提供层。</p></li></ul><p>下面我们会从整体到细节，从流程到方法逐一剖析AQS框架，主要分析过程如下：</p><p><img src="https://p1.meituan.net/travelcube/d2f7f7fffdc30d85d17b44266c3ab05323338.png" alt></p><h3><span id="21-原理概览">2.1 原理概览</span><a href="#21-原理概览" class="header-anchor">#</a></h3><p>AQS核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。</p><p>CLH：Craig、Landin and Hagersten队列，是单向链表，AQS中的队列是CLH变体的虚拟双向队列（FIFO），AQS是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配。</p><p>主要原理图如下：</p><p><img src="https://p0.meituan.net/travelcube/7132e4cef44c26f62835b197b239147b18062.png" alt></p><p>AQS使用一个Volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。</p><h4><span id="211-aqs数据结构">2.1.1 AQS数据结构</span><a href="#211-aqs数据结构" class="header-anchor">#</a></h4><p>先来看下AQS中最基本的数据结构——Node，Node即为上面CLH变体队列中的节点。</p><p><img src="https://p1.meituan.net/travelcube/960271cf2b5c8a185eed23e98b72c75538637.png" alt></p><p>解释一下几个方法和属性值的含义：</p><table><thead><tr><th>方法和属性值</th><th>含义</th></tr></thead><tbody><tr><td>waitStatus</td><td>当前节点在队列中的状态</td></tr><tr><td>thread</td><td>表示处于该节点的线程</td></tr><tr><td>prev</td><td>前驱指针</td></tr><tr><td>predecessor</td><td>返回前驱节点，没有的话抛出npe</td></tr><tr><td>nextWaiter</td><td>指向下一个处于CONDITION状态的节点（由于本篇文章不讲述Condition Queue队列，这个指针不多介绍）</td></tr><tr><td>next</td><td>后继指针</td></tr></tbody></table><p>线程两种锁的模式：</p><table><thead><tr><th>模式</th><th>含义</th></tr></thead><tbody><tr><td>SHARED</td><td>表示线程以共享的模式等待锁</td></tr><tr><td>EXCLUSIVE</td><td>表示线程正在以独占的方式等待锁</td></tr></tbody></table><p>waitStatus有下面几个枚举值：</p><table><thead><tr><th>枚举</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>当一个Node被初始化的时候的默认值</td></tr><tr><td>CANCELLED</td><td>为1，表示线程获取锁的请求已经取消了</td></tr><tr><td>CONDITION</td><td>为-2，表示节点在等待队列中，节点线程等待唤醒</td></tr><tr><td>PROPAGATE</td><td>为-3，当前线程处在SHARED情况下，该字段才会使用</td></tr><tr><td>SIGNAL</td><td>为-1，表示线程已经准备好了，就等资源释放了</td></tr></tbody></table><h4><span id="212-同步状态state">2.1.2 同步状态State</span><a href="#212-同步状态state" class="header-anchor">#</a></h4><p>在了解数据结构后，接下来了解一下AQS的同步状态——State。AQS中维护了一个名为state的字段，意为同步状态，是由Volatile修饰的，用于展示当前临界资源的获锁情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private volatile int state;</span><br></pre></td></tr></table></figure><p>下面提供了几个访问这个字段的方法：</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>protected final int getState()</td><td>获取State的值</td></tr><tr><td>protected final void setState(int newState)</td><td>设置State的值</td></tr><tr><td>protected final boolean compareAndSetState(int expect, int update)</td><td>使用CAS方式更新State</td></tr></tbody></table><p>这几个方法都是Final修饰的，说明子类中无法重写它们。我们可以通过修改State字段表示的同步状态来实现多线程的独占模式和共享模式（加锁过程）。</p><p><img src="https://p0.meituan.net/travelcube/27605d483e8935da683a93be015713f331378.png" alt> <img src="https://p0.meituan.net/travelcube/3f1e1a44f5b7d77000ba4f9476189b2e32806.png" alt></p><p>对于我们自定义的同步工具，需要自定义获取同步状态和释放状态的方式，也就是AQS架构图中的第一层：API层。</p><h2><span id="22-aqs重要方法与reentrantlock的关联">2.2 AQS重要方法与ReentrantLock的关联</span><a href="#22-aqs重要方法与reentrantlock的关联" class="header-anchor">#</a></h2><p>从架构图中可以得知，AQS提供了大量用于自定义同步器实现的Protected方法。自定义同步器实现的相关方法也只是为了通过修改State字段来实现多线程的独占模式或者共享模式。自定义同步器需要实现以下方法（ReentrantLock需要实现的方法如下，并不是全部）：</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>protected boolean isHeldExclusively()</td><td>该线程是否正在独占资源。只有用到Condition才需要去实现它。</td></tr><tr><td>protected boolean tryAcquire(int arg)</td><td>独占方式。arg为获取锁的次数，尝试获取资源，成功则返回True，失败则返回False。</td></tr><tr><td>protected boolean tryRelease(int arg)</td><td>独占方式。arg为释放锁的次数，尝试释放资源，成功则返回True，失败则返回False。</td></tr><tr><td>protected int tryAcquireShared(int arg)</td><td>共享方式。arg为获取锁的次数，尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</td></tr><tr><td>protected boolean tryReleaseShared(int arg)</td><td>共享方式。arg为释放锁的次数，尝试释放资源，如果释放后允许唤醒后续等待结点返回True，否则返回False。</td></tr></tbody></table><p>一般来说，自定义同步器要么是独占方式，要么是共享方式，它们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。ReentrantLock是独占锁，所以实现了tryAcquire-tryRelease。</p><p>以非公平锁为例，这里主要阐述一下非公平锁与AQS之间方法的关联之处，具体每一处核心方法的作用会在文章后面详细进行阐述。</p><p><img src="https://p1.meituan.net/travelcube/b8b53a70984668bc68653efe9531573e78636.png" alt></p><p>为了帮助大家理解ReentrantLock和AQS之间方法的交互过程，以非公平锁为例，我们将加锁和解锁的交互流程单独拎出来强调一下，以便于对后续内容的理解。</p><p><img src="https://p1.meituan.net/travelcube/7aadb272069d871bdee8bf3a218eed8136919.png" alt></p><p>加锁：</p><ul><li>通过ReentrantLock的加锁方法Lock进行加锁操作。</li><li>会调用到内部类Sync的Lock方法，由于Sync#lock是抽象方法，根据ReentrantLock初始化选择的公平锁和非公平锁，执行相关内部类的Lock方法，本质上都会执行AQS的Acquire方法。</li><li>AQS的Acquire方法会执行tryAcquire方法，但是由于tryAcquire需要自定义同步器实现，因此执行了ReentrantLock中的tryAcquire方法，由于ReentrantLock是通过公平锁和非公平锁内部类实现的tryAcquire方法，因此会根据锁类型不同，执行不同的tryAcquire。</li><li>tryAcquire是获取锁逻辑，获取失败后，会执行框架AQS的后续逻辑，跟ReentrantLock自定义同步器无关。</li></ul><p>解锁：</p><ul><li>通过ReentrantLock的解锁方法Unlock进行解锁。</li><li>Unlock会调用内部类Sync的Release方法，该方法继承于AQS。</li><li>Release中会调用tryRelease方法，tryRelease需要自定义同步器实现，tryRelease只在ReentrantLock中的Sync实现，因此可以看出，释放锁的过程，并不区分是否为公平锁。</li><li>释放成功后，所有处理由AQS框架完成，与自定义同步器无关。</li></ul><p>通过上面的描述，大概可以总结出ReentrantLock加锁解锁时API层核心方法的映射关系。</p><p><img src="https://p0.meituan.net/travelcube/f30c631c8ebbf820d3e8fcb6eee3c0ef18748.png" alt></p><h2><span id="23-通过reentrantlock理解aqs">2.3 通过ReentrantLock理解AQS</span><a href="#23-通过reentrantlock理解aqs" class="header-anchor">#</a></h2><p>ReentrantLock中公平锁和非公平锁在底层是相同的，这里以非公平锁为例进行分析。</p><p>在非公平锁中，有一段这样的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下这个Acquire是怎么写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">    selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看一下tryAcquire方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，这里只是AQS的简单实现，具体获取锁的实现方法是由各自的公平锁和非公平锁单独实现的（以ReentrantLock为例）。如果该方法返回了True，则说明当前线程获取锁成功，就不用往后执行了；如果获取失败，就需要加入到等待队列中。下面会详细解释线程是何时以及怎样被加入进等待队列中的。</p><h3><span id="231-线程加入等待队列">2.3.1 线程加入等待队列</span><a href="#231-线程加入等待队列" class="header-anchor">#</a></h3><h4><span id="2311-加入队列的时机">2.3.1.1 加入队列的时机</span><a href="#2311-加入队列的时机" class="header-anchor">#</a></h4><p>当执行Acquire(1)时，会通过tryAcquire获取锁。在这种情况下，如果获取锁失败，就会调用addWaiter加入到等待队列中去。</p><h4><span id="2312-如何加入队列">2.3.1.2 如何加入队列</span><a href="#2312-如何加入队列" class="header-anchor">#</a></h4><p>获取锁失败后，会执行addWaiter(Node.EXCLUSIVE)加入等待队列，具体实现方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">Node pred = tail;</span><br><span class="line"><span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">    node.prev = pred;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">    pred.next = node;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetTail</span><span class="params">(Node expect, Node update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, tailOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的流程如下：</p><ul><li><p>通过当前的线程和锁模式新建一个节点。</p></li><li><p>Pred指针指向尾节点Tail。</p></li><li><p>将New中Node的Prev指针指向Pred。</p></li><li><p>通过compareAndSetTail方法，完成尾节点的设置。这个方法主要是对tailOffset和Expect进行比较，如果tailOffset的Node和Expect的Node地址是相同的，那么设置Tail的值为Update的值。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    stateOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;state&quot;</span>));</span><br><span class="line">    headOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;head&quot;</span>));</span><br><span class="line">    tailOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;tail&quot;</span>));</span><br><span class="line">    waitStatusOffset = unsafe.objectFieldOffset(Node.class.getDeclaredField(<span class="string">&quot;waitStatus&quot;</span>));</span><br><span class="line">    nextOffset = unsafe.objectFieldOffset(Node.class.getDeclaredField(<span class="string">&quot;next&quot;</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123; </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从AQS的静态代码块可以看出，都是获取一个对象的属性相对于该对象在内存当中的偏移量，这样我们就可以根据这个偏移量在对象内存当中找到这个属性。tailOffset指的是tail对应的偏移量，所以这个时候会将new出来的Node置为当前队列的尾节点。同时，由于是双向链表，也需要将前一个节点指向尾节点。</p><ul><li>如果Pred指针是Null（说明等待队列中没有元素），或者当前Pred指针和Tail指向的位置不同（说明被别的线程已经修改），就需要看一下Enq的方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有被初始化，需要进行初始化一个头结点出来。但请注意，初始化的头结点并不是当前线程节点，而是调用了无参构造函数的节点。如果经历了初始化或者并发导致队列中有元素，则与之前的方法相同。其实，addWaiter就是一个在双端链表添加尾节点的操作，需要注意的是，双端链表的头结点是一个无参构造函数的头结点。</p><p>总结一下，线程获取锁的时候，过程大体如下：</p><ol><li><p>当没有线程获取到锁时，线程1获取锁成功。</p></li><li><p>线程2申请锁，但是锁被线程1占有。</p></li></ol><p><img src="https://p0.meituan.net/travelcube/e9e385c3c68f62c67c8d62ab0adb613921117.png" alt></p><ol><li>如果再有线程要获取锁，依次在队列中往后排队即可。</li></ol><p>回到上边的代码，hasQueuedPredecessors是公平锁加锁时判断等待队列中是否存在有效节点的方法。如果返回False，说明当前线程可以争取共享资源；如果返回True，说明队列中存在有效节点，当前线程必须加入到等待队列中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = tail; </span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp; ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里，我们理解一下h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());为什么要判断的头结点的下一个节点？第一个节点储存的数据是什么？</p><blockquote><p>双向链表中，第一个节点为虚节点，其实并不存储任何信息，只是占位。真正的第一个有数据的节点，是在第二个节点开始的。当h != t时： 如果(s = h.next) == null，等待队列正在有线程进行初始化，但只是进行到了Tail指向Head，没有将Head指向Tail，此时队列中有元素，需要返回True（这块具体见下边代码分析）。 如果(s = h.next) != null，说明此时队列中至少有一个有效节点。如果此时s.thread == Thread.currentThread()，说明等待队列的第一个有效节点中的线程与当前线程相同，那么当前线程是可以获取资源的；如果s.thread != Thread.currentThread()，说明等待队列的第一个有效节点线程与当前线程不同，当前线程必须加入进等待队列。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; </span><br><span class="line">    <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">        tail = head;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.prev = t;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">        t.next = node;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>节点入队不是原子操作，所以会出现短暂的head != tail，此时Tail指向最后一个节点，而且Tail指向Head。如果Head没有指向Tail（可见5、6、7行），这种情况下也需要将相关线程加入队列中。所以这块代码是为了解决极端情况下的并发问题。</p><h4><span id="2313-等待队列中线程出队列时机">2.3.1.3 等待队列中线程出队列时机</span><a href="#2313-等待队列中线程出队列时机" class="header-anchor">#</a></h4><p>回到最初的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">    selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上文解释了addWaiter方法，这个方法其实就是把对应的线程以Node的数据结构形式加入到双端队列里，返回的是一个包含该线程的Node。而这个Node会作为参数，进入到acquireQueued方法中。acquireQueued方法可以对排队中的线程进行“获锁”操作。</p><p>总的来说，一个线程获取锁失败了，被放入等待队列，acquireQueued会把放入队列中的线程不断去获取锁，直到获取成功或者不再需要获取（中断）。</p><p>下面我们从“何时出队列？”和“如何出队列？”两个方向来分析一下acquireQueued源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">        <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">        setHead(node);</span><br><span class="line">        p.next = <span class="keyword">null</span>; </span><br><span class="line">        failed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> interrupted;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">        interrupted = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (failed)</span><br><span class="line">    cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：setHead方法是把当前节点置为虚节点，但并没有修改waitStatus，因为它是一直需要用的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    head = node;</span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line">    node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line">    &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parkAndCheckInterrupt主要用于挂起当前线程，阻塞调用栈，返回当前线程的中断状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法的流程图如下：</p><p><img src="https://p0.meituan.net/travelcube/c124b76dcbefb9bdc778458064703d1135485.png" alt></p><p>从上图可以看出，跳出当前循环的条件是当“前置节点是头结点，且当前线程获取锁成功”。为了防止因死循环导致CPU资源被浪费，我们会判断前置节点的状态来决定是否要将当前线程挂起，具体挂起流程用流程图表示如下（shouldParkAfterFailedAcquire流程）：</p><p><img src="https://p0.meituan.net/travelcube/9af16e2481ad85f38ca322a225ae737535740.png" alt></p><p>从队列中释放节点的疑虑打消了，那么又有新问题了：</p><ul><li><p>shouldParkAfterFailedAcquire中取消节点是怎么生成的呢？什么时候会把一个节点的waitStatus设置为-1？</p></li><li><p>是在什么时间释放节点通知到被挂起的线程呢？</p></li></ul><h3><span id="232-cancelled状态节点生成">2.3.2 CANCELLED状态节点生成</span><a href="#232-cancelled状态节点生成" class="header-anchor">#</a></h3><p>acquireQueued方法中的Finally代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">    <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">        ...</span><br><span class="line">        failed = <span class="keyword">false</span>;</span><br><span class="line">                ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (failed)</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过cancelAcquire方法，将Node的状态标记为CANCELLED。接下来，我们逐行来分析这个方法的原理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">    node.prev = pred = pred.prev;</span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp; ((ws = pred.waitStatus) == Node.SIGNAL || (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">        <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">            compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line">        node.next = node; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前的流程：</p><ul><li><p>获取当前节点的前驱节点，如果前驱节点的状态是CANCELLED，那就一直往前遍历，找到第一个waitStatus &lt;= 0的节点，将找到的Pred节点和当前Node关联，将当前Node设置为CANCELLED。</p></li><li><p>根据当前节点的位置，考虑以下三种情况：</p></li></ul><p>(1) 当前节点是尾节点。</p><p>(2) 当前节点是Head的后继节点。</p><p>(3) 当前节点不是Head的后继节点，也不是尾节点。</p><p>根据上述第二条，我们来分析每一种情况的流程。</p><p>当前节点是尾节点。</p><p><img src="https://p1.meituan.net/travelcube/b845211ced57561c24f79d56194949e822049.png" alt></p><p>当前节点是Head的后继节点。</p><p><img src="https://p1.meituan.net/travelcube/ab89bfec875846e5028a4f8fead32b7117975.png" alt></p><p>当前节点不是Head的后继节点，也不是尾节点。</p><p><img src="https://p0.meituan.net/travelcube/45d0d9e4a6897eddadc4397cf53d6cd522452.png" alt></p><p>通过上面的流程，我们对于CANCELLED节点状态的产生和变化已经有了大致的了解，但是为什么所有的变化都是对Next指针进行了操作，而没有对Prev指针进行操作呢？什么情况下会对Prev指针进行操作？</p><blockquote><p>执行cancelAcquire的时候，当前节点的前置节点可能已经从队列中出去了（已经执行过Try代码块中的shouldParkAfterFailedAcquire方法了），如果此时修改Prev指针，有可能会导致Prev指向另一个已经移除队列的Node，因此这块变化Prev指针不安全。 shouldParkAfterFailedAcquire方法中，会执行下面的代码，其实就是在处理Prev指针。shouldParkAfterFailedAcquire是获取锁失败的情况下才会执行，进入该方法后，说明共享资源已被获取，当前节点之前的节点都不会出现变化，因此这个时候变更Prev指针比较安全。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">node.prev = pred = pred.prev;</span><br><span class="line">&#125; while (pred.waitStatus &gt; 0);</span><br></pre></td></tr></table></figure></blockquote><h3><span id="233-如何解锁">2.3.3 如何解锁</span><a href="#233-如何解锁" class="header-anchor">#</a></h3><p>我们已经剖析了加锁过程中的基本流程，接下来再对解锁的基本流程进行分析。由于ReentrantLock在解锁的时候，并不区分公平锁和非公平锁，所以我们直接看解锁的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，本质释放锁的地方，是通过框架来完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">        unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ReentrantLock里面的公平锁和非公平锁的父类Sync定义了可重入锁的释放锁机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    free = <span class="keyword">true</span>;</span><br><span class="line">    setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来解释下述源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的判断条件为什么是h != null &amp;&amp; h.waitStatus != 0？</p><blockquote><p>h == null Head还没初始化。初始情况下，head == null，第一个节点入队，Head会被初始化一个虚拟节点。所以说，这里如果还没来得及入队，就会出现head == null 的情况。</p><p>h != null &amp;&amp; waitStatus == 0 表明后继节点对应的线程仍在运行中，不需要唤醒。</p><p>h != null &amp;&amp; waitStatus &lt; 0 表明后继节点可能被阻塞了，需要唤醒。</p></blockquote><p>再看一下unparkSuccessor方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">    compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    s = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">    <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">    s = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">    LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要从后往前找第一个非Cancelled的节点呢？原因如下。</p><p>之前的addWaiter方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们从这里可以看到，节点入队并不是原子操作，也就是说，node.prev = pred; compareAndSetTail(pred, node) 这两个地方可以看作Tail入队的原子操作，但是此时pred.next = node;还没执行，如果这个时候执行了unparkSuccessor方法，就没办法从前往后找了，所以需要从后往前找。还有一点原因，在产生CANCELLED状态节点的时候，先断开的是Next指针，Prev指针并未断开，因此也是必须要从后往前遍历才能够遍历完全部的Node。</p><p>综上所述，如果是从前往后找，由于极端情况下入队的非原子操作和CANCELLED节点产生过程中断开Next指针的操作，可能会导致无法遍历所有的节点。所以，唤醒对应的线程后，对应的线程就会继续往下执行。继续执行acquireQueued方法以后，中断如何处理？</p><h3><span id="234-中断恢复后的执行流程">2.3.4 中断恢复后的执行流程</span><a href="#234-中断恢复后的执行流程" class="header-anchor">#</a></h3><p>唤醒后，会执行return Thread.interrupted();，这个函数返回的是当前执行线程的中断状态，并清除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再回到acquireQueued代码，当parkAndCheckInterrupt返回True或者False的时候，interrupted的值不同，但都会执行下次循环。如果这个时候获取锁成功，就会把当前interrupted返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">        <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">            setHead(node);</span><br><span class="line">            p.next = <span class="keyword">null</span>; </span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> interrupted;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">        interrupted = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (failed)</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果acquireQueued为True，就会执行selfInterrupt方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法其实是为了中断线程。但为什么获取了锁以后还要中断线程呢？这部分属于Java提供的协作式中断知识内容，感兴趣同学可以查阅一下。这里简单介绍一下：</p><ol><li><p>当中断线程被唤醒时，并不知道被唤醒的原因，可能是当前线程在等待中被中断，也可能是释放了锁以后被唤醒。因此我们通过Thread.interrupted()方法检查中断标记（该方法返回了当前线程的中断状态，并将当前线程的中断标识设置为False），并记录下来，如果发现该线程被中断过，就再中断一次。</p></li><li><p>线程在等待资源的过程中被唤醒，唤醒后还是会不断地去尝试获取锁，直到抢到锁为止。也就是说，在整个流程中，并不响应中断，只是记录中断记录。最后抢到锁返回了，那么如果被中断过的话，就需要补充一次中断。</p></li></ol><p>这里的处理方式主要是运用线程池中基本运作单元Worder中的runWorker，通过Thread.interrupted()进行额外的判断处理，感兴趣的同学可以看下ThreadPoolExecutor源码。</p><h3><span id="235-小结">2.3.5 小结</span><a href="#235-小结" class="header-anchor">#</a></h3><p>我们在1.3小节中提出了一些问题，现在来回答一下。</p><blockquote><p>Q：某个线程获取锁失败的后续流程是什么呢？</p><p>A：存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。</p><p>Q：既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？</p><p>A：是CLH变体的FIFO双端队列。</p><p>Q：处于排队等候机制中的线程，什么时候可以有机会获取锁呢？</p><p>A：可以详细看下2.3.1.3小节。</p><p>Q：如果处于排队等候机制中的线程一直无法获取锁，需要一直等待么？还是有别的策略来解决这一问题？</p><p>A：线程所在节点的状态会变成取消状态，取消状态的节点会从队列中释放，具体可见2.3.2小节。</p><p>Q：Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？</p><p>A：AQS的Acquire会调用tryAcquire方法，tryAcquire由各个自定义同步器实现，通过tryAcquire完成加锁过程。</p></blockquote><h2><span id="3-aqs应用">3 AQS应用</span><a href="#3-aqs应用" class="header-anchor">#</a></h2><h3><span id="31-reentrantlock的可重入应用">3.1 ReentrantLock的可重入应用</span><a href="#31-reentrantlock的可重入应用" class="header-anchor">#</a></h3><p>ReentrantLock的可重入性是AQS很好的应用之一，在了解完上述知识点以后，我们很容易得知ReentrantLock实现可重入的方法。在ReentrantLock里面，不管是公平锁还是非公平锁，都有一段逻辑。</p><p>公平锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">    <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">    <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非公平锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires))&#123;</span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line"><span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line"><span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) </span><br><span class="line"><span class="function">t   hrow new <span class="title">Error</span><span class="params">(<span class="string">&quot;Maximum lock count exceeded&quot;</span>)</span></span>;</span><br><span class="line">setState(nextc);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面这两段都可以看到，有一个同步状态State来控制整体可重入的情况。State是Volatile修饰的，用于保证一定的可见性和有序性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure><p>接下来看State这个字段主要的过程：</p><ol><li><p>State初始化的时候为0，表示没有任何线程持有锁。</p></li><li><p>当有线程持有该锁时，值就会在原来的基础上+1，同一个线程多次获得锁是，就会多次+1，这里就是可重入的概念。</p></li><li><p>解锁也是对这个字段-1，一直到0，此线程对锁释放。</p></li></ol><h3><span id="32-juc中的应用场景">3.2 JUC中的应用场景</span><a href="#32-juc中的应用场景" class="header-anchor">#</a></h3><p>除了上边ReentrantLock的可重入性的应用，AQS作为并发编程的框架，为很多其他同步工具提供了良好的解决方案。下面列出了JUC中的几种同步工具，大体介绍一下AQS的应用场景：</p><table><thead><tr><th>同步工具</th><th>同步工具与AQS的关联</th></tr></thead><tbody><tr><td>ReentrantLock</td><td>使用AQS保存锁重复持有的次数。当一个线程获取锁时，ReentrantLock记录当前获得锁的线程标识，用于检测是否重复获取，以及错误线程试图解锁操作时异常情况的处理。</td></tr><tr><td>Semaphore</td><td>使用AQS同步状态来保存信号量的当前计数。tryRelease会增加计数，acquireShared会减少计数。</td></tr><tr><td>CountDownLatch</td><td>使用AQS同步状态来表示计数。计数为0时，所有的Acquire操作（CountDownLatch的await方法）才可以通过。</td></tr><tr><td>ReentrantReadWriteLock</td><td>使用AQS同步状态中的16位保存写锁持有的次数，剩下的16位用于保存读锁的持有次数。</td></tr><tr><td>ThreadPoolExecutor</td><td>Worker利用AQS同步状态实现对独占线程变量的设置（tryAcquire和tryRelease）。</td></tr></tbody></table><h3><span id="33-自定义同步工具">3.3 自定义同步工具</span><a href="#33-自定义同步工具" class="header-anchor">#</a></h3><p>了解AQS基本原理以后，按照上面所说的AQS知识点，自己实现一个同步工具。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeeLock</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span> <span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> compareAndSetState(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span> <span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过我们自己定义的Lock完成一定的同步功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeeMain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> LeeLock leeLock = <span class="keyword">new</span> LeeLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    leeLock.lock();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    leeLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码每次运行结果都会是20000。通过简单的几行代码就能实现同步功能，这就是AQS的强大之处。</p><h2><span id="总结">总结</span><a href="#总结" class="header-anchor">#</a></h2><p>我们日常开发中使用并发的场景太多，但是对并发内部的基本框架原理了解的人却不多。由于篇幅原因，本文仅介绍了可重入锁ReentrantLock的原理和AQS原理，希望能够成为大家了解AQS和ReentrantLock等同步器的“敲门砖”。</p><h2><span id="参考资料">参考资料</span><a href="#参考资料" class="header-anchor">#</a></h2><ul><li>Lea D. The java. util. concurrent synchronizer framework[J]. Science of Computer Programming, 2005, 58(3): 293-309.</li><li>《Java并发编程实战》</li><li><a href="https://tech.meituan.com/2018/11/15/java-lock.html">不可不说的Java“锁”事</a></li><li><a href="https://www.jianshu.com/p/f584799f1c77">一张图读懂公平锁与非公平锁</a></li><li><a href="https://blog.csdn.net/qq_35190492/article/details/104943579">公平锁和非公平锁的区别</a></li></ul><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">&lt;p&gt;Java中的大部分同步类（Lock、Semaphore、ReentrantLock等）都是基于AbstractQueuedSynchronizer（简称为AQS）实现的。AQS是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架。本文会从应用层逐渐深入到原理层，并通过ReentrantLock的基本特性和ReentrantLock与AQS的关联，来深入解读AQS相关独占锁的知识点，同时采取问答的模式来帮助大家理解AQS。由于篇幅原因，本篇文章主要阐述AQS中独占锁的逻辑和Sync Queue，不讲述包含共享锁和Condition Queue的部分（本篇文章核心为AQS原理剖析，只是简单介绍了ReentrantLock，感兴趣同学可以阅读一下ReentrantLock的源码）。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="https://blog.beyhub.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://blog.beyhub.com/tags/Java/"/>
    
    <category term="锁" scheme="https://blog.beyhub.com/tags/%E9%94%81/"/>
    
    <category term="高并发" scheme="https://blog.beyhub.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java SDK中的SPI机制</title>
    <link href="https://blog.beyhub.com/p/f429d0e59d95/"/>
    <id>https://blog.beyhub.com/p/f429d0e59d95/</id>
    <published>2021-08-23T11:38:08.523Z</published>
    <updated>2021-08-24T11:13:29.412Z</updated>
    
    <content type="html"><![CDATA[<p>本文通过探析JDK提供的，在开源项目中比较常用的Java SPI机制，希望给大家在实际开发实践、学习开源项目提供参考。SPI全称Service Provider Interface，是Java提供的一套用来被第三方实现或者扩展的API，它可以用来启用框架扩展和替换组件。</p><span id="more"></span><p>整体机制图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/5618238-5d8948367cb9b18e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/848/format/webp" alt></p><p>Java SPI 实际上是“<strong>基于接口的编程＋策略模式＋配置文件</strong>”组合实现的动态加载机制。</p><p>系统设计的各个抽象，往往有很多不同的实现方案，在面向的对象的设计里，一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。<br>Java SPI就是提供这样的一个机制：为某个接口寻找服务实现的机制。有点类似IOC的思想，就是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要。所以SPI的核心思想就是<strong>解耦</strong>。</p><p>概括地说，适用于：<strong>调用者根据实际使用需要，启用、扩展、或者替换框架的实现策略</strong></p><p>比较常见的例子：</p><ul><li>数据库驱动加载接口实现类的加载<br>JDBC加载不同类型数据库的驱动</li><li>日志门面接口实现类加载<br>SLF4J加载不同提供商的日志实现类</li><li>Spring<br>Spring中大量使用了SPI,比如：对servlet3.0规范对ServletContainerInitializer的实现、自动类型转换Type Conversion SPI(Converter SPI、Formatter SPI)等</li><li>Dubbo<br>Dubbo中也大量使用SPI的方式实现框架的扩展, 不过它对Java提供的原生SPI做了封装，允许用户扩展实现Filter接口</li></ul><p>要使用Java SPI，需要遵循如下约定：</p><ul><li>1、当服务提供者提供了接口的一种具体实现后，在jar包的META-INF/services目录下创建一个以“接口全限定名”为命名的文件，内容为实现类的全限定名；</li><li>2、接口实现类所在的jar包放在主程序的classpath中；</li><li>3、主程序通过java.util.ServiceLoder动态装载实现模块，它通过扫描META-INF/services目录下的配置文件找到实现类的全限定名，把类加载到JVM；</li><li>4、SPI的实现类必须携带一个不带参数的构造方法；</li></ul><h2><span id="示例代码">示例代码</span><a href="#示例代码" class="header-anchor">#</a></h2><p><strong>步骤1</strong>、定义一组接口 (假设是org.foo.demo.IShout)，并写出接口的一个或多个实现，(假设是org.foo.demo.animal.Dog、org.foo.demo.animal.Cat)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IShout</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">IShout</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;miao miao&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">IShout</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;wang wang&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤2</strong>、在 src/main/resources/ 下建立 /META-INF/services 目录， 新增一个以接口命名的文件 (org.foo.demo.IShout文件)，内容是要应用的实现类（这里是org.foo.demo.animal.Dog和org.foo.demo.animal.Cat，每行一个类）。</p><p>文件位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- src</span><br><span class="line">    -main</span><br><span class="line">        -resources</span><br><span class="line">            - META-INF</span><br><span class="line">                - services</span><br><span class="line">                    - org.foo.demo.IShout</span><br></pre></td></tr></table></figure><p>文件内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.foo.demo.animal.Dog</span><br><span class="line">org.foo.demo.animal.Cat</span><br></pre></td></tr></table></figure><p><strong>步骤3</strong>、使用 ServiceLoader 来加载配置文件中指定的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SPIMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServiceLoader&lt;IShout&gt; shouts = ServiceLoader.load(IShout.class);</span><br><span class="line">        <span class="keyword">for</span> (IShout s : shouts) &#123;</span><br><span class="line">            s.shout();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码输出：</p><p>首先看ServiceLoader类的签名类的成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceLoader</span>&lt;<span class="title">S</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">S</span>&gt;</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX = <span class="string">&quot;META-INF/services/&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;S&gt; service;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader loader;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;</span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;String,S&gt; providers = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LazyIterator lookupIterator;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考具体ServiceLoader具体源码，代码量不多，加上注释一共587行，梳理了一下，实现的流程如下：</p><ul><li><p>1 应用程序调用ServiceLoader.load方法<br>ServiceLoader.load方法内先创建一个新的ServiceLoader，并实例化该类中的成员变量，包括：</p><ul><li>loader(ClassLoader类型，类加载器)</li><li>acc(AccessControlContext类型，访问控制器)</li><li>providers(LinkedHashMap&lt;String,S&gt;类型，用于缓存加载成功的类)</li><li>lookupIterator(实现迭代器功能)</li></ul></li><li><p>2 应用程序通过迭代器接口获取对象实例<br>ServiceLoader先判断成员变量providers对象中(LinkedHashMap&lt;String,S&gt;类型)是否有缓存实例对象，如果有缓存，直接返回。<br>如果没有缓存，执行类的装载，实现如下：</p></li><li><p>(1) 读取META-INF/services/下的配置文件，获得所有能被实例化的类的名称，值得注意的是，ServiceLoader<strong>可以跨越jar包获取META-INF下的配置文件</strong>，具体加载配置的实现代码如下：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    String fullName = PREFIX + service.getName();</span><br><span class="line">    if (loader == null)</span><br><span class="line">        configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">    else</span><br><span class="line">        configs = loader.getResources(fullName);</span><br><span class="line">&#125; catch (IOException x) &#123;</span><br><span class="line">    fail(service, &quot;Error locating configuration files&quot;, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>(2) 通过反射方法Class.forName()加载类对象，并用instance()方法将类实例化。</li><li>(3) 把实例化后的类缓存到providers对象中，(LinkedHashMap&lt;String,S&gt;类型）<br>然后返回实例对象。</li></ul><p><strong>优点</strong>：<br>使用Java SPI机制的优势是实现解耦，使得第三方服务模块的装配控制的逻辑与调用者的业务代码分离，而不是耦合在一起。应用程序可以根据实际业务情况启用框架扩展或替换框架组件。</p><p>相比使用提供接口jar包，供第三方服务模块实现接口的方式，SPI的方式使得源框架，不必关心接口的实现类的路径，可以不用通过下面的方式获取接口实现类：</p><ul><li>代码硬编码import 导入实现类</li><li>指定类全路径反射获取：例如在JDBC4.0之前，JDBC中获取数据库驱动类需要通过<strong>Class.forName(“com.mysql.jdbc.Driver”)</strong>，类似语句先动态加载数据库相关的驱动，然后再进行获取连接等的操作</li><li>第三方服务模块把接口实现类实例注册到指定地方，源框架从该处访问实例</li></ul><p>通过SPI的方式，第三方服务模块实现接口后，在第三方的项目代码的META-INF/services目录下的配置文件指定实现类的全路径名，源码框架即可找到实现类</p><p><strong>缺点</strong>：</p><ul><li>虽然ServiceLoader也算是使用的延迟加载，但是基本只能通过遍历全部获取，也就是接口的实现类全部加载并实例化一遍。如果你并不想用某些实现类，它也被加载并实例化了，这就造成了浪费。获取某个实现类的方式不够灵活，只能通过Iterator形式获取，不能根据某个参数来获取对应的实现类。</li><li>多个并发多线程使用ServiceLoader类的实例是不安全的。</li></ul><h3><span id="参考资料">参考资料</span><a href="#参考资料" class="header-anchor">#</a></h3><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Ftime.geekbang.org%2Fcolumn%2Fintro%2F82%3Fcode%3Dw8EZ6RGOQApZJ5tpAzP8dRzeVHxZ4q%252FfOdSbSZzbkhc%253D">Java核心技术36讲</a><br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdocs.oracle.com%2Fjavase%2Ftutorial%2Fext%2Fbasics%2Fspi.html">The Java™ Tutorials</a><br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdocs.oracle.com%2Fjavase%2F8%2Fdocs%2Fapi%2Fjava%2Futil%2FServiceLoader.html">Java Doc</a><br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.developer.com%2Fjava%2Farticle.php%2F3848881%2FService-Provider-Interface-Creating-Extensible-Java-Applications.htm">Service Provider Interface: Creating Extensible Java Applications</a><br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FService_provider_interface">Service provider interface</a><br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2Flovesqcc%2Fp%2F5229353.html">Java ServiceLoader使用和解析</a><br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fyangguosb%2Farticle%2Fdetails%2F78772730">Java基础之SPI机制</a><br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fcxis.me%2F2017%2F04%2F17%2FJava%25E4%25B8%25ADSPI%25E6%259C%25BA%25E5%2588%25B6%25E6%25B7%25B1%25E5%2585%25A5%25E5%258F%258A%25E6%25BA%2590%25E7%25A0%2581%25E8%25A7%25A3%25E6%259E%2590%2F">Java中SPI机制深入及源码解析</a><br><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.spring4all.com%2Farticle%2F260">SPI机制简介</a></p><h3><span id="示例项目">示例项目</span><a href="#示例项目" class="header-anchor">#</a></h3><p><a href="https://github.com/eugenp/tutorials/tree/master/java-spi">https://github.com/eugenp/tutorials/tree/master/java-spi</a></p><p>原文链接：<a href="https://www.jianshu.com/p/46b42f7f593c">https://www.jianshu.com/p/46b42f7f593c</a></p><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">&lt;p&gt;本文通过探析JDK提供的，在开源项目中比较常用的Java SPI机制，希望给大家在实际开发实践、学习开源项目提供参考。SPI全称Service Provider Interface，是Java提供的一套用来被第三方实现或者扩展的API，它可以用来启用框架扩展和替换组件。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="https://blog.beyhub.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="java" scheme="https://blog.beyhub.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>关系型数据库的单列索引与联合索引</title>
    <link href="https://blog.beyhub.com/p/4d4a323f1983/"/>
    <id>https://blog.beyhub.com/p/4d4a323f1983/</id>
    <published>2021-08-21T19:51:02.000Z</published>
    <updated>2021-08-23T02:31:53.330Z</updated>
    
    <content type="html"><![CDATA[<p>数据库只做两件事情：存储数据、检索数据。而索引是在你存储的数据之外，额外保存一些路标（一般是B+树），以减少检索数据的时间。所以索引是主数据衍生的附加结构。一张表可以建立任意多个索引，每个索引可以是任意多个字段的组合。索引可能会提高查询速度（如果查询时使用了索引），但一定会减慢写入速度，因为每次写入时都需要更新索引，所以索引只应该加在经常需要搜索的列上，不要加在写多读少的列上。</p><span id="more"></span><h2><span id="使用单列索引和组合索引的时机"> 使用单列索引和组合索引的时机</span></h2><p>在关系数据库中，索引是一种提升检索速度的数据结构，但是它会带来写入速度的损失，以及更多的存储空间占用。</p><p>通过一个字段而不是主键查询一张<code>n</code>条记录的数据表，需要扫描O(n)条记录（从技术上讲，<code>n</code>意味着该表使用的<a href="https://en.wikipedia.org/wiki/Block_(data_storage)"><strong>磁盘块</strong></a>的数量，但是为了便于理解我们简单的假设它是记录的条数）。举例来说，假设<code>ssn</code>是一个唯一字段，下面这条SQL查询平均需要读取<code>n/2</code>条记录才能找到匹配的记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> \<span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> users.ssn <span class="operator">=</span> <span class="string">&#x27;1234&#x27;</span>;</span><br></pre></td></tr></table></figure><p>因为<code>ssn</code>是唯一的，所以在第一次找到这条记录时就会停止；然而如果查询字段不是唯一的，类似下面这条SQL语句会扫描<code>n</code>条数据（全表扫描）来找到所有的匹配记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> \<span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> users.first\_name <span class="operator">=</span> <span class="string">&#x27;Teemo&#x27;</span>;</span><br></pre></td></tr></table></figure><p>全表扫描是缓慢的，尤其当表的记录非常多的时候，这个时候可以创建索引来提升查询性能。</p><p>索引，或者更具体一些，单列索引是通过一种额外的数据结构<code>B-Tree</code>来对指定的特定的列进行排序。索引中的每一条记录包含一个指向数据表的指针，所以在索引中查找数据等价于在原始数据表中查询。举例，假设现在有下面这张<code>users</code>表：</p><table><thead><tr><th>ID</th><th>first_name</th><th>last_name</th><th>Class</th><th>Position</th><th>ssn</th></tr></thead><tbody><tr><td>1</td><td>Teemo</td><td>Shroomer</td><td>Specialist</td><td>Top</td><td>2345</td></tr><tr><td>2</td><td>Cecil</td><td>Heimerdinger</td><td>Specialist</td><td>Mid</td><td>5461</td></tr><tr><td>3</td><td>Annie</td><td>Hastur</td><td>Mage</td><td>Mid</td><td>8784</td></tr><tr><td>4</td><td>Fiora</td><td>Laurent</td><td>Slayer</td><td>Top</td><td>7867</td></tr><tr><td>5</td><td>Garen</td><td>Crownguard</td><td>Fighter</td><td>Top</td><td>4579</td></tr><tr><td>6</td><td>Malcolm</td><td>Graves</td><td>Specialist</td><td>ADC</td><td>4578</td></tr><tr><td>7</td><td>Irelia</td><td>Lito</td><td>Figher</td><td>Top</td><td>5689</td></tr><tr><td>8</td><td>Janna</td><td>Windforce</td><td>Controller</td><td>Support</td><td>4580</td></tr><tr><td>9</td><td>Jarvan</td><td>Lightshield</td><td>Figher</td><td>Top</td><td>4579</td></tr><tr><td>10</td><td>Katarina</td><td>DuCouteau</td><td>Assassin</td><td>Mid</td><td>5608</td></tr><tr><td>11</td><td>Kayle</td><td>Hex</td><td>Specialist</td><td>Top</td><td>4794</td></tr><tr><td>12</td><td>Emilia</td><td>LeBlanc</td><td>Mage</td><td>Mid</td><td>3468</td></tr><tr><td>13</td><td>Lee</td><td>Sin</td><td>Fighter</td><td>Jungle</td><td>8085</td></tr><tr><td>14</td><td>Lux</td><td>Crownguard</td><td>Mage</td><td>Mid</td><td>4567</td></tr><tr><td>15</td><td>Sarah</td><td>Fortune</td><td>Marksman</td><td>ADC</td><td>6560</td></tr><tr><td>16</td><td>Morgana</td><td>Hex</td><td>Controller</td><td>Support</td><td>3457</td></tr><tr><td>17</td><td>Orianna</td><td>Reveck</td><td>Mage</td><td>Mid</td><td>9282</td></tr><tr><td>18</td><td>Sona</td><td>Buvelle</td><td>Controller</td><td>Support</td><td>4722</td></tr><tr><td>19</td><td>Jericho</td><td>Swain</td><td>Mage</td><td>Mid</td><td>5489</td></tr><tr><td>20</td><td>Shauna</td><td>Vayne</td><td>Marksman</td><td>ADC</td><td>2352</td></tr><tr><td>21</td><td>Xin</td><td>Zhao</td><td>Fighter</td><td>Jungle</td><td>6902</td></tr><tr><td>22</td><td>Yorick</td><td>Mori</td><td>Tank</td><td>Top</td><td>4840</td></tr><tr><td>23</td><td>Wu</td><td>Kong</td><td>Fighter</td><td>Jungle</td><td>4933</td></tr></tbody></table><p>我们在<code>users.first_name</code>字段创建一个普通索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX first_name_index <span class="keyword">ON</span> users (first_name) <span class="keyword">USING</span> BTREE;</span><br></pre></td></tr></table></figure><p>这时会创建一个基于<code>first_name</code>字段的排序，并使用指针指向<code>users</code>表的主键，类似于下面这样：</p><table><thead><tr><th>first_name</th><th>Primary Key</th></tr></thead><tbody><tr><td>Annie</td><td>3</td></tr><tr><td>Cecil</td><td>2</td></tr><tr><td>Emilia</td><td>12</td></tr><tr><td>Fiora</td><td>4</td></tr><tr><td>Garen</td><td>5</td></tr><tr><td>Irelia</td><td>7</td></tr><tr><td>Janna</td><td>8</td></tr><tr><td>Jarvan</td><td>9</td></tr><tr><td>Jericho</td><td>19</td></tr><tr><td>Katarina</td><td>10</td></tr><tr><td>Kayle</td><td>11</td></tr><tr><td>Lee</td><td>13</td></tr><tr><td>Lux</td><td>14</td></tr><tr><td>Malcolm</td><td>6</td></tr><tr><td>Morgana</td><td>16</td></tr><tr><td>Orianna</td><td>17</td></tr><tr><td>Sarah</td><td>15</td></tr><tr><td>Shauna</td><td>20</td></tr><tr><td>Sona</td><td>18</td></tr><tr><td>Teemo</td><td>1</td></tr><tr><td>Wu</td><td>23</td></tr><tr><td>Xin</td><td>21</td></tr><tr><td>Yorick</td><td>22</td></tr></tbody></table><p>执行下面这条查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> first_name <span class="operator">=</span> <span class="string">&#x27;Teemo&#x27;</span>;</span><br></pre></td></tr></table></figure><p>此时，<code>first_name</code>字段已建立有顺序的索引，数据库在执行查询时，通过二分法查找将算法复杂度降到<code>O(log_2(n))</code>。</p><h2><span id="唯一索引"> 唯一索引</span></h2><p>除了性能方面的收益，索引也会被用于优化具有唯一性的字段。举例，假设我们不希望多个用户使用同一个手机号码，这是就可以在创建索引时添加<code>UNIQUE</code>修饰符。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX ssn\_index <span class="keyword">ON</span> users (ssn);</span><br></pre></td></tr></table></figure><p>创建上述唯一索引后，如果<code>users</code>表中已经存在了一条对应字段值相同记录，则会引起一个错误。</p><h2><span id="避免必要的索引"> 避免必要的索引</span></h2><p>正如有一句谚语所说：“天下没有免费的午餐”，索引能提高性能但也是有成本的：</p><ol><li>额外的空间用于存储索引</li><li>执行<code>CREATE</code>、<code>UPDATE</code>、<code>DELETE</code>等数据修改操作时，索引也会被更新</li></ol><p>因此，事实上不必要的索引会导致性能整体性的降低，接下来是使用索引的几条准则：</p><ul><li>不要在读少写多的表上创建索引，正如上面所说，索引提升了读性能但是降低了写性能</li><li>不要在大多数值都相同字段上使用索引，查询复杂度能达到<code>O(log_2(n))</code>的原因是二分法查找，但这只有在多数字段值都不同的情况下才有效</li><li>不要在确定大小的小表上使用索引，因为这并不会明显的提升性能。但要注意，有些表（例如<code>users</code>）虽然现在很小，但它未来可能会不断增长；但也有的表一直很小，冰激凌的口味毕竟是有限的。</li></ul><p>单列索引和组合索引也是对字段排序的数据结构，但是与单列索引不同的是，联合索引中组合了多个字段。举例，再看下这张<code>users</code>表：</p><table><thead><tr><th>ID</th><th>first_name</th><th>last_name</th><th>class</th><th>position</th></tr></thead><tbody><tr><td>1</td><td>Teemo</td><td>Shroomer</td><td>Specialist</td><td>Top</td></tr><tr><td>2</td><td>Cecil</td><td>Heimerdinger</td><td>Specialist</td><td>Mid</td></tr><tr><td>3</td><td>Annie</td><td>Hastur</td><td>Mage</td><td>Mid</td></tr><tr><td>4</td><td>Fiora</td><td>Laurent</td><td>Slayer</td><td>Top</td></tr><tr><td>5</td><td>Garen</td><td>Crownguard</td><td>Fighter</td><td>Top</td></tr><tr><td>6</td><td>Malcolm</td><td>Graves</td><td>Specialist</td><td>ADC</td></tr><tr><td>7</td><td>Irelia</td><td>Lito</td><td>Figher</td><td>Top</td></tr><tr><td>8</td><td>Janna</td><td>Windforce</td><td>Controller</td><td>Support</td></tr><tr><td>9</td><td>Jarvan</td><td>Lightshield</td><td>Figher</td><td>Top</td></tr><tr><td>10</td><td>Katarina</td><td>DuCouteau</td><td>Assassin</td><td>Mid</td></tr><tr><td>11</td><td>Kayle</td><td>Hex</td><td>Specialist</td><td>Top</td></tr><tr><td>12</td><td>Emilia</td><td>LeBlanc</td><td>Mage</td><td>Mid</td></tr><tr><td>13</td><td>Lee</td><td>Sin</td><td>Fighter</td><td>Jungle</td></tr><tr><td>14</td><td>Lux</td><td>Crownguard</td><td>Mage</td><td>Mid</td></tr><tr><td>15</td><td>Sarah</td><td>Fortune</td><td>Marksman</td><td>ADC</td></tr><tr><td>16</td><td>Morgana</td><td>Hex</td><td>Controller</td><td>Support</td></tr><tr><td>17</td><td>Orianna</td><td>Reveck</td><td>Mage</td><td>Mid</td></tr><tr><td>18</td><td>Sona</td><td>Buvelle</td><td>Controller</td><td>Support</td></tr><tr><td>19</td><td>Jericho</td><td>Swain</td><td>Mage</td><td>Mid</td></tr><tr><td>20</td><td>Shauna</td><td>Vayne</td><td>Marksman</td><td>ADC</td></tr><tr><td>21</td><td>Xin</td><td>Zhao</td><td>Fighter</td><td>Jungle</td></tr><tr><td>22</td><td>Yorick</td><td>Mori</td><td>Tank</td><td>Top</td></tr><tr><td>23</td><td>Wu</td><td>Kong</td><td>Fighter</td><td>Jungle</td></tr></tbody></table><p>在<code>class</code>和<code>position</code>两列上创建一个联合索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX class_pos_index <span class="keyword">ON</span> users (class, position);</span><br></pre></td></tr></table></figure><p>这时候创建了一个组合索引，对两个字段拼接进行排序，如下所示：</p><table><thead><tr><th>class-position</th><th>Primary Key</th></tr></thead><tbody><tr><td>AssassinMid</td><td>10</td></tr><tr><td>ControllerSupport</td><td>16</td></tr><tr><td>ControllerSupport</td><td>18</td></tr><tr><td>ControllerSupport</td><td>8</td></tr><tr><td>FigherTop</td><td>7</td></tr><tr><td>FigherTop</td><td>9</td></tr><tr><td>FighterJungle</td><td>13</td></tr><tr><td>FighterJungle</td><td>21</td></tr><tr><td>FighterJungle</td><td>23</td></tr><tr><td>FighterTop</td><td>5</td></tr><tr><td>MageMid</td><td>12</td></tr><tr><td>MageMid</td><td>14</td></tr><tr><td>MageMid</td><td>17</td></tr><tr><td>MageMid</td><td>19</td></tr><tr><td>MageMid</td><td>3</td></tr><tr><td>MarksmanADC</td><td>15</td></tr><tr><td>MarksmanADC</td><td>20</td></tr><tr><td>SlayerTop</td><td>4</td></tr><tr><td>SpecialistADC</td><td>6</td></tr><tr><td>SpecialistMid</td><td>2</td></tr><tr><td>SpecialistTop</td><td>1</td></tr><tr><td>SpecialistTop</td><td>11</td></tr><tr><td>TankTop</td><td>22</td></tr></tbody></table><p>下面是一个对联合索引的查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span>  class <span class="operator">=</span> <span class="string">&#x27;Specialist&#x27;</span> <span class="keyword">AND</span> position <span class="operator">=</span> <span class="string">&#x27;Top&#x27;</span>;</span><br></pre></td></tr></table></figure><p>经过上面一通操作，我们减少了检索时间，因为联合索引基于<code>class-position</code>排序，数据库可以在时间复杂度<code>O(log_2(n))</code>下查找到值<code>SpecialistTop</code>，而不是全表扫描。</p><p>受益于上述组合索引将<code>class</code>作为联合索引的第一个字段，基于<code>class</code>列的查询性能也会提升。因为基于<code>class</code>字段的索引基本上等同于联合索引<code>class-position</code>，所以我们不需要再单独为<code>class</code>建立索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> class <span class="operator">=</span> <span class="string">&#x27;Specialist&#x27;</span>;</span><br></pre></td></tr></table></figure><p>然而，对字段<code>position</code>的查询性能并不会有所变化，因为它是联合索引中的第二个字段。基于<code>class-position</code>排序的联合索引，不能用于快速检索<code>position</code>列的值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> \<span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> position <span class="operator">=</span> <span class="string">&#x27;Top&#x27;</span>;</span><br></pre></td></tr></table></figure><p>基于以上，联合索引组成字段的顺序是非常重要的，一个对<code>column1</code> , <code>column2</code> , <code>column3</code> ,…, <code>columnN</code>若干字段的组合索引，对以下SQL语句是有效的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> column1 <span class="operator">=</span> <span class="string">&#x27;value&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> column1 <span class="operator">=</span> <span class="string">&#x27;value1&#x27;</span> <span class="keyword">AND</span> column2 <span class="operator">=</span> <span class="string">&#x27;value2&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> column1 <span class="operator">=</span> <span class="string">&#x27;value1&#x27;</span> <span class="keyword">AND</span> column2 <span class="operator">=</span> <span class="string">&#x27;value2&#x27;</span> <span class="keyword">AND</span> column3 <span class="operator">=</span> <span class="string">&#x27;value3&#x27;</span>...</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> column1 <span class="operator">=</span> <span class="string">&#x27;value1&#x27;</span> <span class="keyword">AND</span> column2 <span class="operator">=</span> <span class="string">&#x27;value2&#x27;</span> <span class="keyword">AND</span> column3 <span class="operator">=</span> <span class="string">&#x27;value3&#x27;</span>... <span class="keyword">AND</span> columnN <span class="operator">=</span> <span class="string">&#x27;valueN&#x27;</span></span><br></pre></td></tr></table></figure><h2><span id="联合索引建立指南"> 联合索引建立指南</span></h2><p>和单列索引一样，联合索引也会降低写入速度，同时增加存储空间的占用量。建立联合索引时，选择字段以及字段顺序排列应当考虑以下几个原则：</p><ul><li>如果一些字段倾向于在查询中同时出现，这时，为他们创建一个联合是一个不错的主意。例如，在上述<code>users</code>表中，建立一个<code>(last_name, first_name)</code>组合的联合主键是不错的选择</li><li>如果需要对字段<code>field1</code>创建索引，同时也需要创建联合索引<code>(field1, field2)</code>，此时只需要创建后者即可</li><li>与单列索引类似，组合字段值的重复度会影响联合索引的查询效率。很显然，如果两个字段重复度不高，联合索引组成的索引值重复度也不高，但我们仍然可以将高重复度的字段和低重复度的几个字段组合起来建立联合索引。</li></ul><h2><span id="唯一组合索引和组合索引"> 唯一组合索引和组合索引</span></h2><p>联合索引也可以将字段值组合设置为强制唯一。</p><p>通常，单个字段值不是唯一的，但组合后的字段是唯一的。例如，<code>addresses</code>表中有<code>street</code>,<code>address_number</code>,<code>city</code>，3个字段。我们不需要将<code>street</code>或<code>house_number</code>或<code>city</code>设置为唯一，因为不同的地址可能使用相同的上述值，但我们可能会希望<code>street-house_number-city</code>这个组合是唯一的。这时，我们可以使用联合索引，并添加<code>UNIQUE</code>修饰符：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX index_st_no_city <span class="keyword">ON</span> addresses (street, house_number, city);</span><br></pre></td></tr></table></figure><blockquote><p>原文地址：<a href="https://user3141592.medium.com/single-vs-composite-indexes-in-relational-databases-58d0eb045cbe">https://user3141592.medium.com/single-vs-composite-indexes-in-relational-databases-58d0eb045cbe</a></p></blockquote><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">&lt;p&gt;数据库只做两件事情：存储数据、检索数据。而索引是在你存储的数据之外，额外保存一些路标（一般是B+树），以减少检索数据的时间。所以索引是主数据衍生的附加结构。一张表可以建立任意多个索引，每个索引可以是任意多个字段的组合。索引可能会提高查询速度（如果查询时使用了索引），但一定会减慢写入速度，因为每次写入时都需要更新索引，所以索引只应该加在经常需要搜索的列上，不要加在写多读少的列上。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://blog.beyhub.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://blog.beyhub.com/tags/MySQL/"/>
    
    <category term="面试题" scheme="https://blog.beyhub.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>HashMap、Hashtable等Map接口的实现和原理</title>
    <link href="https://blog.beyhub.com/p/2b5aebafa2f6/"/>
    <id>https://blog.beyhub.com/p/2b5aebafa2f6/</id>
    <published>2020-04-11T02:51:09.000Z</published>
    <updated>2021-08-21T11:48:53.962Z</updated>
    
    <content type="html"><![CDATA[<p>Map 集合和 Collection 集合不同，Map 集合是基于键（key）/值（value）的映射，Collection中的集合，元素是孤立存在的，向集合中存储元素采用一个个元素的方式存储；Map中的集合，元素是成对存在的，每个元素由键与值两部分组成，通过键可以找对所对应的值。</p><p>Collection中的集合称为单列集合，Map中的集合称为双列集合。需要注意的是，Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。<br><img src="/images/posts/2020/map-interface-1.png" alt></p><span id="more"></span><h2><span id="比较"> 比较</span></h2><table><thead><tr><th></th><th>HashMap</th><th>TreeMap</th><th>HashTable</th></tr></thead><tbody><tr><td>实现</td><td>基于哈希散列表实现</td><td>SortMap接口，基于红黑树</td><td>继承自Dictionary</td></tr><tr><td>存储</td><td>随机存储</td><td>默认按键的升序排序</td><td>随机存储</td></tr><tr><td>遍历</td><td>Iterator遍历是随机的</td><td>Iterator遍历是排序的</td><td>Enumeration和Iterator</td></tr><tr><td>性能损耗</td><td>几乎无</td><td>插入、删除</td><td>几乎无</td></tr><tr><td>键值对</td><td>只允许键、值均为null</td><td>键、值都不能为null</td><td>不允许null</td></tr><tr><td>线程安全</td><td>否</td><td>否</td><td>是</td></tr><tr><td>效率</td><td>高</td><td>低</td><td>高</td></tr></tbody></table><p>一般情况下我们选用HashMap，因为HashMap的键值对在取出时是随机的，其依据键的hashCode和键的equals方法存取数据，具有很快的访问速度，所以在Map中插入、删除及索引元素时其是效率最高的实现。而TreeMap的键值对在取出时是排过序的，所以效率会低点。</p><h2><span id="hashtable"> HashTable</span></h2><p>散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存储存位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。</p><h3><span id="hashmap和hashtable的区别"> HashMap和hashtable的区别</span></h3><ul><li>HashMap允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许</li><li>HashMap 把 Hashtable 的 contains 方法去掉了，改成 containsValue 和 containsKey。因为 contains 方法容易让人引起误解。</li><li>HashTable 继承自 Dictionary 类，而HashMap是Java1.2 引进的 Map interface 的一个实现</li><li>HashTable 的方法是 Synchronize 的，而HashMap不是，在多个线程访问 Hashtable 时，不需要自己为它的方法实现同步，而 HashMap 就必须为之提供外同步</li><li>Hashtable 和 HashMap 采用的 hash/rehash 算法都大概一样，所以性能不会有很大的差异</li></ul><h3><span id="hashmap-不是线程安全的没有锁"> HashMap 不是线程安全的（没有锁）</span></h3><p>HashMap 是 map 接口的实现类，是将键映射到值的对象，其中键和值都是对象，并且不能包含重复键，但可以包含重复值。HashMap 允许 null key 和 null value，而 HashTable 不允许。</p><h3><span id="linkedhashmap"> LinkedHashMap</span></h3><p>大多数情况下，只要不涉及线程安全问题，Map基本都可以使用HashMap，不过HashMap有一个问题，就是迭代HashMap的顺序并不是HashMap放置的顺序，也就是无序。HashMap的这一缺点往往会带来困扰，因为有些场景，我们期待一个有序的Map.这就是我们的LinkedHashMap,</p><h3><span id="hashtable-是线程安全-有锁-同步机制"> Hashtable 是线程安全 （有锁-同步机制）</span></h3><p>HashMap 是 HashTable 的轻量级实现，他们都完成了Map 接口，主要区别在于 HashMap 允许 null key 和 null value,由于非线程安全，效率上可能高于 Hashtable。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get它搞成了同步方法，保证了get的安全性</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//synchronized,同样</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//也是搞成了同步方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="concurrenthashmap和hashtable的区别"> ConcurrentHashMap和Hashtable的区别</span></h3><p>ConcurrentHashMap基于内存屏障（Volatile）实现，而HashTable基于同步锁性能相对较低</p><p>它们都可以用于多线程的环境，但是当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。因为ConcurrentHashMap引入了分割(segmentation)，不论它变得多么大，仅仅需要锁定map的某个部分，而其它的线程不需要等到迭代完成才能访问map。简而言之，在迭代的过程中，ConcurrentHashMap仅仅锁定map的某个部分，而Hashtable则会锁定整个map。</p><h2><span id="扩展阅读"> 扩展阅读</span></h2><ol><li><a href="https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/index.html">IBM 探索 ConcurrentHashMap 高并发性的实现机制</a></li></ol><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">&lt;p&gt;Map 集合和 Collection 集合不同，Map 集合是基于键（key）/值（value）的映射，Collection中的集合，元素是孤立存在的，向集合中存储元素采用一个个元素的方式存储；Map中的集合，元素是成对存在的，每个元素由键与值两部分组成，通过键可以找对所对应的值。&lt;/p&gt;
&lt;p&gt;Collection中的集合称为单列集合，Map中的集合称为双列集合。需要注意的是，Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。&lt;br /&gt;
&lt;img src=&quot;/images/posts/2020/map-interface-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://blog.beyhub.com/categories/Java/"/>
    
    
    <category term="原理" scheme="https://blog.beyhub.com/tags/%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引底层的数据结构与算法</title>
    <link href="https://blog.beyhub.com/p/ea1ec3c52bb7/"/>
    <id>https://blog.beyhub.com/p/ea1ec3c52bb7/</id>
    <published>2020-04-10T23:25:19.000Z</published>
    <updated>2021-08-21T04:12:22.449Z</updated>
    
    <content type="html"><![CDATA[<p>索引是帮助MySQL高效获取数据的排好序的数据结构，由于以上实现的数据结构与数据库中索引相关，关于索引，有以下知识：</p><ol><li>唯一索引：唯一索引不允许两行具有相同的索引值</li><li>主键索引：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。<br />主键索引要求主键中的每个值是唯一的，并且不能为空</li><li>聚集索引（Clustered)：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有一个</li><li>非聚集索引（Non-clustered)：非聚集索引指定表的逻辑顺序。<br />数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针可以有多个（小于 249 个）</li></ol><span id="more"></span><h2 id="索引数据结构"><a class="markdownIt-Anchor" href="#索引数据结构"></a> 索引数据结构</h2><h3 id="二叉树"><a class="markdownIt-Anchor" href="#二叉树"></a> 二叉树</h3><p>左边子节点的数据小于父节点数据，右边子节点的数据大于父节点数据。如果col2是索引，查找索引为89的行元素，那么只需要查找两次，就可以获取到行元素所在的磁盘指针地址。</p><p><img src="/images/posts/2020/binarytree.png" alt="" /></p><p>如果col1是索引，查找索引为6的行元素，那么需要查找六次，就可以获取到行元素所在的磁盘指针地址，即得到了该索引为6的行元素。因此二叉树不适合存储单边增长的序列字段，近乎全表扫描获取数据。</p><h3 id="红黑树"><a class="markdownIt-Anchor" href="#红黑树"></a> 红黑树</h3><p>本质二叉树，属于二叉平衡树，jdk1.8 hashmap的底层实现；存储大数据量，树的高度不可控， 数量越大，树的高度越高；500w行数据，2的n次方=500w数据量， n是树的高度，也就是查询次数；</p><h3 id="hash表"><a class="markdownIt-Anchor" href="#hash表"></a> hash表</h3><p>通过散列可以快速获取磁盘文件指针，对于指定索引查找文件非常快，但是对于范围查找没法支持。</p><h3 id="b树"><a class="markdownIt-Anchor" href="#b树"></a> B树</h3><p><img src="/images/posts/2020/btree.png" alt="" /></p><p>本质是多路二叉树；叶节点具有相同的深度，叶节点的指针为空；所有索引元素不重复；节点中数据索引从左到右依次递增的；</p><h3 id="b树b树的变种"><a class="markdownIt-Anchor" href="#b树b树的变种"></a> B+树（B树的变种）</h3><p>非叶子节点不存储数据，只存储索引(冗余)和指针，可以放更多的索引，树高降低 ；叶子节点包含所有索引字段；叶子节点比b树增加了指针连接；叶子节点有双向指针链接(首尾子节点还通过指针连接)，提高区间访问的性能，范围查找；</p><p><img src="/images/posts/2020/bplustree.png" alt="" /></p><p><strong>为什么mysql页文件默认16K？</strong></p><p>MySQL每个B+树节点最大存储容量：16KB （指针+数据+索引）。假设我们一行数据大小为1K，那么一页就能存16条数据，也就是一个叶子节点能存16条数据；再看非叶子节点，假设主键ID为bigint类型，那么长度为8B，指针大小在Innodb源码中为6B，一共就是14B，那么一页里就可以存储16K/14=1170个(主键+指针)那么一颗高度为2的B+树能存储的数据为：117016=18720条，一颗高度为3的B+树能存储的数据为：11701170*16=21902400（千万级条）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> `Innodb_page_size`</span><br></pre></td></tr></table></figure><p>因此，B+树存储大数据量的表也可以非常高效的获取数据，<strong>MySQL使用B+树作为索引的数据结构</strong>。</p><h3 id="存储引擎"><a class="markdownIt-Anchor" href="#存储引擎"></a> 存储引擎</h3><h4 id="innodb聚集"><a class="markdownIt-Anchor" href="#innodb聚集"></a> InnoDB（聚集）</h4><p>表数据文件本身是按照B+tree组织的一个索引结构文件frm文件：存储这张表的表结构ibd文件：存储这张表的所有数据行和索引字段聚集(聚簇)索引----叶节点包含完整数据记录</p><p><strong>为什么InnoDB表必须有主键，并且推荐使用整型的自增主键？</strong></p><p>首先，为了满足MySQL的索引数据结构B+树的特性，必须要有索引作为主键，可以有效提高查询效率，因此InnoDB必须要有主键。如果不手动指定主键，InnoDB会从插入的数据中找出不重复的一列作为主键索引，如果没找到不重复的一列，InnoDB会在后台增加一列rowId做为主键索引。</p><p>其次，索引的数据类型是整型，一方面整型占有的磁盘空间或内存空间相比字符串更少，另一方面整型比较比字符串比较更快速，字符串比较是先转换为ASCII码，然后再比较的。<br />最后，B+树本质是多路多叉树，如果主键索引不是自增的，那么后续插入的索引就会引起B+树的其他节点的分裂和重新平衡，影响数据插入的效率，如果是自增主键，只用在尾节点做增加就可以。</p><p><strong>为什么非主键索引结构叶子节点存储的是主键值？</strong></p><p>主键索引和非主键索引维护各自的B+树结构，当插入的数据的时候，由于数据只有一份，通过非主键索引获取到主键值，然后再去主键索引的B+树数据结构中找到对应的行数据，节省了内存空间；<br />如果非主键索引的叶子节点也存储一份数据，如果通过非主键索引插入数据，那么要向主键索引对应的行数据进行同步，那么会带来数据一致性问题。可以通过事务的方式解决，我们都知道使用事务后，就会对性能有所消耗。</p><p><strong>联合索引</strong></p><p>两个或更多个列上的索引被称作联合索引，联合索引又叫复合索引。对于复合索引:Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。</p><p>例如索引是key index (a,b,c). 可以支持a | a,b| a,b,c 3种组合进行查找，但不支持 b,c进行查找 .当最左侧字段是常量引用时，索引就十分有效。</p><h4 id="myisam和innodb的9大区别"><a class="markdownIt-Anchor" href="#myisam和innodb的9大区别"></a> MyISAM和InnoDB的9大区别</h4><ol><li>InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</li><li>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；</li><li>InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。也就是说：InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。</li><li>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</li><li>Innodb不支持全文索引（5.7以后支持），而MyISAM支持全文索引，查询效率上MyISAM要高</li><li>MyISAM表格可以被压缩后进行查询操作</li><li>InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁InnoDB的行锁是实现在索引上的，而不是锁在物理行记录上。潜台词是，如果访问没有命中索引，也无法使用行锁，将要退化为表锁。</li><li>InnoDB表必须有主键（用户没有指定的话会自己找或生产一个主键），而Myisam可以没有</li><li>Innodb存储文件有frm、ibd，而Myisam是frm、MYD、MYIInnodb：frm是表定义文件，ibd是数据文件Myisam：frm是表定义文件，myd是数据文件，myi是索引文件</li></ol><h2 id="扩展阅读"><a class="markdownIt-Anchor" href="#扩展阅读"></a> 扩展阅读</h2><ol><li>MySQL索引背后的数据结构及算法原理 <a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></li></ol><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">&lt;p&gt;索引是帮助MySQL高效获取数据的排好序的数据结构，由于以上实现的数据结构与数据库中索引相关，关于索引，有以下知识：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;唯一索引：唯一索引不允许两行具有相同的索引值&lt;/li&gt;
&lt;li&gt;主键索引：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。&lt;br /&gt;
主键索引要求主键中的每个值是唯一的，并且不能为空&lt;/li&gt;
&lt;li&gt;聚集索引（Clustered)：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有一个&lt;/li&gt;
&lt;li&gt;非聚集索引（Non-clustered)：非聚集索引指定表的逻辑顺序。&lt;br /&gt;
数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针可以有多个（小于 249 个）&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Java" scheme="https://blog.beyhub.com/categories/Java/"/>
    
    
    <category term="MySQL" scheme="https://blog.beyhub.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Markmap</title>
    <link href="https://blog.beyhub.com/p/603ae4015c97/"/>
    <id>https://blog.beyhub.com/p/603ae4015c97/</id>
    <published>2020-04-10T22:06:41.000Z</published>
    <updated>2021-08-21T10:48:30.855Z</updated>
    
    <content type="html"><![CDATA[<div class="markmap-container" style="height:300px;" ><svg class="markmap-svg">{"t":"root","d":0,"v":"","c":[{"t":"heading","d":1,"v":"Testa","c":[{"t":"heading","d":2,"v":"test1"},{"t":"heading","d":2,"v":"test2"}]},{"t":"heading","d":1,"v":"Testb","c":[{"t":"heading","d":2,"v":"test1"},{"t":"heading","d":2,"v":"test2"}]}]}</svg></div><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;markmap-container&quot; style=&quot;height:300px;&quot; &gt;&lt;svg class=&quot;markmap-svg&quot;&gt;{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;v&quot;:&quot;Testa</summary>
      
    
    
    
    <category term="杂文" scheme="https://blog.beyhub.com/categories/%E6%9D%82%E6%96%87/"/>
    
    
    <category term="MySQL" scheme="https://blog.beyhub.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis 动态SQL</title>
    <link href="https://blog.beyhub.com/p/c080a06a7d4a/"/>
    <id>https://blog.beyhub.com/p/c080a06a7d4a/</id>
    <published>2020-04-10T22:06:41.000Z</published>
    <updated>2021-08-21T04:12:22.449Z</updated>
    
    <content type="html"><![CDATA[<p>动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。</p><p>使用动态 SQL 并非一件易事，但借助可用于任何 SQL 映射语句中的强大的动态 SQL 语言，MyBatis 显著地提升了这一特性的易用性。</p><p><img src="/images/posts/2020/mybatis.png" alt></p><span id="more"></span><p>如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。</p><ol><li>if</li><li>choose (when, otherwise)</li><li>trim (where, set)</li><li>foreach</li><li>if</li></ol><h2><span id="yuan-su-xiang-jie"> 元素详解</span><a href="#yuan-su-xiang-jie" class="header-anchor">#</a></h2><h3><span id="if"> if</span><a href="#if" class="header-anchor">#</a></h3><p>使用动态 SQL 最常见情景是根据条件包含 where 子句的一部分。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogWithTitleLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  WHERE state = ‘ACTIVE’</span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">    AND title like #&#123;title&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这条语句提供了可选的查找文本功能。如果不传入 “title”，那么所有处于 “ACTIVE” 状态的 BLOG 都会返回；如果传入了 “title” 参数，那么就会对 “title” 一列进行模糊查找并返回对应的 BLOG 结果（细心的读者可能会发现，“title” 的参数值需要包含查找掩码或通配符字符）。</p><p>如果希望通过 “title” 和 “author” 两个参数进行可选搜索该怎么办呢？首先，我想先将语句名称修改成更名副其实的名称；接下来，只需要加入另一个条件即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG WHERE state = ‘ACTIVE’</span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">    AND title like #&#123;title&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">    AND author_name like #&#123;author.name&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3><span id="choose-when-otherwise"> choose、when、otherwise</span><a href="#choose-when-otherwise" class="header-anchor">#</a></h3><p>有时候，我们不想使用所有的条件，而只是想从多个条件中选择一个使用。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。</p><p>还是上面的例子，但是策略变为：传入了 “title” 就按 “title” 查找，传入了 “author” 就按 “author” 查找的情形。若两者都没有传入，就返回标记为 featured 的 BLOG（这可能是管理员认为，与其返回大量的无意义随机 Blog，还不如返回一些由管理员挑选的 Blog）。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG WHERE state = ‘ACTIVE’</span><br><span class="line">  <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">      AND title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">      AND author_name like #&#123;author.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">      AND featured = 1</span><br><span class="line">    <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3><span id="trim-where-set"> trim、where、set</span><a href="#trim-where-set" class="header-anchor">#</a></h3><p>前面几个例子已经合宜地解决了一个臭名昭著的动态 SQL 问题。现在回到之前的 “if” 示例，这次我们将 “state = ‘ACTIVE’” 设置成动态条件，看看会发生什么。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  WHERE</span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;state != null&quot;</span>&gt;</span></span><br><span class="line">    state = #&#123;state&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">    AND title like #&#123;title&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">    AND author_name like #&#123;author.name&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果没有匹配的条件会怎么样？最终这条 SQL 会变成这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> BLOG</span><br><span class="line"><span class="keyword">WHERE</span></span><br></pre></td></tr></table></figure><p>这会导致查询失败。如果匹配的只是第二个条件又会怎样？这条 SQL 会是这样:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM BLOG</span><br><span class="line">WHERE</span><br><span class="line">AND title like ‘someTitle’</span><br></pre></td></tr></table></figure><p>这个查询也会失败。这个问题不能简单地用条件元素来解决。这个问题是如此的难以解决，以至于解决过的人不会再想碰到这种问题。</p><p>MyBatis 有一个简单且适合大多数场景的解决办法。而在其他场景中，可以对其进行自定义以符合需求。而这，只需要一处简单的改动：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;state != null&quot;</span>&gt;</span></span><br><span class="line">         state = #&#123;state&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">        AND title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">        AND author_name like #&#123;author.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>where 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，where 元素也会将它们去除。</p><p>如果 where 元素与你期望的不太一样，你也可以通过自定义 trim 元素来定制 where 元素的功能。比如，和 where 元素等价的自定义 trim 元素为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;WHERE&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;AND |OR &quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure><p>prefixOverrides 属性会忽略通过管道符分隔的文本序列（注意此例中的空格是必要的）。上述例子会移除所有 prefixOverrides 属性中指定的内容，并且插入 prefix 属性中指定的内容。</p><p>用于动态更新语句的类似解决方案叫做 set。set 元素可以用于动态包含需要更新的列，忽略其它不更新的列。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateAuthorIfNecessary&quot;</span>&gt;</span></span><br><span class="line">  update Author</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span>username=#&#123;username&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;password != null&quot;</span>&gt;</span>password=#&#123;password&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null&quot;</span>&gt;</span>email=#&#123;email&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;bio != null&quot;</span>&gt;</span>bio=#&#123;bio&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">  where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个例子中，set 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。</p><p>来看看与 set 元素等价的自定义 trim 元素吧：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;SET&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意，我们覆盖了后缀值设置，并且自定义了前缀值。</p><h3><span id="foreach"> foreach</span><a href="#foreach" class="header-anchor">#</a></h3><p>动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN 条件语句的时候）。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPostIn&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;domain.blog.Post&quot;</span>&gt;</span></span><br><span class="line">  SELECT *</span><br><span class="line">  FROM POST P</span><br><span class="line">  WHERE ID in</span><br><span class="line">  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;item&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>foreach 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。这个元素也不会错误地添加多余的分隔符，看它多智能！</p><p>提示 你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 foreach。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。</p><p>至此，我们已经完成了与 XML 配置及映射文件相关的讨论。下一章将详细探讨 Java API，以便你能充分利用已经创建的映射配置。</p><h3><span id="script"> script</span><a href="#script" class="header-anchor">#</a></h3><p>要在带注解的映射器接口类中使用动态 SQL，可以使用 script 元素。比如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Update(&#123;&quot;&lt;script&gt;&quot;,</span></span><br><span class="line"><span class="meta">     &quot;update Author&quot;,</span></span><br><span class="line"><span class="meta">     &quot;  &lt;set&gt;&quot;,</span></span><br><span class="line"><span class="meta">     &quot;    &lt;if test=&#x27;username != null&#x27;&gt;username=#&#123;username&#125;,&lt;/if&gt;&quot;,</span></span><br><span class="line"><span class="meta">     &quot;    &lt;if test=&#x27;password != null&#x27;&gt;password=#&#123;password&#125;,&lt;/if&gt;&quot;,</span></span><br><span class="line"><span class="meta">     &quot;    &lt;if test=&#x27;email != null&#x27;&gt;email=#&#123;email&#125;,&lt;/if&gt;&quot;,</span></span><br><span class="line"><span class="meta">     &quot;    &lt;if test=&#x27;bio != null&#x27;&gt;bio=#&#123;bio&#125;&lt;/if&gt;&quot;,</span></span><br><span class="line"><span class="meta">     &quot;  &lt;/set&gt;&quot;,</span></span><br><span class="line"><span class="meta">     &quot;where id=#&#123;id&#125;&quot;,</span></span><br><span class="line"><span class="meta">     &quot;&lt;/script&gt;&quot;&#125;)</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">updateAuthorValues</span><span class="params">(Author author)</span></span>;</span><br></pre></td></tr></table></figure><h3><span id="bind"> bind</span><a href="#bind" class="header-anchor">#</a></h3><p>bind 元素允许你在 OGNL 表达式以外创建一个变量，并将其绑定到当前的上下文。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlogsLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">&quot;pattern&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#x27;%&#x27; + _parameter.getTitle() + &#x27;%&#x27;&quot;</span> /&gt;</span></span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  WHERE title LIKE #&#123;pattern&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2><span id="duo-shu-ju-ku-zhi-chi"> 多数据库支持</span><a href="#duo-shu-ju-ku-zhi-chi" class="header-anchor">#</a></h2><p>如果配置了 databaseIdProvider，你就可以在动态代码中使用名为 “_databaseId” 的变量来为不同的数据库构建特定的语句。比如下面的例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">order</span>=<span class="string">&quot;BEFORE&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;_databaseId == &#x27;oracle&#x27;&quot;</span>&gt;</span></span><br><span class="line">      select seq_users.nextval from dual</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;_databaseId == &#x27;db2&#x27;&quot;</span>&gt;</span></span><br><span class="line">      select nextval for seq_users from sysibm.sysdummy1&quot;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">  insert into users values (#&#123;id&#125;, #&#123;name&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><h3><span id="dong-tai-sql-zhong-de-cha-ru-jiao-ben-yu-yan"> 动态 SQL 中的插入脚本语言</span><a href="#dong-tai-sql-zhong-de-cha-ru-jiao-ben-yu-yan" class="header-anchor">#</a></h3><p>MyBatis 从 3.2 版本开始支持插入脚本语言，这允许你插入一种语言驱动，并基于这种语言来编写动态 SQL 查询语句。</p><p>可以通过实现以下接口来插入一种语言：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LanguageDriver</span> </span>&#123;</span><br><span class="line">  <span class="function">ParameterHandler <span class="title">createParameterHandler</span><span class="params">(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql)</span></span>;</span><br><span class="line">  <span class="function">SqlSource <span class="title">createSqlSource</span><span class="params">(Configuration configuration, XNode script, Class&lt;?&gt; parameterType)</span></span>;</span><br><span class="line">  <span class="function">SqlSource <span class="title">createSqlSource</span><span class="params">(Configuration configuration, String script, Class&lt;?&gt; parameterType)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现自定义语言驱动后，你就可以在 mybatis-config.xml 文件中将它设置为默认语言：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;org.sample.MyLanguageDriver&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;myLanguage&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultScriptingLanguage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;myLanguage&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者，你也可以使用 lang 属性为特定的语句指定语言：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">lang</span>=<span class="string">&quot;myLanguage&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者，在你的 mapper 接口上添加 @Lang 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mapper</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Lang(MyLanguageDriver.class)</span></span><br><span class="line">  <span class="meta">@Select(&quot;SELECT * FROM BLOG&quot;)</span></span><br><span class="line">  <span class="function">List&lt;Blog&gt; <span class="title">selectBlog</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="mybatis-zhong-he-de-qu-bie"> Mybatis中$和#的区别</span><a href="#mybatis-zhong-he-de-qu-bie" class="header-anchor">#</a></h3><p>在SQL中引用这些参数的时候，可以使用两种方式#{parameterName}或者${parameterName}，首先，我们说一下这两种引用参数时的区别，使用#{parameterName}引用参数的时候，Mybatis会把这个参数认为是一个字符串，例如传入参数是“Smith”，那么在SQL（Select * from emp where name = #{employeeName})使用的时候就会转换为Select * from emp where name = ‘Smith’; 同时在SQL（Select * from emp where name = ${employeeName}）使用的时候就会转换为Select * from emp where name = Smith。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. #将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。如：</span><br><span class="line">order by #user_id#，如果传入的值是111,那么解析成sql时的值为order by &quot;111&quot;,</span><br><span class="line"> 如果传入的值是id，则解析成的sql为order by &quot;id&quot;.</span><br><span class="line">2. $将传入的数据直接显示生成在sql中。如：order by $user_id$，</span><br><span class="line">如果传入的值是111,那么解析成sql时的值为order by user_id, </span><br><span class="line"> 如果传入的值是id，则解析成的sql为order by id.</span><br><span class="line">3. #方式能够很大程度防止sql注入。</span><br><span class="line">4. $方式无法防止Sql注入。</span><br><span class="line">5. $方式一般用于传入数据库对象，例如传入表名.</span><br><span class="line">6. 一般能用#的就别用$.</span><br></pre></td></tr></table></figure><h2><span id="kuo-zhan-yue-du"> 扩展阅读</span><a href="#kuo-zhan-yue-du" class="header-anchor">#</a></h2><ol><li>Mybatis文档：<a href="https://mybatis.org/mybatis-3/zh/dynamic-sql.html">https://mybatis.org/mybatis-3/zh/dynamic-sql.html</a></li></ol><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">&lt;p&gt;动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。&lt;/p&gt;
&lt;p&gt;使用动态 SQL 并非一件易事，但借助可用于任何 SQL 映射语句中的强大的动态 SQL 语言，MyBatis 显著地提升了这一特性的易用性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/posts/2020/mybatis.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://blog.beyhub.com/categories/Java/"/>
    
    
    <category term="MySQL" scheme="https://blog.beyhub.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>BPM工作流引擎Activiti</title>
    <link href="https://blog.beyhub.com/p/7e089f4a881f/"/>
    <id>https://blog.beyhub.com/p/7e089f4a881f/</id>
    <published>2020-04-10T19:11:52.000Z</published>
    <updated>2021-08-21T10:57:27.283Z</updated>
    
    <content type="html"><![CDATA[<p>Activiti 是一个业务流程管理的开源框架，支持BPMN2.0流程定义协议。其主要功能有流程定义、流程部署、流程执行、用户群组管理、历史记录查询等功能。越是复杂的业务越是需要流程管理的工具，activiti就是很好的选择，从oa系统的审批到电商系统的购物，这些复杂的业务场景都能看到Activiti的身影。硬编码复杂的业务时，每一步的流转判断充满了风险，稍有不慎就得不到想要的结果，而问题追踪起来也非常麻烦。而基于activiti编写复杂的业务时，按照规范画出流程定义文件，业务可见即可得一目了然，大大降低了复杂业务出错的概率，剩下的事情就交给activiti去执行，它会严格按照流程的定义去执行。</p><span id="more"></span><h2 id="bpmbusiness-process-management"><a class="markdownIt-Anchor" href="#bpmbusiness-process-management"></a> BPM（Business Process Management）</h2><p>BPMN(Business Process Model and Notation)，业务流程建模和标注。 Notation是BPMN的核心，即使用图形来表达业务流程。另外，BPMN是由OMG组织维护的一个公开的标准，与任何特定商业组织或工具是没有关系，无需为此付费。BPMN和传统的流程图的区别如下：</p><ul><li>BPMN是一个正式的规范，各种图标、元件是有准确的含义和使用规范</li><li>BPMN可以描述基于事件触发的行为，比如响应超时、外部系统无法提供服务等</li></ul><p>下图为一个订单流程的描述：</p><p><img src="/images/posts/2020/bpmn.png" alt="" /></p><h2 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h2><ol><li>actitvti支持BPMN2.0流程定义协议。</li><li>activiti与Spring集成非常方便，甚至实现了Starter，集成SpringBoot更为方便。</li><li>activiti的社区活跃，github提交记录频繁，不断的有开发者给他添砖加瓦。</li><li>activiti的提供的api非常丰富，能够满足绝大部分的业务场景。</li></ol><h2 id="核心api"><a class="markdownIt-Anchor" href="#核心api"></a> 核心API</h2><p>activiti给使用者提供了大量的接口，这些接口能够完成从流程部署、流程运行以及历史流程记录查询的所有操作。主要的api有一下七个：</p><ol><li>RepositoryService，部署流程定义文件，管理流程定义实例。</li><li>RuntimeService，启动流程，管理流程实例，设置获取流程变量。</li><li>TaskService，处理任务、设置任务候选人（组）、指定任务处理人（组）、设置附件等。</li><li>FormService，获取任务的表单数据、提交完成一个任务、启动流程。</li><li>HistoryService，查询流程历史记录、事件记录、变量记录。</li><li>IdentityService，创建用户、创建组、查询用户（组）。</li><li>ManagementService，执行自定义命令、查询底层实体、数据表、提供更多的扩展功能。</li></ol><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ol><li>官方网站：<a href="https://www.activiti.org/">https://www.activiti.org/</a></li><li>BPMN 官网：<a href="http://www.bpmn.org/">http://www.bpmn.org/</a></li></ol><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">&lt;p&gt;Activiti 是一个业务流程管理的开源框架，支持BPMN2.0流程定义协议。其主要功能有流程定义、流程部署、流程执行、用户群组管理、历史记录查询等功能。越是复杂的业务越是需要流程管理的工具，activiti就是很好的选择，从oa系统的审批到电商系统的购物，这些复杂的业务场景都能看到Activiti的身影。硬编码复杂的业务时，每一步的流转判断充满了风险，稍有不慎就得不到想要的结果，而问题追踪起来也非常麻烦。而基于activiti编写复杂的业务时，按照规范画出流程定义文件，业务可见即可得一目了然，大大降低了复杂业务出错的概率，剩下的事情就交给activiti去执行，它会严格按照流程的定义去执行。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://blog.beyhub.com/categories/Java/"/>
    
    
    <category term="BPMN" scheme="https://blog.beyhub.com/tags/BPMN/"/>
    
  </entry>
  
  <entry>
    <title>Java CAS并发原语</title>
    <link href="https://blog.beyhub.com/p/2ae578083ace/"/>
    <id>https://blog.beyhub.com/p/2ae578083ace/</id>
    <published>2020-04-10T03:44:35.000Z</published>
    <updated>2021-08-21T14:07:10.545Z</updated>
    
    <content type="html"><![CDATA[<p>在Java并发中，我们最初接触的应该就是synchronized关键字了，但是synchronized属于重量级锁，很多时候会引起性能问题，volatile也是个不错的选择，但是volatile不能保证原子性，只能在某些场合下使用。</p><p>对CAS的理解，CAS是一种无锁算法，CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。CAS比较与交换的伪代码可以表示为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;   </span><br><span class="line">       备份旧数据；  </span><br><span class="line">       基于旧数据构造新数据；  </span><br><span class="line">&#125;<span class="keyword">while</span>(!CAS( 内存地址，备份的旧数据，新数据 ))  </span><br></pre></td></tr></table></figure><h2><span id="乐观锁与悲观锁"> 乐观锁与悲观锁</span></h2><p>像synchronized这种独占锁属于悲观锁，它是在假设一定会发生冲突的，那么加锁恰好有用，除此之外，还有乐观锁，乐观锁的含义就是假设没有发生冲突，那么我正好可以进行某项操作，如果要是发生冲突呢，那我就重试直到成功，乐观锁最常见的就是CAS。</p><p>我们在读Concurrent包下的类的源码时，发现无论是ReenterLock内部的AQS，还是各种Atomic开头的原子类，内部都应用到了CAS，最常见的就是我们在并发编程时遇到的i++这种情况。传统的方法肯定是在方法上加上synchronized关键字:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种方法在性能上可能会差一点，我们还可以使用AtomicInteger，就可以保证i原子的++了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> AtomicInteger i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们来看getAndIncrement的内部：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再深入到getAndAddInt():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们见到compareAndSwapInt这个函数，它也是CAS缩写的由来。那么仔细分析下这个函数做了什么呢？<br>首先我们发现compareAndSwapInt前面的this，那么它属于哪个类呢，我们看上一步getAndAddInt，前面是unsafe。这里我们进入的Unsafe类。这里要对Unsafe类做个说明。结合AtomicInteger的定义来说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6214790243416807050L</span>;</span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>在AtomicInteger数据定义的部分，我们可以看到，其实实际存储的值是放在value中的，除此之外我们还获取了unsafe实例，并且定义了valueOffset。再看到static块，懂类加载过程的都知道，static块的加载发生于类加载的时候，是最先初始化的，这时候我们调用unsafe的objectFieldOffset从Atomic类文件中获取value的偏移量，那么valueOffset其实就是记录value的偏移量的。</p><p>再回到上面一个函数getAndAddInt，我们看var5获取的是什么，通过调用unsafe的getIntVolatile(var1, var2)，这是个native方法，具体实现到JDK源码里去看了，其实就是获取var1中，var2偏移量处的值。var1就是AtomicInteger，var2就是我们前面提到的valueOffset,这样我们就从内存里获取到现在valueOffset处的值了。</p><p>现在重点来了，compareAndSwapInt（var1, var2, var5, var5 + var4）其实换成compareAndSwapInt（obj, offset, expect, update）比较清楚，意思就是如果obj内的value和expect相等，就证明没有其他线程改变过这个变量，那么就更新它为update，如果这一步的CAS没有成功，那就采用自旋的方式继续进行CAS操作，取出乍一看这也是两个步骤了啊，其实在JNI里是借助于一个CPU指令完成的。所以还是原子操作。</p><h2><span id="cas底层原理"> CAS底层原理</span></h2><p>CAS底层使用JNI调用C代码实现的，如果你有Hotspot源码，那么在Unsafe.cpp里可以找到它的实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static JNINativeMethod methods_15[] = &#123;</span><br><span class="line">    //省略一堆代码...</span><br><span class="line">    &#123;CC&quot;compareAndSwapInt&quot;,  CC&quot;(&quot;OBJ&quot;J&quot;&quot;I&quot;&quot;I&quot;&quot;)Z&quot;,      FN_PTR(Unsafe_CompareAndSwapInt)&#125;,</span><br><span class="line">    &#123;CC&quot;compareAndSwapLong&quot;, CC&quot;(&quot;OBJ&quot;J&quot;&quot;J&quot;&quot;J&quot;&quot;)Z&quot;,      FN_PTR(Unsafe_CompareAndSwapLong)&#125;,</span><br><span class="line">    //省略一堆代码...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以看到compareAndSwapInt实现是在Unsafe_CompareAndSwapInt里面，再深入到Unsafe_CompareAndSwapInt:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  UnsafeWrapper(&quot;Unsafe_CompareAndSwapInt&quot;);</span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class="line">  return (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure><p>p是取出的对象，addr是p中offset处的地址，最后调用了Atomic::cmpxchg(x, addr, e), 其中参数x是即将更新的值，参数e是原内存的值。代码中能看到cmpxchg有基于各个平台的实现，这里我选择Linux X86平台下的源码分析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">inline jint     Atomic::cmpxchg    (jint     exchange_value, volatile jint*     dest, jint     compare_value) &#123;</span><br><span class="line">  int mp = os::is_MP();</span><br><span class="line">  __asm__ volatile (LOCK_IF_MP(%4) &quot;cmpxchgl %1,(%3)&quot;</span><br><span class="line">                    : &quot;=a&quot; (exchange_value)</span><br><span class="line">                    : &quot;r&quot; (exchange_value), &quot;a&quot; (compare_value), &quot;r&quot; (dest), &quot;r&quot; (mp)</span><br><span class="line">                    : &quot;cc&quot;, &quot;memory&quot;);</span><br><span class="line">  return exchange_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一段小汇编，__asm__说明是ASM汇编，__volatile__禁止编译器优化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Adding a lock prefix to an instruction on MP machine</span><br><span class="line">#define LOCK_IF_MP(mp) &quot;cmp $0, &quot; #mp &quot;; je 1f; lock; 1: &quot;</span><br></pre></td></tr></table></figure><p>os::is_MP判断当前系统是否为多核系统，如果是就给总线加锁，所以同一芯片上的其他处理器就暂时不能通过总线访问内存，保证了该指令在多处理器环境下的原子性。</p><p>在正式解读这段汇编前，我们来了解下嵌入汇编的基本格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">asm ( assembler template</span><br><span class="line">    : output operands                  /* optional */</span><br><span class="line">    : input operands                   /* optional */</span><br><span class="line">    : list of clobbered registers      /* optional */</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>template就是cmpxchgl %1,(%3)表示汇编模板</li><li>output operands表示输出操作数,=a对应eax寄存器</li><li>input operand 表示输入参数，%1 就是exchange_value, %3是dest, %4就是mp， r表示任意寄存器，a还是eax寄存器</li><li>list of clobbered registers就是些额外参数，cc表示编译器cmpxchgl的执行将影响到标志寄存器, memory告诉编译器要重新从内存中读取变量的最新值，这点实现了volatile的感觉。</li></ul><p>那么表达式其实就是cmpxchgl exchange_value ,dest，我们会发现%2也就是compare_value没有用上，这里就要分析cmpxchgl的语义了。cmpxchgl末尾l表示操作数长度为4，上面已经知道了。cmpxchgl会默认比较eax寄存器的值即compare_value和exchange_value的值，如果相等，就把dest的值赋值给exchange_value,否则，将exchange_value赋值给eax。具体汇编指令可以查看Intel手册CMPXCHG<br>最终，JDK通过CPU的cmpxchgl指令的支持，实现AtomicInteger的CAS操作的原子性。</p><h2><span id="cas-的问题"> CAS 的问题</span></h2><h3><span id="aba问题"> ABA问题</span></h3><p>CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。这就是CAS的ABA问题。</p><p>常见的解决思路是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A-B-A 就会变成1A-2B-3A。<br>目前在JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><h3><span id="循环时间长开销大"> 循环时间长开销大</span></h3><p>上面我们说过如果CAS不成功，则会原地自旋，如果长时间自旋会给CPU带来非常大的执行开销。</p><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Java并发中，我们最初接触的应该就是synchronized关键字了，但是synchronized属于重量级锁，很多时候会引起性能问题，volatile也是个不错的选择，但是volatile不能保证原子性，只能在某些场合下使用。&lt;/p&gt;
&lt;p&gt;对CAS的理解，CAS是一</summary>
      
    
    
    
    <category term="后端" scheme="https://blog.beyhub.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://blog.beyhub.com/tags/Java/"/>
    
    <category term="锁" scheme="https://blog.beyhub.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>JVM 类的加载机制</title>
    <link href="https://blog.beyhub.com/p/799d80e72695/"/>
    <id>https://blog.beyhub.com/p/799d80e72695/</id>
    <published>2020-04-10T03:36:59.000Z</published>
    <updated>2021-08-21T11:43:12.986Z</updated>
    
    <content type="html"><![CDATA[<p>从类被加载到虚拟机内存中开始，到卸御出内存为止，它的整个生命周期分为7个阶段，加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)、卸御(Unloading)。其中验证、准备、解析三个部分统称为连接。</p><p><img src="/images/posts/2020/jvm-classloader.webp" alt></p><span id="more"></span><h2><span id="java类加载机制的七个阶段"> Java类加载机制的七个阶段</span></h2><p>当我们的Java代码编译完成后，会生成对应的 class 文件。接着我们运行java Demo命令的时候，我们其实是启动了JVM 虚拟机执行 class 字节码文件的内容。而 JVM 虚拟机执行 class 字节码的过程可以分为七个阶段：加载、验证、准备、解析、初始化、使用、卸载。</p><h3><span id="加载"> 加载</span></h3><p>下面是对于加载过程最为官方的描述。</p><p>加载阶段是类加载过程的第一个阶段。在这个阶段，JVM 的主要目的是将字节码从各个位置（网络、磁盘等）转化为二进制字节流加载到内存中，接着会为这个类在 JVM 的方法区创建一个对应的 Class 对象，这个 Class 对象就是这个类各种数据的访问入口。</p><p>其实加载阶段用一句话来说就是：把代码数据加载到内存中。这个过程对于我们解答这道问题没有直接的关系，但这是类加载机制的一个过程，所以必须要提一下。</p><h3><span id="验证"> 验证</span></h3><p>当 JVM 加载完 Class 字节码文件并在方法区创建对应的 Class 对象之后，JVM 便会启动对该字节码流的校验，只有符合 JVM 字节码规范的文件才能被 JVM 正确执行。这个校验过程大致可以分为下面几个类型：</p><p>JVM规范校验。JVM 会对字节流进行文件格式校验，判断其是否符合 JVM 规范，是否能被当前版本的虚拟机处理。例如：文件是否是以 0x cafe bene开头，主次版本号是否在当前虚拟机处理范围之内等。<br>代码逻辑校验。JVM 会对代码组成的数据流和控制流进行校验，确保 JVM 运行该字节码文件后不会出现致命错误。例如一个方法要求传入 int 类型的参数，但是使用它的时候却传入了一个 String 类型的参数。一个方法要求返回 String 类型的结果，但是最后却没有返回结果。代码中引用了一个名为 Apple 的类，但是你实际上却没有定义 Apple 类。<br>当代码数据被加载到内存中后，虚拟机就会对代码数据进行校验，看看这份代码是不是真的按照JVM规范去写的。这个过程对于我们解答问题也没有直接的关系，但是了解类加载机制必须要知道有这个过程。</p><h3><span id="准备重点"> 准备（重点）</span></h3><p>当完成字节码文件的校验之后，JVM 便会开始为类变量分配内存并初始化。这里需要注意两个关键点，即内存分配的对象以及初始化的类型。</p><p>内存分配的对象。Java 中的变量有「类变量」和「类成员变量」两种类型，「类变量」指的是被 static 修饰的变量，而其他所有类型的变量都属于「类成员变量」。在准备阶段，JVM 只会为「类变量」分配内存，而不会为「类成员变量」分配内存。「类成员变量」的内存分配需要等到初始化阶段才开始。<br>例如下面的代码在准备阶段，只会为 factor 属性分配内存，而不会为 website 属性分配内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> factor = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> String website = <span class="string">&quot;www.cnblogs.com/chanshuyi&quot;</span>;</span><br></pre></td></tr></table></figure><p>初始化的类型。在准备阶段，JVM 会为类变量分配内存，并为其初始化。但是这里的初始化指的是为变量赋予 Java 语言中该数据类型的零值，而不是用户代码里初始化的值。<br>例如下面的代码在准备阶段之后，sector 的值将是 0，而不是 3。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> sector = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>但如果一个变量是常量（被 static final 修饰）的话，那么在准备阶段，属性便会被赋予用户希望的值。例如下面的代码在准备阶段之后，number 的值将是 3，而不是 0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> number = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>之所以 static final 会直接被复制，而 static 变量会被赋予零值。其实我们稍微思考一下就能想明白了。</p><p>两个语句的区别是一个有 final 关键字修饰，另外一个没有。而 final 关键字在 Java 中代表不可改变的意思，意思就是说 number 的值一旦赋值就不会在改变了。既然一旦赋值就不会再改变，那么就必须一开始就给其赋予用户想要的值，因此被 final 修饰的类变量在准备阶段就会被赋予想要的值。而没有被 final 修饰的类变量，其可能在初始化阶段或者运行阶段发生变化，所以就没有必要在准备阶段对它赋予用户想要的值。</p><h3><span id="解析"> 解析</span></h3><p>当通过准备阶段之后，JVM 针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类引用进行解析。这个阶段的主要任务是将其在常量池中的符号引用替换成直接其在内存中的直接引用。</p><p>其实这个阶段对于我们来说也是几乎透明的，了解一下就好。</p><h3><span id="初始化重点"> 初始化（重点）</span></h3><p>到了初始化阶段，用户定义的 Java 程序代码才真正开始执行。在这个阶段，JVM 会根据语句执行顺序对类对象进行初始化，一般来说当 JVM 遇到下面 5 种情况的时候会触发初始化：</p><p>遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。<br>使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。<br>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。<br>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。<br>当使用 JDK1.7 动态语言支持时，如果一个 java.lang.invoke.MethodHandle实例最后的解析结果 REF_getstatic,REF_putstatic,REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。</p><h3><span id="使用"> 使用</span></h3><p>当 JVM 完成初始化阶段之后，JVM 便开始从入口方法开始执行用户的程序代码。这个阶段也只是了解一下就可以。</p><h3><span id="卸载"> 卸载</span></h3><p>当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存。这个阶段也只是了解一下就可以。</p><p>看完了Java的类加载机智之后，是不是有点懵呢。不怕，我们先通过一个小例子来醒醒神。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello ShuYi.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Book()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;书的构造方法&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;price=&quot;</span> + price +<span class="string">&quot;,amount=&quot;</span> + amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;书的普通代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> price = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;书的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> amount = <span class="number">112</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考一下上面这段代码输出什么？</p><p>书的静态代码块<br>Hello ShuYi.<br>怎么样，你答对了吗？是不是和你想得有点不一样呢。</p><p>下面我们来简单分析一下，首先根据上面说到的触发初始化的5种情况的第4种（当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类），我们会进行类的初始化。</p><p>那么类的初始化顺序到底是怎么样的呢？</p><p>在我们代码中，我们只知道有一个构造方法，但实际上Java代码编译成字节码之后，是没有构造方法的概念的，只有类初始化方法 和 对象初始化方法 。</p><p>那么这两个方法是怎么来的呢？</p><p>类初始化方法。编译器会按照其出现顺序，收集类变量的赋值语句、静态代码块，最终组成类初始化方法。类初始化方法一般在类初始化的时候执行。<br>上面的这个例子，其类初始化方法就是下面这段代码了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;书的静态代码块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> amount = <span class="number">112</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对象初始化方法。编译器会按照其出现顺序，收集成员变量的赋值语句、普通代码块，最后收集构造函数的代码，最终组成对象初始化方法。对象初始化方法一般在实例化类对象的时候执行。<br>上面这个例子，其对象初始化方法就是下面这段代码了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;书的普通代码块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> price = <span class="number">110</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;书的构造方法&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;price=&quot;</span> + price +<span class="string">&quot;,amount=&quot;</span> + amount);</span><br></pre></td></tr></table></figure><p>类初始化方法 和 对象初始化方法 之后，我们再来看这个例子，我们就不难得出上面的答案了。</p><p>但细心的朋友一定会发现，其实上面的这个例子其实没有执行对象初始化方法。</p><p>因为我们确实没有进行 Book 类对象的实例化。如果你在 main 方法中增加 new Book() 语句，你会发现对象的初始化方法执行了！</p><h2><span id="什么是类装载器classloader"> 什么是类装载器ClassLoader</span></h2><ol><li>ClassLoader是一个抽象类</li><li>ClassLoader的实例将读入Java字节码将类装载到JVM中</li><li>ClassLoader可以定制，满足不同的字节码流获取方式</li><li>ClassLoader负责类装载过程中的加载阶段。</li></ol><h2><span id="jvm中的类加载器"> JVM中的类加载器</span></h2><ol><li><p>启动类加载器（BootStrap ClassLoader）：引导类装入器是用本地代码实现的类装入器，它负责将 jdk中jre/lib下面的核心类库或-Xbootclasspath选项指定的jar包加载到内存中。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。</p></li><li><p>扩展类加载器（Extension ClassLoader）：扩展类加载器是由Sun的ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将jdk中jre/lib/ext或者由系统变量-Djava.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。</p></li><li><p>系统类加载器（System ClassLoader）：系统类加载器是由 Sun的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。它负责将系统类路径java -classpath或-Djava.class.path变量所指的目录下的类库加载到内存中。开发者可以直接使用系统类加载器。</p></li></ol><p>下图中展示了类加载器直接的关系和双亲委派模型</p><p><img src="/images/posts/2020/classloader2.webp" alt="双亲委派模型"></p><p>从图中我们发现除启动类加载器外，每个加载器都有父的类加载器。</p><blockquote><p>双亲委派机制：如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。</p></blockquote><p>从类的继承关系来看，ExtClassLoader和AppClassLoader都是继承URLClassLoader，都是ClassLoader的子类。而BootStrapClassLoader是有C++写的，不再java的ClassLoader子类中。</p><h2><span id="自定义类加载器"> 自定义类加载器</span></h2><p>前面提到了 Java 自带的加载器 BootstrapClassLoader、AppClassLoader和ExtClassLoader，这些都是 Java 已经提供好的。<br>而真正有意思的，是 自定义类加载器，它允许我们在运行时可以从本地磁盘或网络上动态加载自定义类。这使得开发者可以动态修复某些有问题的类，热更新代码。<br>下面来实现一个网络类加载器，这个加载器可以从网络上动态下载 .class 文件并加载到虚拟机中使用。<br>后面我还会写作与 热修复／动态更新 相关的文章，这里先学习 Java 层 NetworkClassLoader 相关的原理。</p><p>作为一个 NetworkClassLoader，它首先要继承 ClassLoader；<br>然后它要实现ClassLoader内的 findClass() 方法。注意，不是loadClass()方法，因为ClassLoader提供了loadClass()（如上面的源码），它会基于双亲委托机制去搜索某个 class，直到搜索不到才会调用自身的findClass()，如果直接复写loadClass()，那还要实现双亲委托机制；<br>在 findClass() 方法里，要从网络上下载一个 .class 文件，然后转化成 Class 对象供虚拟机使用。</p><p>具体实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load class from network</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = downloadClassData(name); <span class="comment">// 从远程下载</span></span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">super</span>.findClass(name); <span class="comment">// 未找到，抛异常</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length); <span class="comment">// convert class byte data to Class&lt;?&gt; object</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] downloadClassData(String name) &#123;</span><br><span class="line">        <span class="comment">// 从 localhost 下载 .class 文件</span></span><br><span class="line">        String path = <span class="string">&quot;http://localhost&quot;</span> + File.separatorChar + <span class="string">&quot;java&quot;</span> + File.separatorChar + name.replace(<span class="string">&#x27;.&#x27;</span>, File.separatorChar) + <span class="string">&quot;.class&quot;</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            URL url = <span class="keyword">new</span> URL(path);</span><br><span class="line">            InputStream ins = url.openStream();</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> bufferSize = <span class="number">4096</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line">            <span class="keyword">int</span> bytesNumRead = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, bytesNumRead); <span class="comment">// 把下载的二进制数据存入 ByteArrayOutputStream</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;Real NetworkClassLoader\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;networkClassLoader&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类的作用是从网络上（这里是本人的 local apache 服务器 <a href="http://localhost/java">http://localhost/java</a> 上）目录里去下载对应的 .class 文件，并转换成 Class&lt;?&gt; 返回回去使用。</p><p>下面我们来利用这个 NetworkClassLoader 去加载 localhost 上的 MusicPlayer 类：</p><p>首先把 MusicPlayer.class 放置于 /Library/WebServer/Documents/java （MacOS）目录下，由于 MacOS 自带 apache 服务器，这里是服务器的默认目录；执行下面一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String className = <span class="string">&quot;classloader.NetworkClass&quot;</span>;</span><br><span class="line">NetworkClassLoader networkClassLoader = <span class="keyword">new</span> NetworkClassLoader();</span><br><span class="line">Class&lt;?&gt; clazz  = networkClassLoader.loadClass(className);</span><br></pre></td></tr></table></figure><p>正常运行，加载 <a href="http://localhost/java/classloader/MusicPlayer.class%E6%88%90%E5%8A%9F%E3%80%82%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%87%BA">http://localhost/java/classloader/MusicPlayer.class成功。可以看出</a> NetworkClassLoader 可以正常工作，如果读者要用的话，只要稍微修改 url 的拼接方式即可自行使用。</p><h1><span id="小结"> 小结</span></h1><p>类加载方式是 Java 上非常创新的一项技术，给未来的热修复技术提供了可能。本文力求通过简单的语言和合适的例子来讲解其中双亲委托机制、自定义加载器等，并开发了自定义的NetworkClassLoader。当然，类加载是很有意思的技术，很难覆盖所有知识点，比如不同类加载器加载同一个类，得到的实例却不是同一个等等。</p><h2><span id="双亲委派模型的好处"> 双亲委派模型的好处</span></h2><p>Java类随着加载它的类加载器一起具备了一种带有优先级的层次关系。比如，Java中的Object类，它存放在rt.jar之中,无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object在各种类加载环境中都是同一个类。如果不采用双亲委派模型，那么由各个类加载器自己取加载的话，那么系统中会存在多种不同的Object类。</p><h1><span id="参考"> 参考</span></h1><ol><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html">深入探讨 Java 类加载器</a></li></ol><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">&lt;p&gt;从类被加载到虚拟机内存中开始，到卸御出内存为止，它的整个生命周期分为7个阶段，加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)、卸御(Unloading)。其中验证、准备、解析三个部分统称为连接。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/posts/2020/jvm-classloader.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="https://blog.beyhub.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="JVM" scheme="https://blog.beyhub.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Synchronized修饰静态方法和非静态方法总结</title>
    <link href="https://blog.beyhub.com/p/110159ef9ed4/"/>
    <id>https://blog.beyhub.com/p/110159ef9ed4/</id>
    <published>2020-04-09T23:34:49.000Z</published>
    <updated>2021-08-21T11:44:58.448Z</updated>
    
    <content type="html"><![CDATA[<p>synchronized 的本质就是一个可重入锁，大致分为以下两类</p><ol><li>有对象锁 synchronized(this),或者非静态方法上加synchronized修饰</li><li>类锁 synchronized(XX.class),或者静态方法上加synchronized修饰</li></ol><span id="more"></span><h2><span id="synchronized修饰非静态方法实际上是对调用该方法的对象加锁俗称对象锁"> Synchronized修饰非静态方法，实际上是对调用该方法的对象加锁，俗称“对象锁”</span></h2><p>Java中每个对象都有一个锁，并且是唯一的。假设分配的一个对象空间，里面有多个方法，相当于空间里面有多个小房间，如果我们把所有的小房间都加锁，因为这个对象只有一把钥匙，因此同一时间只能有一个人打开一个小房间，然后用完了还回去，再由JVM 去分配下一个获得钥匙的人。</p><p>情况1：同一个对象在两个线程中分别访问该对象的两个同步方法<br>结果：会产生互斥。<br>解释：因为锁针对的是对象，当对象调用一个synchronized方法时，其他同步方法需要等待其执行结束并释放锁后才能执行。</p><p>情况2：不同对象在两个线程中调用同一个同步方法<br>结果：不会产生互斥。<br>解释：因为是两个对象，锁针对的是对象，并不是方法，所以可以并发执行，不会互斥。形象的来说就是因为我们每个线程在调用方法的时候都是new 一个对象，那么就会出现两个空间，两把钥匙，</p><h2><span id="synchronized修饰静态方法实际上是对该类对象加锁俗称类锁"> Synchronized修饰静态方法，实际上是对该类对象加锁，俗称“类锁”</span></h2><p>情况1：用类直接在两个线程中调用两个不同的同步方法<br>结果：会产生互斥。<br>解释：因为对静态对象加锁实际上对类（.class）加锁，类对象只有一个，可以理解为任何时候都只有一个空间，里面有N个房间，一把锁，因此房间（同步方法）之间一定是互斥的。</p><p>注：上述情况和用单例模式声明一个对象来调用非静态方法的情况是一样的，因为永远就只有这一个对象。所以访问同步方法之间一定是互斥的。</p><p>情况2：用一个类的静态对象在两个线程中调用静态方法或非静态方法<br>结果：会产生互斥。<br>解释：因为是一个对象调用，同上。</p><p>情况3：一个对象在两个线程中分别调用一个静态同步方法和一个非静态同步方法<br>结果：不会产生互斥。<br>解释：因为虽然是一个对象调用，但是两个方法的锁类型不同，调用的静态方法实际上是类对象在调用，即这两个方法产生的并不是同一个对象锁，因此不会互斥，会并发执行。</p><p>测试代码：<br>同步方法类：SynchronizedTest.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line"><span class="comment">/*private SynchronizedTest()&#123;&#125;</span></span><br><span class="line"><span class="comment">private static SynchronizedTest st;           //懒汉式单例模式，线程不安全，需要加synchronized同步</span></span><br><span class="line"><span class="comment">public static SynchronizedTest getInstance()&#123;</span></span><br><span class="line"><span class="comment">if(st == null)&#123;</span></span><br><span class="line"><span class="comment">st = new SynchronizedTest();</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">return st;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="comment">/*private SynchronizedTest()&#123;&#125;</span></span><br><span class="line"><span class="comment">private static final SynchronizedTest st = new SynchronizedTest();  //饿汉式单利模式，天生线程安全</span></span><br><span class="line"><span class="comment">public static SynchronizedTest getInstance()&#123;</span></span><br><span class="line"><span class="comment">return st;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SynchronizedTest staticIn = <span class="keyword">new</span> SynchronizedTest();   <span class="comment">//静态对象</span></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;                                      <span class="comment">//非静态方法1</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;  </span><br><span class="line">     System.out.println(<span class="string">&quot;method1 is running!&quot;</span>);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;                                   <span class="comment">//非静态方法2</span></span><br><span class="line">     <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;method2 is running!&quot;</span>);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod1</span><span class="params">()</span></span>&#123;                     <span class="comment">//静态方法1</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;static method1 is running!&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod2</span><span class="params">()</span></span>&#123;                      <span class="comment">//静态方法2</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;static method2 is running!&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程类1：Thread1.java（释放不同的注释可以测试不同的情况）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//SynchronizedTest s = SynchronizedTest.getInstance();</span></span><br><span class="line"><span class="comment">//s.method1();</span></span><br><span class="line"><span class="comment">//SynchronizedTest s1 = new SynchronizedTest();</span></span><br><span class="line"><span class="comment">//s1.method1();</span></span><br><span class="line">SynchronizedTest.staticIn.method1();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//SynchronizedTest.staticMethod1();</span></span><br><span class="line"><span class="comment">//SynchronizedTest.staticMethod2();</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">线程类<span class="number">2</span>：Thread2.Java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//SynchronizedTest s = SynchronizedTest.getInstance();</span></span><br><span class="line"><span class="comment">//SynchronizedTest s2 = new SynchronizedTest();</span></span><br><span class="line"><span class="comment">//s2.method1();</span></span><br><span class="line"><span class="comment">//s.method2();</span></span><br><span class="line"><span class="comment">//SynchronizedTest.staticMethod1();</span></span><br><span class="line"><span class="comment">//SynchronizedTest.staticMethod2();</span></span><br><span class="line"><span class="comment">//SynchronizedTest.staticIn.method2();</span></span><br><span class="line">SynchronizedTest.staticIn.staticMethod1();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主类：ThreadMain.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadMain</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread1());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread2());</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        exec.execute(t1);</span><br><span class="line">        exec.execute(t2);</span><br><span class="line">        exec.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="总结"> 总结</span></h2><ol><li>对象锁钥匙只能有一把才能互斥，才能保证共享变量的唯一性</li><li>在静态方法上的锁，和 实例方法上的锁，默认不是同样的，如果同步需要制定两把锁一样。</li><li>关于同一个类的方法上的锁，来自于调用该方法的对象，如果调用该方法的对象是相同的，那么锁必然相同，否则就不相同。比如 new A().x() 和 new A().x(),对象不同，锁不同，如果A的单利的，就能互斥。</li><li>静态方法加锁，能和所有其他静态方法加锁的 进行互斥</li><li>静态方法加锁，和xx.class 锁效果一样，直接属于类的</li></ol><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">&lt;p&gt;synchronized 的本质就是一个可重入锁，大致分为以下两类&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有对象锁 synchronized(this),或者非静态方法上加synchronized修饰&lt;/li&gt;
&lt;li&gt;类锁 synchronized(XX.class),或者静态方法上加synchronized修饰&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="后端" scheme="https://blog.beyhub.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="锁" scheme="https://blog.beyhub.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Java中ArrayList和LinkedList的区别</title>
    <link href="https://blog.beyhub.com/p/f09fcd3aa487/"/>
    <id>https://blog.beyhub.com/p/f09fcd3aa487/</id>
    <published>2020-04-09T22:41:50.000Z</published>
    <updated>2021-08-21T04:12:22.449Z</updated>
    
    <content type="html"><![CDATA[<p>从数据结构上看，顾名思义，ArrayList是实现了基于动态数组的结构，而LinkedList则是基于实现链表的数据结构。而两种数据结构在程序上体现出来的优缺点在于增删和改查的速率，就此，我们分别作出说明。</p><span id="more"></span><h2><span id="shu-ju-de-geng-xin-he-cha-zhao"> 数据的更新和查找</span><a href="#shu-ju-de-geng-xin-he-cha-zhao" class="header-anchor">#</a></h2><p>ArrayList的所有数据是在同一个地址上,而LinkedList的每个数据都拥有自己的地址。所以在对数据进行查找的时候，由于LinkedList的每个数据地址不一样，get数据的时候ArrayList的速度会优于LinkedList，而更新数据的时候，虽然都是通过循环循环到指定节点修改数据，但LinkedList的查询速度已经是慢的，而且对于LinkedList而言，更新数据时不像ArrayList只需要找到对应下标更新就好，LinkedList需要修改指针，速率不言而喻</p><h2><span id="shu-ju-de-zeng-jia-he-shan-chu"> 数据的增加和删除</span><a href="#shu-ju-de-zeng-jia-he-shan-chu" class="header-anchor">#</a></h2><p>对于数据的增加元素，ArrayList是通过移动该元素之后的元素位置，其后元素位置全部+1，所以耗时较长，而LinkedList只需要将该元素前的后续指针指向该元素并将该元素的后续指针指向之后的元素即可。与增加相同，删除元素时ArrayList需要将被删除元素之后的元素位置-1，而LinkedList只需要将之后的元素前置指针指向前一元素，前一元素的指针指向后一元素即可。当然，事实上，若是单一元素的增删，尤其是在List末端增删一个元素，二者效率不相上下。</p><p>下面我们通过程序检验结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">50000</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getTime</span><span class="params">(List list)</span> </span>&#123;</span><br><span class="line">    insertByPosition(list);</span><br><span class="line">    readByPosition(list);</span><br><span class="line">    updateByPosition(list);</span><br><span class="line">    deleteByPosition(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向list的指定位置插入N个元素，并统计时间</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertByPosition</span><span class="params">(List list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        list.add(<span class="number">0</span>, i);</span><br><span class="line">    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> interval = endTime - startTime;</span><br><span class="line">    System.out.println(getListName(list) + <span class="string">&quot;插入&quot;</span> + N + <span class="string">&quot;条数据耗时：&quot;</span> + interval</span><br><span class="line">            + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从list中读取元素，并统计时间</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readByPosition</span><span class="params">(List list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        list.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> interval = endTime - startTime;</span><br><span class="line">    System.out.println(getListName(list) + <span class="string">&quot;查询&quot;</span> + N + <span class="string">&quot;条数据耗时：&quot;</span> + interval</span><br><span class="line">            + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从list的随机位置修改元素，并统计时间</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">updateByPosition</span><span class="params">(List list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">int</span> M = <span class="number">40000</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">40000</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> j = (<span class="keyword">int</span>)(<span class="number">1</span>+Math.random()*(<span class="number">40000</span>-<span class="number">1</span>+<span class="number">1</span>));</span><br><span class="line">    list.set(j, <span class="string">&quot;list&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> interval = endTime - startTime;</span><br><span class="line">    System.out.println(getListName(list) + <span class="string">&quot;随机修改&quot;</span> + M + <span class="string">&quot;条数据耗时&quot;</span> + interval</span><br><span class="line">            + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从list的指定位置删除N个元素，并统计时间</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteByPosition</span><span class="params">(List list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 删除list第一个位置元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> interval = endTime - startTime;</span><br><span class="line">    System.out.println(getListName(list) + <span class="string">&quot;删除&quot;</span> + N + <span class="string">&quot;条数据耗时&quot;</span> + interval</span><br><span class="line">            + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取list类型名称</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getListName</span><span class="params">(List list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list <span class="keyword">instanceof</span> LinkedList) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;LinkedList&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list <span class="keyword">instanceof</span> ArrayList) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ArrayList&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    getTime(<span class="keyword">new</span> ArrayList());</span><br><span class="line">    getTime(<span class="keyword">new</span> LinkedList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在我本机的运行结果如下：</p><p><img src="/images/posts/2020/arraylist-linkedlist.webp" alt></p><blockquote><p>由此可见在程序执行过程中，对大量数据的增删改查时就会面临效率问题，所以对于ArrayList和LinkedList的选择，多数情况下如果查询操作较多ArrayList的效果更好.如果删除,插入较多LinkedList的效果较好.当然，具体怎么用还看具体的需求.</p></blockquote><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">&lt;p&gt;从数据结构上看，顾名思义，ArrayList是实现了基于动态数组的结构，而LinkedList则是基于实现链表的数据结构。而两种数据结构在程序上体现出来的优缺点在于增删和改查的速率，就此，我们分别作出说明。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://blog.beyhub.com/categories/Java/"/>
    
    
    <category term="原理" scheme="https://blog.beyhub.com/tags/%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中事务隔离的级别</title>
    <link href="https://blog.beyhub.com/p/98d075607ba2/"/>
    <id>https://blog.beyhub.com/p/98d075607ba2/</id>
    <published>2020-04-09T22:36:34.000Z</published>
    <updated>2021-08-20T15:54:33.289Z</updated>
    
    <content type="html"><![CDATA[<p>数据库事务（简称:事务）是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。事务的使用是数据库管理系统区别文件系统的重要特征之一。事务拥有四个重要的特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability），人们习惯称之为 ACID 特性。下面我逐一对其进行解释。</p><span id="more"></span><h2 id="事务的四个特征"><a class="markdownIt-Anchor" href="#事务的四个特征"></a> 事务的四个特征</h2><h3 id="原子性atomicity"><a class="markdownIt-Anchor" href="#原子性atomicity"></a> 原子性（Atomicity）</h3><p>事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。例如，如果一个事务需要新增 100 条记录，但是在新增了 10 条记录之后就失败了，那么数据库将回滚对这 10 条新增的记录。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。</p><h3 id="一致性consistency"><a class="markdownIt-Anchor" href="#一致性consistency"></a> 一致性（Consistency）</h3><p>指事务将数据库从一种状态转变为另一种一致的的状态。事务开始前和结束后，数据库的完整性约束没有被破坏。例如工号带有唯一属性，如果经过一个修改工号的事务后，工号变的非唯一了，则表明一致性遭到了破坏。</p><h3 id="隔离性isolation"><a class="markdownIt-Anchor" href="#隔离性isolation"></a> 隔离性（Isolation）</h3><p>要求每个读写事务的对象对其他事务的操作对象能互相分离，即该事务提交前对其他事务不可见。 也可以理解为多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。这指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。例如一个用户在更新自己的个人信息的同时，是不能看到系统管理员也在更新该用户的个人信息（此时更新事务还未提交）。</p><p>注：MySQL 通过锁机制来保证事务的隔离性。</p><h3 id="持久性durability"><a class="markdownIt-Anchor" href="#持久性durability"></a> 持久性（Durability）</h3><p>事务一旦提交，则其结果就是永久性的。即使发生宕机的故障，数据库也能将数据恢复，也就是说事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。这只是从事务本身的角度来保证，排除 RDBMS（关系型数据库管理系统，例如 Oracle、MySQL 等）本身发生的故障。</p><p>注：MySQL 使用 redo log 来保证事务的持久性。</p><h2 id="事务的隔离级别"><a class="markdownIt-Anchor" href="#事务的隔离级别"></a> 事务的隔离级别</h2><p>SQL 标准定义的四种隔离级别被 ANSI（美国国家标准学会）和 ISO/IEC（国际标准）采用，每种级别对事务的处理能力会有不同程度的影响。</p><p>我们分别对四种隔离级别从并发程度由高到低进行描述，并用代码进行演示，数据库环境为 MySQL 5.7。</p><h3 id="read-uncommitted读未提交"><a class="markdownIt-Anchor" href="#read-uncommitted读未提交"></a> READ UNCOMMITTED（读未提交）</h3><p>该隔离级别的事务会读到其它未提交事务的数据，此现象也称之为脏读。</p><p>准备两个终端，在此命名为 mysql 终端 1 和 mysql 终端 2，再准备一张测试表 test，写入一条测试数据并调整隔离级别为 READ UNCOMMITTED，任意一个终端执行即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SET @@session.transaction_isolation = <span class="string">&#x27;READ-UNCOMMITTED&#x27;</span>;</span><br><span class="line">create database <span class="built_in">test</span>;</span><br><span class="line">use <span class="built_in">test</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test(id <span class="type">int</span> <span class="keyword">primary</span> key);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test(id) <span class="keyword">values</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>登录 mysql 终端 1，开启一个事务，将 ID 为 1 的记录更新为 2。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">update <span class="built_in">test</span> <span class="built_in">set</span> id = 2 <span class="built_in">where</span> id = 1;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test;  <span class="comment">-- 此时看到一条ID为2的记录</span></span><br></pre></td></tr></table></figure><p>登录 mysql 终端 2，开启一个事务后查看表中的数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use <span class="built_in">test</span>;</span><br><span class="line">begin;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test; <span class="comment">-- 此时看到一条 ID 为 2 的记录</span></span><br></pre></td></tr></table></figure><p>最后一步读取到了 mysql 终端 1 中未提交的事务（没有 commit 提交动作），即产生了脏读，大部分业务场景都不允许脏读出现，但是此隔离级别下数据库的并发是最好的。</p><h3 id="read-committed读提交"><a class="markdownIt-Anchor" href="#read-committed读提交"></a> READ COMMITTED（读提交）</h3><p>一个事务可以读取另一个已提交的事务，多次读取会造成不一样的结果，此现象称为不可重复读问题，Oracle 和 SQL Server 的默认隔离级别。</p><p>准备两个终端，在此命名为 mysql 终端 1 和 mysql 终端 2，再准备一张测试表 test，写入一条测试数据并调整隔离级别为 READ COMMITTED，任意一个终端执行即可。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.transaction_isolation <span class="operator">=</span> <span class="string">&#x27;READ-COMMITTED&#x27;</span>;</span><br><span class="line"><span class="keyword">create</span> database test;</span><br><span class="line">use test;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test(id <span class="type">int</span> <span class="keyword">primary</span> key);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test(id) <span class="keyword">values</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>登录 mysql 终端 1，开启一个事务，将 ID 为 1 的记录更新为 2，并确认记录数变更过来。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line">update test <span class="keyword">set</span> id <span class="operator">=</span> <span class="number">2</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test; <span class="comment">-- 此时看到一条记录为 2</span></span><br></pre></td></tr></table></figure><p>登录 mysql 终端 2，开启一个事务后，查看表中的数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use test;</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test; <span class="comment">-- 此时看一条 ID 为 1 的记录</span></span><br></pre></td></tr></table></figure><p>登录 mysql 终端 1，提交事务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>切换到 mysql 终端 2。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test; <span class="comment">-- 此时看到一条 ID 为 2 的记录</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>mysql 终端 2 在开启了一个事务之后，在第一次读取 test 表（此时 mysql 终端 1 的事务还未提交）时 ID 为 1，在第二次读取 test 表（此时 mysql 终端 1 的事务已经提交）时 ID 已经变为 2，说明在此隔离级别下已经读取到已提交的事务。</p><h3 id="repeatable-read可重复读"><a class="markdownIt-Anchor" href="#repeatable-read可重复读"></a> REPEATABLE READ（可重复读）</h3><p>该隔离级别是 MySQL 默认的隔离级别，在同一个事务里，select 的结果是事务开始时时间点的状态，因此，同样的 select 操作读到的结果会是一致的，但是，会有幻读现象。MySQL 的 InnoDB 引擎可以通过 next-key locks 机制（参考下文&quot;行锁的算法&quot;一节）来避免幻读。</p><p>准备两个终端，在此命名为 mysql 终端 1 和 mysql 终端 2，准备一张测试表 test 并调整隔离级别为 REPEATABLE READ，任意一个终端执行即可。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.transaction_isolation <span class="operator">=</span> <span class="string">&#x27;REPEATABLE-READ&#x27;</span>;</span><br><span class="line"><span class="keyword">create</span> database test;</span><br><span class="line">use test;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test(id <span class="type">int</span> <span class="keyword">primary</span> key,name <span class="type">varchar</span>(<span class="number">20</span>));</span><br></pre></td></tr></table></figure><p>登录 mysql 终端 1，开启一个事务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test; <span class="comment">-- 无记录</span></span><br></pre></td></tr></table></figure><p>登录 mysql 终端 2，开启一个事务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test; <span class="comment">-- 无记录</span></span><br></pre></td></tr></table></figure><p>切换到 mysql 终端 1，增加一条记录并提交。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test(id,name) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>切换到 msyql 终端 2。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test; <span class="comment">--此时查询还是无记录</span></span><br></pre></td></tr></table></figure><p>通过这一步可以证明，在该隔离级别下已经读取不到别的已提交的事务，如果想看到 mysql 终端 1 提交的事务，在 mysql 终端 2 将当前事务提交后再次查询就可以读取到 mysql 终端 1 提交的事务。我们接着实验，看看在该隔离级别下是否会存在别的问题。</p><p>此时接着在 mysql 终端 2 插入一条数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test(id,name) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>); <span class="comment">-- 此时报主键冲突的错误</span></span><br></pre></td></tr></table></figure><p>也许到这里您心里可能会有疑问，明明在第 5 步没有数据，为什么在这里会报错呢？其实这就是该隔离级别下可能产生的问题，MySQL 称之为幻读。注意我在这里强调的是 MySQL 数据库，Oracle 数据库对于幻读的定义可能有所不同。</p><h3 id="serializable序列化"><a class="markdownIt-Anchor" href="#serializable序列化"></a> SERIALIZABLE（序列化）</h3><p>在该隔离级别下事务都是串行顺序执行的，MySQL 数据库的 InnoDB 引擎会给读操作隐式加一把读共享锁，从而避免了脏读、不可重读复读和幻读问题。</p><p>准备两个终端，在此命名为 mysql 终端 1 和 mysql 终端 2，分别登入 mysql，准备一张测试表 test 并调整隔离级别为 SERIALIZABLE，任意一个终端执行即可。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.transaction_isolation <span class="operator">=</span> <span class="string">&#x27;SERIALIZABLE&#x27;</span>;</span><br><span class="line"><span class="keyword">create</span> database test;</span><br><span class="line">use test;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test(id <span class="type">int</span> <span class="keyword">primary</span> key);</span><br></pre></td></tr></table></figure><p>登录 mysql 终端 1，开启一个事务，并写入一条数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test(id) <span class="keyword">values</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>登录 mysql 终端 2，开启一个事务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test; <span class="comment">-- 此时会一直卡住</span></span><br></pre></td></tr></table></figure><p>立马切换到 mysql 终端 1,提交事务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>一旦事务提交，msyql 终端 2 会立马返回 ID 为 1 的记录，否则会一直卡住，直到超时，其中超时参数是由 innodb_lock_wait_timeout 控制。由于每条 select 语句都会加锁，所以该隔离级别的数据库并发能力最弱，但是有些资料表明该结论也不一定对，如果感兴趣，您可以自行做个压力测试。</p><p>表 1 总结了各个隔离级别下产生的一些问题。</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交</td><td>可以出现</td><td>可以出现</td><td>可以出现</td></tr><tr><td>读提交</td><td>不允许出现</td><td>可以出现</td><td>可以出现</td></tr><tr><td>可重复读</td><td>不允许出现</td><td>不允许出现</td><td>可以出现</td></tr><tr><td>序列化</td><td>不允许出现</td><td>不允许出现</td><td>不允许出现</td></tr></tbody></table><h2 id="mysql-中的锁"><a class="markdownIt-Anchor" href="#mysql-中的锁"></a> MySQL 中的锁</h2><p>锁也是数据库管理系统区别文件系统的重要特征之一。锁机制使得在对数据库进行并发访问时，可以保障数据的完整性和一致性。对于锁的实现，各个数据库厂商的实现方法都会有所不同。本文讨论 MySQL 中的 InnoDB 引擎的锁。</p><h3 id="锁的类型"><a class="markdownIt-Anchor" href="#锁的类型"></a> 锁的类型</h3><p>InnoDB 实现了两种类型的行级锁：</p><h4 id="共享锁也称为-s-锁允许事务读取一行数据"><a class="markdownIt-Anchor" href="#共享锁也称为-s-锁允许事务读取一行数据"></a> 共享锁（也称为 S 锁）：允许事务读取一行数据。</h4><p>可以使用 SQL 语句 select * from tableName where … lock in share mode; 手动加 S 锁。</p><h4 id="独占锁也称为-x-锁允许事务删除或更新一行数据"><a class="markdownIt-Anchor" href="#独占锁也称为-x-锁允许事务删除或更新一行数据"></a> 独占锁（也称为 X 锁）：允许事务删除或更新一行数据。</h4><p>可以使用 SQL 语句 select * from tableName where … for update; 手动加 X 锁。</p><p>S 锁和 S 锁是兼容的，X 锁和其它锁都不兼容，举个例子，事务 T1 获取了一个行 r1 的 S 锁，另外事务 T2 可以立即获得行 r1 的 S 锁，此时 T1 和 T2 共同获得行 r1 的 S 锁，此种情况称为锁兼容，但是另外一个事务 T2 此时如果想获得行 r1 的 X 锁，则必须等待 T1 对行 r 锁的释放，此种情况也成为锁冲突。</p><p>为了实现多粒度的锁机制，InnoDB 还有两种内部使用的意向锁，由 InnoDB 自动添加，且都是表级别的锁。</p><p>意向共享锁（IS）：事务即将给表中的各个行设置共享锁，事务给数据行加 S 锁前必须获得该表的 IS 锁。<br />意向排他锁（IX）：事务即将给表中的各个行设置排他锁，事务给数据行加 X 锁前必须获得该表 IX 锁。<br />意向锁的主要目的是为了使得行锁和表锁共存。表 2 列出了行级锁和表级意向锁的兼容性。</p><p>表 2. 行级锁和表级意向锁的兼容性</p><table><thead><tr><th>锁类型</th><th>X</th><th>IX</th><th>S</th><th>IS</th></tr></thead><tbody><tr><td>X</td><td>冲突</td><td>冲突</td><td>冲突</td><td>冲突</td></tr><tr><td>IX</td><td>冲突</td><td>兼容</td><td>冲突</td><td>兼容</td></tr><tr><td>S</td><td>冲突</td><td>冲突</td><td>兼容</td><td>兼容</td></tr><tr><td>IS</td><td>冲突</td><td>兼容</td><td>兼容</td><td>兼容</td></tr></tbody></table><h4 id="行锁的算法"><a class="markdownIt-Anchor" href="#行锁的算法"></a> 行锁的算法</h4><p>InnoDB 存储引擎使用三种行锁的算法用来满足相关事务隔离级别的要求。</p><h4 id="record-locks"><a class="markdownIt-Anchor" href="#record-locks"></a> Record Locks</h4><p>该锁为索引记录上的锁，如果表中没有定义索引，InnoDB 会默认为该表创建一个隐藏的聚簇索引，并使用该索引锁定记录。</p><h4 id="gap-locks"><a class="markdownIt-Anchor" href="#gap-locks"></a> Gap Locks</h4><p>该锁会锁定一个范围，但是不括记录本身。可以通过修改隔离级别为 READ COMMITTED 或者配置 innodb_locks_unsafe_for_binlog 参数为 ON。</p><h4 id="next-key-locks"><a class="markdownIt-Anchor" href="#next-key-locks"></a> Next-key Locks</h4><p>该锁就是 Record Locks 和 Gap Locks 的组合，即锁定一个范围并且锁定该记录本身。InnoDB 使用 Next-key Locks 解决幻读问题。需要注意的是，如果索引有唯一属性，则 InnnoDB 会自动将 Next-key Locks 降级为 Record Locks。举个例子，如果一个索引有 1, 3, 5 三个值，则该索引锁定的区间为 (-∞,1], (1,3], (3,5], (5,+ ∞)。</p><h4 id="死锁"><a class="markdownIt-Anchor" href="#死锁"></a> 死锁</h4><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p><p>InnoDB 引擎采取的是 wait-for graph 等待图的方法来自动检测死锁，如果发现死锁会自动回滚一个事务。</p><p>下面我们通过一个示例来了解死锁。</p><p>准备两个终端，在此命名为 mysql 终端 1 和 mysql 终端 2，分别登入 mysql，再准备一张测试表 test 写入两条测试数据，并调整隔离级别为 SERIALIZABLE，任意一个终端执行即可。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.transaction_isolation <span class="operator">=</span> <span class="string">&#x27;REPEATABLE-READ&#x27;</span>;</span><br><span class="line"><span class="keyword">create</span> database test;</span><br><span class="line">use test;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test(id <span class="type">int</span> <span class="keyword">primary</span> key);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test(id) <span class="keyword">values</span>(<span class="number">1</span>),(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>登录 mysql 终端 1，开启一个事务，手动给 ID 为 1 的记录加 X 锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">for</span> update;</span><br></pre></td></tr></table></figure><p>登录 mysql 终端 2，开启一个事务，手动给 ID 为 2 的记录加 X 锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span> <span class="keyword">for</span> update;</span><br></pre></td></tr></table></figure><p>切换到 mysql 终端 1，手动给 ID 为 2 的记录加 X 锁，此时会一直卡住，因为此时在等待第 3 步中 X 锁的释放，直到超时，超时时间由 innodb_lock_wait_timeout 控制。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span> <span class="keyword">for</span> update;</span><br></pre></td></tr></table></figure><p>在锁超时前立刻切换到 mysql 终端 2，手动给 ID 为 1 的记录加 X 锁，此时又会等待第 2 步中 X 所的释放，两个终端都在等待资源的释放，所以 InnoDB 引擎会立马检测到死锁产生，自动回滚一个事务，以防止死锁一直占用资源。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">for</span> update;</span><br><span class="line">ERROR <span class="number">1213</span> (<span class="number">40001</span>): Deadlock found <span class="keyword">when</span> trying <span class="keyword">to</span> <span class="keyword">get</span> lock; try restarting transaction</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时，通过 show engine innodb status\G 命令可以看到 LATEST DETECTED DEADLOCK 相关信息，即表明有死锁发生；或者通过配置 innodb_print_all_deadlocks（MySQL 5.6.2 版本开始提供）参数为 ON 将死锁相关信息打印到 MySQL 的错误日志。</p><h3 id="锁的优化建议"><a class="markdownIt-Anchor" href="#锁的优化建议"></a> 锁的优化建议</h3><p>锁如果利用不好，会给业务造成大量的卡顿现象，在了解了锁相关的一些知识点后，我们可以有意识的去避免锁带来的一些问题。</p><ol><li>合理设计索引，让 InnoDB 在索引键上面加锁的时候尽可能准确，尽可能的缩小锁定范围，避免造成不必要的锁定而影响其他 Query 的执行。</li><li>尽可能减少基于范围的数据检索过滤条件，避免因为间隙锁带来的负面影响而锁定了不该锁定的记录。</li><li>尽量控制事务的大小，减少锁定的资源量和锁定时间长度。</li><li>在业务环境允许的情况下，尽量使用较低级别的事务隔离，以减少 MySQL 因为实现事务隔离级别所带来的附加成本。</li></ol><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">&lt;p&gt;数据库事务（简称:事务）是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。事务的使用是数据库管理系统区别文件系统的重要特征之一。事务拥有四个重要的特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability），人们习惯称之为 ACID 特性。下面我逐一对其进行解释。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://blog.beyhub.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://blog.beyhub.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>基于Redis实现分布式锁</title>
    <link href="https://blog.beyhub.com/p/55a9c58bce22/"/>
    <id>https://blog.beyhub.com/p/55a9c58bce22/</id>
    <published>2020-04-09T22:31:52.000Z</published>
    <updated>2021-08-21T11:45:53.698Z</updated>
    
    <content type="html"><![CDATA[<p>在多线程的环境下，为了保证一个代码块在同一时间只能由一个线程访问，Java中我们一般可以使用synchronized语法和ReetrantLock去保证，这实际上是本地锁的方式。但是现在公司都是流行分布式架构，在分布式环境下，如何保证不同节点的线程同步执行呢？保证分布式操作的原子性。</p><span id="more"></span><h2><span id="简介"> 简介</span></h2><p>实际上，对于分布式场景，我们可以使用分布式锁，它是控制<strong>分布式系统之间互斥访问共享资源</strong>的一种方式。比如说在一个分布式系统中，多台机器上部署了多个服务，当客户端一个用户发起一个数据插入请求时，如果没有分布式锁机制保证，那么那多台机器上的多个服务可能进行并发插入操作，导致数据重复插入，对于某些不允许有多余数据的业务来说，这就会造成问题。而分布式锁机制就是为了解决类似这类问题，保证多个服务之间互斥的访问共享资源，如果一个服务抢占了分布式锁，其他服务没获取到锁，就不进行后续操作。大致意思如下图所示（不一定准确）</p><p><img src="/images/posts/2020/distributed-lock.png" alt="分布式锁"></p><p>Redis 锁主要利用 Redis 的 setnx 命令。</p><h2><span id="场景举例"> 场景举例</span></h2><ol><li>假设有一个进程A，每小时准点给用户发送一条短信&quot;Hello world&quot;，为了高可用，就必须在多台机器上面部署多个进程，避免宕机的情况；</li><li>假设部署在两台机器，那么问题来了，用户每个小时就会收到两条&quot;Hello world&quot;，信息就重复了；</li><li>我们希望只发送一条&quot;Hello world&quot;，那么就可以引入分布式锁的概念了；</li><li>进程A和进程B发送短信前先去注册一个锁，假设进程A抢到了锁，进程B就等待结果，如果发送成功了，那么B就放弃此次任务，等待下一个小时。</li><li>问题的核心就在于怎么注册锁，检查锁的存在和注册锁是一个原子性操作，类似mysql的主键，存在则不能insert，就是说你不能把我的锁覆盖了，你得等着；</li><li>我们有多种方式可以实现分布式锁，最简单的就是以每小时准点这个时间作为主键，到mysql写入一条数据，利用数据库来维持一致性。</li></ol><h3><span id="分布式锁一般有如下的特点"> 分布式锁一般有如下的特点：</span></h3><ul><li>互斥性： 同一时刻只能有一个线程持有锁</li><li>可重入性： 同一节点上的同一个线程如果获取了锁之后能够再次获取锁</li><li>锁超时：和J.U.C中的锁一样支持锁超时，防止死锁</li><li>高性能和高可用：加锁和解锁需要高效，同时也需要保证高可用，防止分布式锁失效</li><li>具备阻塞和非阻塞性：能够及时从阻塞状态中被唤醒</li></ul><h3><span id="我们一般实现分布式锁有以下几种方式"> 我们一般实现分布式锁有以下几种方式：</span></h3><ul><li>基于数据库</li><li>基于Redis</li><li>基于zookeeper</li><li>本篇文章主要介绍基于Redis如何实现分布式锁</li></ul><h2><span id="分布式锁应该具备的条件"> 分布式锁应该具备的条件</span></h2><ol><li>在分布式系统环境下，一个方法在同一时间只能被一个机器的的一个线程执行；</li><li>高可用的获取锁与释放锁；</li><li>高性能的获取锁与释放锁；</li><li>具备可重入特性；</li><li>具备锁失效机制，防止死锁；</li><li>具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。</li></ol><h2><span id="redis的分布式锁实现"> Redis的分布式锁实现</span></h2><h3><span id="利用setnxexpire命令-错误的做法"> 利用setnx+expire命令 (错误的做法)</span></h3><p>Redis的SETNX命令，setnx key value，将key设置为value，当键不存在时，才能成功，若键存在，什么也不做，成功返回1，失败返回0 。 SETNX实际上就是SET IF NOT Exists的缩写</p><p>因为分布式锁还需要超时机制，所以我们利用expire命令来设置，所以利用setnx+expire命令的核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(String key,String requset,<span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">    Long result = jedis.setnx(key, requset);</span><br><span class="line">    <span class="comment">// result = 1时，设置成功，否则设置失败</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">1L</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> jedis.expire(key, timeout) == <span class="number">1L</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上上面的步骤是有问题的，setnx和expire是分开的两步操作，不具有原子性，如果执行完第一条指令应用异常或者重启了，锁将无法过期。</p><p>一种改善方案就是使用Lua脚本来保证原子性（包含setnx和expire两条指令）</p><h3><span id="使用lua脚本包含setnx和expire两条指令"> 使用Lua脚本（包含setnx和expire两条指令）</span></h3><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock_with_lua</span><span class="params">(String key, String UniqueId, <span class="keyword">int</span> seconds)</span> </span>&#123;</span><br><span class="line">    String lua_scripts = <span class="string">&quot;if redis.call(&#x27;setnx&#x27;,KEYS[1],ARGV[1]) == 1 then&quot;</span> +</span><br><span class="line">            <span class="string">&quot;redis.call(&#x27;expire&#x27;,KEYS[1],ARGV[2]) return 1 else return 0 end&quot;</span>;</span><br><span class="line">    List&lt;String&gt; keys = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; values = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    keys.add(key);</span><br><span class="line">    values.add(UniqueId);</span><br><span class="line">    values.add(String.valueOf(seconds));</span><br><span class="line">    Object result = jedis.eval(lua_scripts, keys, values);</span><br><span class="line">    <span class="comment">//判断是否成功</span></span><br><span class="line">    <span class="keyword">return</span> result.equals(<span class="number">1L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="使用-set-key-value-ex-secondspx-millisecondsnxxx-命令-正确做法"> 使用 set key value [EX seconds][PX milliseconds][NX|XX] 命令 (正确做法)</span></h3><p>Redis在 2.6.12 版本开始，为 SET 命令增加一系列选项：</p><p>SET key value[EX seconds][PX milliseconds][NX|XX]</p><ul><li>EX seconds: 设定过期时间，单位为秒</li><li>PX milliseconds: 设定过期时间，单位为毫秒</li><li>NX: 仅当key不存在时设置值</li><li>XX: 仅当key存在时设置值</li></ul><p>set命令的nx选项，就等同于setnx命令，代码过程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock_with_set</span><span class="params">(String key, String UniqueId, <span class="keyword">int</span> seconds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>.equals(jedis.set(key, UniqueId, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;EX&quot;</span>, seconds));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>value必须要具有唯一性，我们可以用UUID来做，设置随机字符串保证唯一性，至于为什么要保证唯一性？假如value不是随机字符串，而是一个固定值，那么就可能存在下面的问题：</p><ol><li>客户端1获取锁成功</li><li>客户端1在某个操作上阻塞了太长时间</li><li>设置的key过期了，锁自动释放了</li><li>客户端2获取到了对应同一个资源的锁</li><li>客户端1从阻塞中恢复过来，因为value值一样，所以执行释放锁操作时就会释放掉客户端2持有的锁，这样就会造成问题</li></ol><p>所以通常来说，在释放锁时，我们需要对value进行验证</p><p>释放锁的实现<br>释放锁时需要验证value值，也就是说我们在获取锁的时候需要设置一个value，不能直接用del key这种粗暴的方式，因为直接del key任何客户端都可以进行解锁了，所以解锁时，我们需要判断锁是否是自己的，基于value值来判断，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">releaseLock_with_lua</span><span class="params">(String key,String value)</span> </span>&#123;</span><br><span class="line">    String luaScript = <span class="string">&quot;if redis.call(&#x27;get&#x27;,KEYS[1]) == ARGV[1] then &quot;</span> +</span><br><span class="line">            <span class="string">&quot;return redis.call(&#x27;del&#x27;,KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> jedis.eval(luaScript, Collections.singletonList(key), Collections.singletonList(value)).equals(<span class="number">1L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用Lua脚本的方式，尽量保证原子性。</p><p>使用 set key value [EX seconds][PX milliseconds][NX|XX] 命令 看上去很OK，实际上在Redis集群的时候也会出现问题，比如说A客户端在Redis的master节点上拿到了锁，但是这个加锁的key还没有同步到slave节点，master故障，发生故障转移，一个slave节点升级为master节点，B客户端也可以获取同个key的锁，但客户端A也已经拿到锁了，这就导致多个客户端都拿到锁。</p><p>所以针对Redis集群这种情况，还有其他方案</p><h3><span id="redlock算法-与-redisson-实现"> Redlock算法 与 Redisson 实现</span></h3><p>Redis作者 antirez基于分布式环境下提出了一种更高级的分布式锁的实现Redlock，原理如下：</p><blockquote><p>下面参考文章Redlock：Redis分布式锁最牛逼的实现 和 <a href="https://redis.io/topics/distlock">https://redis.io/topics/distlock</a></p></blockquote><p>假设有5个独立的Redis节点（注意这里的节点可以是5个Redis单master实例，也可以是5个Redis Cluster集群，但并不是有5个主节点的cluster集群）：</p><ul><li>获取当前Unix时间，以毫秒为单位</li><li>依次尝试从5个实例，使用相同的key和具有唯一性的value(例如UUID)获取锁，当向Redis请求获取锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应用小于锁的失效时间，例如你的锁自动失效时间为10s，则超时时间应该在5~50毫秒之间，这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务端没有在规定时间内响应，客户端应该尽快尝试去另外一个Redis实例请求获取锁</li><li>客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间，当且仅当从大多数(N/2+1，这里是3个节点)的Redis节点都取到锁，并且使用的时间小于锁失败时间时，锁才算获取成功。</li><li>如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）</li><li>如果某些原因，获取锁失败（没有在至少N/2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功，防止某些节点获取到锁但是客户端没有得到响应而导致接下来的一段时间不能被重新获取锁）</li></ul><h3><span id="redisson实现简单分布式锁"> Redisson实现简单分布式锁</span></h3><p>对于Java用户而言，我们经常使用Jedis，Jedis是Redis的Java客户端，除了Jedis之外，Redisson也是Java的客户端，Jedis是阻塞式I/O，而Redisson底层使用Netty可以实现非阻塞I/O，该客户端封装了锁的，继承了J.U.C的Lock接口，所以我们可以像使用ReentrantLock一样使用Redisson，具体使用过程如下。首先加入POM依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.10.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用Redisson，代码如下(与使用ReentrantLock类似）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 配置文件</span></span><br><span class="line">Config config = <span class="keyword">new</span> Config();</span><br><span class="line">config.useSingleServer()</span><br><span class="line">        .setAddress(<span class="string">&quot;redis://127.0.0.1:6379&quot;</span>)</span><br><span class="line">        .setPassword(RedisConfig.PASSWORD)</span><br><span class="line">        .setDatabase(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//2. 构造RedissonClient</span></span><br><span class="line">RedissonClient redissonClient = Redisson.create(config);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 设置锁定资源名称</span></span><br><span class="line">RLock lock = redissonClient.getLock(<span class="string">&quot;redlock&quot;</span>);</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;获取锁成功，实现业务逻辑&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于Redlock算法的实现，在Redisson中我们可以使用RedissonRedLock来完成。</p><h2><span id="redis实现的分布式锁轮子"> Redis实现的分布式锁轮子</span></h2><p>下面利用SpringBoot + Jedis + AOP的组合来实现一个简易的分布式锁。</p><h3><span id="自定义注解"> 自定义注解</span></h3><p>自定义一个注解，被注解的方法会执行获取分布式锁的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RedisLock &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务键</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">key</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁的过期秒数,默认是5秒</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expire</span><span class="params">()</span> <span class="keyword">default</span> 5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试加锁，最多等待时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">waitTime</span><span class="params">()</span> <span class="keyword">default</span> Long.MIN_VALUE</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁的超时时间单位</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">TimeUnit <span class="title">timeUnit</span><span class="params">()</span> <span class="keyword">default</span> TimeUnit.SECONDS</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="aop拦截器实现"> AOP拦截器实现</span></h3><p>在AOP中我们去执行获取分布式锁和释放分布式锁的逻辑，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockMethodAspect</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisLockHelper redisLockHelper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JedisUtil jedisUtil;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(LockMethodAspect.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(com.redis.lock.annotation.RedisLock)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = jedisUtil.getJedis();</span><br><span class="line">        MethodSignature signature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        Method method = signature.getMethod();</span><br><span class="line"></span><br><span class="line">        RedisLock redisLock = method.getAnnotation(RedisLock.class);</span><br><span class="line">        String value = UUID.randomUUID().toString();</span><br><span class="line">        String key = redisLock.key();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> islock = redisLockHelper.lock(jedis,key, value, redisLock.expire(), redisLock.timeUnit());</span><br><span class="line">            logger.info(<span class="string">&quot;isLock : &#123;&#125;&quot;</span>,islock);</span><br><span class="line">            <span class="keyword">if</span> (!islock) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;获取锁失败&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;获取锁失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> joinPoint.proceed();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;系统异常&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  <span class="keyword">finally</span> &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;释放锁&quot;</span>);</span><br><span class="line">            redisLockHelper.unlock(jedis,key, value);</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="redis实现分布式锁核心类"> Redis实现分布式锁核心类</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLockHelper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sleepTime = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 直接使用setnx + expire方式获取分布式锁</span></span><br><span class="line"><span class="comment">     * 非原子性</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock_setnx</span><span class="params">(Jedis jedis,String key, String value, <span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">        Long result = jedis.setnx(key, value);</span><br><span class="line">        <span class="comment">// result = 1时，设置成功，否则设置失败</span></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">1L</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> jedis.expire(key, timeout) == <span class="number">1L</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用Lua脚本，脚本中使用setnex+expire命令进行加锁操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> UniqueId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> seconds</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Lock_with_lua</span><span class="params">(Jedis jedis,String key, String UniqueId, <span class="keyword">int</span> seconds)</span> </span>&#123;</span><br><span class="line">        String lua_scripts = <span class="string">&quot;if redis.call(&#x27;setnx&#x27;,KEYS[1],ARGV[1]) == 1 then&quot;</span> +</span><br><span class="line">                <span class="string">&quot;redis.call(&#x27;expire&#x27;,KEYS[1],ARGV[2]) return 1 else return 0 end&quot;</span>;</span><br><span class="line">        List&lt;String&gt; keys = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; values = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        keys.add(key);</span><br><span class="line">        values.add(UniqueId);</span><br><span class="line">        values.add(String.valueOf(seconds));</span><br><span class="line">        Object result = jedis.eval(lua_scripts, keys, values);</span><br><span class="line">        <span class="comment">//判断是否成功</span></span><br><span class="line">        <span class="keyword">return</span> result.equals(<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在Redis的2.6.12及以后中,使用 set key value [NX] [EX] 命令</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(Jedis jedis,String key, String value, <span class="keyword">int</span> timeout, TimeUnit timeUnit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> seconds = timeUnit.toSeconds(timeout);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>.equals(jedis.set(key, value, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;EX&quot;</span>, seconds));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义获取锁的超时时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> waitTime</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeUnit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock_with_waitTime</span><span class="params">(Jedis jedis,String key, String value, <span class="keyword">int</span> timeout, <span class="keyword">long</span> waitTime,TimeUnit timeUnit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> seconds = timeUnit.toSeconds(timeout);</span><br><span class="line">        <span class="keyword">while</span> (waitTime &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            String result = jedis.set(key, value, <span class="string">&quot;nx&quot;</span>, <span class="string">&quot;ex&quot;</span>, seconds);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;OK&quot;</span>.equals(result)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            waitTime -= sleepTime;</span><br><span class="line">            Thread.sleep(sleepTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误的解锁方法—直接删除key</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock_with_del</span><span class="params">(Jedis jedis,String key)</span> </span>&#123;</span><br><span class="line">        jedis.del(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用Lua脚本进行解锁操纵，解锁的时候验证value值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">unlock</span><span class="params">(Jedis jedis,String key,String value)</span> </span>&#123;</span><br><span class="line">        String luaScript = <span class="string">&quot;if redis.call(&#x27;get&#x27;,KEYS[1]) == ARGV[1] then &quot;</span> +</span><br><span class="line">                <span class="string">&quot;return redis.call(&#x27;del&#x27;,KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> jedis.eval(luaScript, Collections.singletonList(key), Collections.singletonList(value)).equals(<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="controller层控制"> Controller层控制</span></h3><p>定义一个TestController来测试我们实现的分布式锁</p><h2><span id="123456789restcontrollerpublic-class-testcontroller-123-redislockkey-quotredis_lockquot-getmappingquotindexquot-public-string-index-123-return-quotindexquot-125125"> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RedisLock(key = &quot;redis_lock&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/index&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></span></h2><p>Zookeeper实现简单，但效率较低；Redis实现复杂，但效率较高。</p><blockquote><p>分布式锁重点在于互斥性，在任意一个时刻，只有一个客户端获取了锁。在实际的生产环境中，分布式锁的实现可能会更复杂，而我这里的讲述主要针对的是单机环境下的基于Redis的分布式锁实现，至于Redis集群环境并没有过多涉及，有兴趣的朋友可以查阅相关资料。</p></blockquote><h3><span id="redission-lock"> Redission Lock</span></h3><p>Lua脚本在Redis底层操作具有原子性（基于事务）</p><p><img src="/images/posts/2020/redission.png" alt></p><h2><span id="资料"> 资料</span></h2><ol><li>项目源码地址：<a href="https://github.com/pjmike/redis-distributed-lock">https://github.com/pjmike/redis-distributed-lock</a></li><li>Redis分布式锁：<a href="https://redis.io/topics/distlock">https://redis.io/topics/distlock</a></li><li>小米的实现方案：<a href="https://xiaomi-info.github.io/2019/12/17/redis-distributed-lock/">https://xiaomi-info.github.io/2019/12/17/redis-distributed-lock/</a></li><li>使用Redis SETNX 命令实现分布式锁：<a href="https://blog.csdn.net/lihao21/article/details/49104695">https://blog.csdn.net/lihao21/article/details/49104695</a></li><li><a href="https://www.bilibili.com/video/BV1Y7411j7qU?p=2">B站视频原理分析</a></li></ol><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">&lt;p&gt;在多线程的环境下，为了保证一个代码块在同一时间只能由一个线程访问，Java中我们一般可以使用synchronized语法和ReetrantLock去保证，这实际上是本地锁的方式。但是现在公司都是流行分布式架构，在分布式环境下，如何保证不同节点的线程同步执行呢？保证分布式操作的原子性。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://blog.beyhub.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="分布式" scheme="https://blog.beyhub.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="高并发" scheme="https://blog.beyhub.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础知识</title>
    <link href="https://blog.beyhub.com/p/fdf8dd944fdb/"/>
    <id>https://blog.beyhub.com/p/fdf8dd944fdb/</id>
    <published>2020-04-09T19:51:02.000Z</published>
    <updated>2021-08-20T15:54:25.046Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。<br />Redis 与其他 key - value 缓存产品有以下三个特点：</p><ul><li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ul><span id="more"></span><h2 id="事务处理"><a class="markdownIt-Anchor" href="#事务处理"></a> 事务处理</h2><p>Lua脚本在Redis底层了原子操作，并发场景下使用频率很高。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 开始一个事务</span><br><span class="line">redis 127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SET book-name &quot;Mastering C++ in 21 days&quot;</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; GET book-name</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SADD tag &quot;C++&quot; &quot;Programming&quot; &quot;Mastering Series&quot;</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SMEMBERS tag</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"># 触发事务执行</span><br><span class="line">redis 127.0.0.1:6379&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) &quot;Mastering C++ in 21 days&quot;</span><br><span class="line">3) (integer) 3</span><br><span class="line">4) 1) &quot;Mastering Series&quot;</span><br><span class="line">   2) &quot;C++&quot;</span><br><span class="line">   3) &quot;Programming&quot;</span><br></pre></td></tr></table></figure><h2 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h2><blockquote><p>Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)</p></blockquote><h3 id="string"><a class="markdownIt-Anchor" href="#string"></a> string</h3><p>string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。<br />string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。</p><p>注意：一个键最大能存储 512MB。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SET runoobkey redis</span><br><span class="line"><span class="comment"># OK</span></span><br><span class="line">redis 127.0.0.1:6379&gt; GET runoobkey</span><br><span class="line"><span class="comment"># &quot;redis&quot;</span></span><br></pre></td></tr></table></figure><h3 id="hash"><a class="markdownIt-Anchor" href="#hash"></a> hash</h3><p>Redis hash 是一个键值(key=&gt;value)对集合<br />Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象</p><blockquote><p>Hash实际是内部存储的Value为一个HashMap，也就是说，Key仍然是用户ID,value是一个Map，这个Map的key是成员的属性名，value是属性值，这样对数据的修改和存取都可以直接通过其内部Map的Key(Redis里称内部Map的key为field),也就是通过 key(用户ID) + field(属性标签)就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; DEL runoob</span><br><span class="line">redis 127.0.0.1:6379&gt; HMSET runoob field1 <span class="string">&quot;Hello&quot;</span> field2 <span class="string">&quot;World&quot;</span></span><br><span class="line"><span class="comment"># &quot;OK&quot;</span></span><br><span class="line">redis 127.0.0.1:6379&gt; HGET runoob field1</span><br><span class="line"><span class="comment"># &quot;Hello&quot;</span></span><br><span class="line">redis 127.0.0.1:6379&gt; HGET runoob field2</span><br><span class="line"><span class="comment"># &quot;World&quot;</span></span><br></pre></td></tr></table></figure><p>[1] <a href="https://zh.wikipedia.org/zh-hans/%E5%93%88%E5%B8%8C%E8%A1%A8">扩展阅读：HashTable哈希表</a></p><h3 id="list"><a class="markdownIt-Anchor" href="#list"></a> list</h3><p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）<br />一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; DEL runoob</span><br><span class="line">redis 127.0.0.1:6379&gt; lpush runoob redis</span><br><span class="line"><span class="comment"># (integer) 1</span></span><br><span class="line">redis 127.0.0.1:6379&gt; lpush runoob mongodb</span><br><span class="line"><span class="comment"># (integer) 2</span></span><br><span class="line">redis 127.0.0.1:6379&gt; lpush runoob rabitmq</span><br><span class="line"><span class="comment"># (integer) 3</span></span><br><span class="line">redis 127.0.0.1:6379&gt; lrange runoob 0 10</span><br><span class="line"><span class="comment"># 1) &quot;rabitmq&quot;</span></span><br><span class="line"><span class="comment"># 2) &quot;mongodb&quot;</span></span><br><span class="line"><span class="comment"># 3) &quot;redis&quot;</span></span><br></pre></td></tr></table></figure><h3 id="set"><a class="markdownIt-Anchor" href="#set"></a> set</h3><p>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。<br />Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。<br />集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SADD runoobkey redis</span><br><span class="line"><span class="comment"># (integer) 1</span></span><br><span class="line">redis 127.0.0.1:6379&gt; SADD runoobkey mongodb</span><br><span class="line"><span class="comment"># (integer) 1</span></span><br><span class="line">redis 127.0.0.1:6379&gt; SADD runoobkey mysql</span><br><span class="line"><span class="comment"># (integer) 1</span></span><br><span class="line">redis 127.0.0.1:6379&gt; SADD runoobkey mysql</span><br><span class="line"><span class="comment"># (integer) 0</span></span><br><span class="line">redis 127.0.0.1:6379&gt; SMEMBERS runoobkey</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1) &quot;mysql&quot;</span></span><br><span class="line"><span class="comment"># 2) &quot;mongodb&quot;</span></span><br><span class="line"><span class="comment"># 3) &quot;redis&quot;</span></span><br></pre></td></tr></table></figure><h3 id="zset-sorted-set-有序集合"><a class="markdownIt-Anchor" href="#zset-sorted-set-有序集合"></a> zset (sorted set 有序集合)</h3><p>zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。<br />不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。<br />zset的成员是唯一的,但分数(score)却可以重复。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; ZADD runoobkey 1 redis</span><br><span class="line"><span class="comment"># (integer) 1</span></span><br><span class="line">redis 127.0.0.1:6379&gt; ZADD runoobkey 2 mongodb</span><br><span class="line"><span class="comment"># (integer) 1</span></span><br><span class="line">redis 127.0.0.1:6379&gt; ZADD runoobkey 3 mysql</span><br><span class="line"><span class="comment"># (integer) 1</span></span><br><span class="line">redis 127.0.0.1:6379&gt; ZADD runoobkey 3 mysql</span><br><span class="line"><span class="comment"># (integer) 0</span></span><br><span class="line">redis 127.0.0.1:6379&gt; ZADD runoobkey 4 mysql</span><br><span class="line"><span class="comment"># (integer) 0</span></span><br><span class="line">redis 127.0.0.1:6379&gt; ZRANGE runoobkey 0 10 WITHSCORES</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1) &quot;redis&quot;</span></span><br><span class="line"><span class="comment"># 2) &quot;1&quot;</span></span><br><span class="line"><span class="comment"># 3) &quot;mongodb&quot;</span></span><br><span class="line"><span class="comment"># 4) &quot;2&quot;</span></span><br><span class="line"><span class="comment"># 5) &quot;mysql&quot;</span></span><br><span class="line"><span class="comment"># 6) &quot;4&quot;</span></span><br></pre></td></tr></table></figure><h2 id="redis-lua"><a class="markdownIt-Anchor" href="#redis-lua"></a> Redis Lua</h2><p>从定义上来说，Redis 中的脚本本身就是一种事务， 所以任何在事务里可以完成的事，在脚本里面也能完成。并且一般来说， 使用脚本要来得更简单，并且速度更快。</p><p>使用事务时可能会遇上以下两种错误：</p><ul><li>事务在执行 EXEC 之前，入队的命令可能会出错。比如说，命令可能会产生语法错误（参数数量错误，参数名错误，等等），或者其他更严重的错误，比如内存不足（如果服务器使用 maxmemory 设置了最大内存限制的话）。</li><li>命令可能在 EXEC 调用之后失败。举个例子，事务中的命令可能处理了错误类型的键，比如将列表命令用在了字符串键上面，诸如此类。<br />对于发生在 EXEC 执行之前的错误，客户端以前的做法是检查命令入队所得的返回值：如果命令入队时返回 QUEUED ，那么入队成功；否则，就是入队失败。如果有命令在入队时失败，那么大部分客户端都会停止并取消这个事务。</li></ul><h3 id="redis中使用lua的好处"><a class="markdownIt-Anchor" href="#redis中使用lua的好处"></a> Redis中使用Lua的好处</h3><ol><li>减少网络开销。可以将多个请求通过脚本的形式一次发送，减少网络时延</li><li>原子操作。redis会将整个脚本作为一个整体执行，中间不会被其他命令插入。因此在编写脚本的过程中无需担心会出现竞态条件，无需使用事务。</li><li>复用。客户端发送的脚步会永久存在redis中，这样，其他客户端可以复用这一脚本而不需要使用代码完成相同的逻辑。</li></ol><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">&lt;p&gt;Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。&lt;br /&gt;
Redis 与其他 key - value 缓存产品有以下三个特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。&lt;/li&gt;
&lt;li&gt;Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。&lt;/li&gt;
&lt;li&gt;Redis支持数据的备份，即master-slave模式的数据备份。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://blog.beyhub.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Redis" scheme="https://blog.beyhub.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Java Web技能树</title>
    <link href="https://blog.beyhub.com/p/ae0a134d75cd/"/>
    <id>https://blog.beyhub.com/p/ae0a134d75cd/</id>
    <published>2020-04-09T09:46:16.000Z</published>
    <updated>2021-08-21T11:43:07.340Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="基础平台"> 基础平台</span></h1><ol><li>应用开发框架：Spring Boot</li><li>微服务框架：Spring Cloud(全家桶)</li><li>数据库ORM: JPA/MyBatis/Hibernate</li><li>任务调度: Quartz</li><li>RPC框架: Dubbo/gRPC</li></ol><h1><span id="数据库技术"> 数据库技术</span></h1><ol><li>缓存与高并发：Redis、EhCache</li><li>关系型数据库：MySQL(InnoDB)</li></ol><h1><span id="大数据与分布式"> 大数据与分布式</span></h1><ol><li>Zookeeper</li><li>消息队列：Kafka/RabbitMQ/RocketMQ</li><li>Hive</li><li>HBase</li><li>Hadoop</li><li>ElasticSearch</li><li>MongoDB</li></ol><h1><span id="运维平台-devops"> 运维平台 devOps</span></h1><ol><li>Docker容器技术</li><li>K8S容器编排</li></ol><h1><span id="项目管理"> 项目管理</span></h1><ol><li>JIRA</li><li>GIT</li></ol><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;基础平台&quot;&gt; 基础平台&lt;/span&gt;&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;应用开发框架：Spring Boot&lt;/li&gt;
&lt;li&gt;微服务框架：Spring Cloud(全家桶)&lt;/li&gt;
&lt;li&gt;数据库ORM: JPA/MyBatis/Hibernate&lt;/l</summary>
      
    
    
    
    <category term="后端" scheme="https://blog.beyhub.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://blog.beyhub.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-Bean基本原理</title>
    <link href="https://blog.beyhub.com/p/13588255e6b9/"/>
    <id>https://blog.beyhub.com/p/13588255e6b9/</id>
    <published>2020-04-09T08:59:34.000Z</published>
    <updated>2021-08-21T04:12:22.449Z</updated>
    
    <content type="html"><![CDATA[<p>被称作 bean 的对象是构成应用程序的支柱也是由 Spring IoC 容器管理的。bean 是一个被实例化，组装，并通过 Spring IoC 容器所管理的对象。这些 bean 是由用容器提供的配置元数据创建的，例如，已经在先前章节看到的，在 XML 的表单中的 定义。</p><p><img src="/images/posts/2020/bean-lifecycle.png" alt></p><blockquote><p>Spring 只帮我们管理单例模式 Bean 的完整生命周期，对于 prototype 的 bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期。</p></blockquote><span id="more"></span><h2><span id="ioc-yu-di-xiang-jie"> IoC与DI详解</span><a href="#ioc-yu-di-xiang-jie" class="header-anchor">#</a></h2><h3><span id="ioc-de-shi-xian-fang-shi-ji-yu-di-de-guan-xi"> IoC的实现方式 及 与DI的关系？</span><a href="#ioc-de-shi-xian-fang-shi-ji-yu-di-de-guan-xi" class="header-anchor">#</a></h3><p>**依赖查找(Dependency Lookup)：**容器中的受控对象通过容器的API来查找自己所依赖的资源和协作对象。<br>这种方式虽然降低了对象间的依赖，但是同时也使用到了容器的API，造成了我们无法在容器外使用和测试对象。<br>依赖查找是一种更加传统的IoC实现方式。</p><p>**依赖注入(Dependency Injection)：**这就是DI，字面上理解，依赖注入就是将服务注入到使用它的地方。对象只提供普通的方法让容器去决定依赖关系，<br>容器全权负责组件的装配，它会把符合依赖关系的对象通过属性（JavaBean中的setter）或者是构造子传递给需要的对象。</p><p>相对于IoC而言，依赖注入(DI)更加准确地描述了IoC的设计理念。所谓依赖注入，即组件之间的依赖关系由容器在应用系统运行期来决定，<br>也就是由容器动态地将某种依赖关系的目标对象实例注入到应用系统中的各个关联的组件之中。</p><h3><span id="spring-zhong-de-ioc-yu-di"> Spring中的IoC与DI</span><a href="#spring-zhong-de-ioc-yu-di" class="header-anchor">#</a></h3><p>IoC是Spring的核心，贯穿始终。对于Spring框架来说，就是由Spring来负责控制对象的生命周期和对象间的关系。<br>Spring中DI有两种实现方式—Setter方式(传值方式)和构造器方式(引用方式)。</p><h3><span id="ioc-de-shi-xian-yuan-li-fan-she-yu-gong-han-mo-shi"> IoC的实现原理：反射与工厂模式</span><a href="#ioc-de-shi-xian-yuan-li-fan-she-yu-gong-han-mo-shi" class="header-anchor">#</a></h3><h4><span id="fan-she"> 反射</span><a href="#fan-she" class="header-anchor">#</a></h4><p>反射是Java语言的一个特性，它允许程序在运行时（注意不是编译的时候）来进行自我检查并且对内部的成员进行操作。例如它允许一个Java类获取它所有的成员变量和方法并且显示出来。</p><p>反射主要是指程序可以访问，检测和修改它本身状态或行为的一种能力，并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。在Java中，只要给定类的名字，那么就可以通过反射机制来获得类的所有信息。</p><p><strong>反射的作用</strong></p><ol><li>在运行时判断任意一个对象所属的类；</li><li>在运行时获取类的对象；</li><li>在运行时访问java对象的属性，方法，构造方法等；</li><li>在运行时修改类的对象、方法和属性</li></ol><p>静态编译：在编译时确定类型，绑定对象，即通过。<br><br>动态编译：运行时确定类型，绑定对象。动态编译最大限度发挥了Java的灵活性，体现了多态的应用，有以降低类之间的藕合性。<br></p><p><strong>反射机制优缺点</strong></p><p>优点：可以实现动态创建对象和编译，体现出很大的灵活性（特别是在J2EE的开发中它的灵活性就表现的十分明显）。通过反射机制我们可以获得类的各种内容，进行反编译。对于JAVA这种先编译再运行的语言来说，反射机制可以使代码更加灵活，更加容易实现面向对象。</p><p>比如，一个大型的软件，不可能一次就把把它设计得很完美，把这个程序编译后，发布了，当发现需要更新某些功能时，我们不可能要用户把以前的卸载，再重新安装新的版本，假如这样的话，这个软件肯定是没有多少人用的。采用静态的话，需要把整个程序重新编译一次才可以实现功能的更新，而采用反射机制的话，它就可以不用卸载，只需要在运行时动态地创建和编译，就可以实现该功能。</p><p>缺点：对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且让它满足我们的要求。这类操作总是慢于直接执行相同的操作。</p><h4><span id="gong-han-mo-shi"> 工厂模式</span><a href="#gong-han-mo-shi" class="header-anchor">#</a></h4><p>IOC容器的工作：创建和管理Bean，它是一个工厂，负责对外提供Bean实例。</p><h2><span id="bean"> @Bean</span><a href="#bean" class="header-anchor">#</a></h2><p>Spring的@Bean注解用于告诉方法，产生一个Bean对象，然后这个Bean对象交给Spring管理。产生这个Bean对象的方法Spring只会调用一次，随后这个Spring将会将这个Bean对象放在自己的IOC容器中。(默认bean的名称就是其方法名。但是也可以指定名称)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanTest <span class="title">getBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        BeanTest bean = <span class="keyword">new</span>  BeanTest();</span><br><span class="line">        System.out.println(<span class="string">&quot;调用方法：&quot;</span>+bean);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;application-context.xml&quot;</span>);</span><br><span class="line">        Object bean1 = context.getBean(<span class="string">&quot;getBean&quot;</span>);</span><br><span class="line">        System.out.println(bean1);</span><br><span class="line">        Object bean2 = context.getBean(<span class="string">&quot;getBean&quot;</span>);</span><br><span class="line">        System.out.println(bean2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">调用方法：Spring.BeanTest@5a4041cc</span><br><span class="line">Spring.BeanTest@5a4041cc</span><br><span class="line">Spring.BeanTest@5a4041cc</span><br></pre></td></tr></table></figure><h2><span id="faq"> FAQ</span><a href="#faq" class="header-anchor">#</a></h2><h3><span id="spring-zhong-de-bean-shi-xian-cheng-an-quan-de-ma-bu-shi"> Spring中的Bean是线程安全的吗（不是）？</span><a href="#spring-zhong-de-bean-shi-xian-cheng-an-quan-de-ma-bu-shi" class="header-anchor">#</a></h3><p>Spring中的Bean默认是单例模式的，框架并没有对bean进行多线程的封装处理。实际上大部分时间Bean是无状态的（比如Dao） 所以说在某种程度上来说Bean其实是安全的。但是如果Bean是有状态的 那就需要开发人员自己来进行线程安全的保证，最简单的办法就是改变bean的作用域把singleton改为protopyte这样每次请求Bean就相当于是new Bean()这样就可以保证线程的安全了。　(有状态就是有数据存储功能/无状态就是不会保存数据）</p><p>线程安全这个问题，要从单例与原型Bean分别进行说明。</p><p><strong>原型Bean：</strong><br>对于原型Bean,每次创建一个新对象，也就是线程之间并不存在Bean共享，自然是不会有线程安全的问题。</p><p><strong>单例Bean：</strong><br>对于单例Bean,所有线程都共享一个单例实例Bean,因此是存在资源的竞争。<br>如果单例Bean,是一个无状态Bean，也就是线程中的操作不会对Bean的成员执行查询以外的操作，那么这个单例Bean是线程安全的。比如Spring mvc 的 Controller、Service、Dao等，这些Bean大多是无状态的，只关注于方法本身。</p><h3><span id="spring-de-bean-zuo-yong-yu-scope-lei-xing"> Spring 的 bean 作用域（scope）类型 ?</span><a href="#spring-de-bean-zuo-yong-yu-scope-lei-xing" class="header-anchor">#</a></h3><ol><li>singleton:单例，默认作用域。</li><li>prototype:原型，每次创建一个新对象。</li><li>request:请求，每次Http请求创建一个新对象，适用于WebApplicationContext环境下。</li><li>session:会话，同一个会话共享一个实例，不同会话使用不用的实例。</li><li>global-session:全局会话，所有会话共享一个实例。</li></ol><h3><span id="service-he-controller-shi-fou-xian-cheng-an-quan"> @Service和@Controller是否线程安全？</span><a href="#service-he-controller-shi-fou-xian-cheng-an-quan" class="header-anchor">#</a></h3><p>默认配置下不是的。为啥呢？因为默认情况下@Controller没有加上@Scope，没有加@Scope就是默认值singleton，单例的。意思就是系统只会初始化一次Controller容器，所以每次请求的都是同一个Controller容器，当然是非线程安全的。</p><ol><li>在@Controller/@Service等容器中，默认情况下，scope值是单例-singleton的，也是线程不安全的</li><li>尽量不要在@Controller/@Service等容器中定义静态变量，不论是单例(singleton)还是多实例(prototype)他都是线程不安全的</li><li>默认注入的Bean对象，在不设置scope的时候他也是线程不安全的</li><li>一定要定义变量的话，用ThreadLocal来封装，这个是线程安全的</li></ol><blockquote><p>多线程场景下，多个线程对这个单例Bean的成员变量并不存在资源的竞争，因为ThreadLocal为每个线程保存线程私有的数据。这是一种以空间换时间的方式。</p></blockquote><h3><span id="bean-he-component-zhi-jian-de-lian-xi-he-qu-bie"> @Bean和@Component之间的联系和区别</span><a href="#bean-he-component-zhi-jian-de-lian-xi-he-qu-bie" class="header-anchor">#</a></h3><p><strong>@Component</strong><br>注解表明一个类会作为组件类，并告知Spring要为这个类创建bean，（@Controller,@Service,@Repository实际上都包含了@Component注解）</p><p><strong>@Bean</strong><br>用在方法上，一般有返回值，@Bean注解告诉Spring这个方法将会返回一个对象，这个对象要注册为Spring应用上下文中的bean。通常方法体中包含了最终产生bean实例的逻辑；第三方的类，如果要注册到spring中，一般用bean的方式。</p><h3><span id="applicationcontext-yu-beanfactory-qu-bie"> ApplicationContext 与 BeanFactory 区别</span><a href="#applicationcontext-yu-beanfactory-qu-bie" class="header-anchor">#</a></h3><p>Bean工厂（BeanFactory）是Spring框架的最核心接口，它提供了高级Ioc的配置机制。应用上下文（ApplicationContext）是BeanFactory的实现，以Bean工厂为基础，它提供了更多面向应用的功能。</p><p>在用途上，BeanFactory是Spring框架的基础设施，面向Spring本身，我们一般不直接使用；ApplicationContext面向使用Spring框架的开发者，所以，在几乎所有的应用场合我们都使用应用上下文而非Bean工厂。</p><h2><span id="kuo-zhan-yue-du"> 扩展阅读</span><a href="#kuo-zhan-yue-du" class="header-anchor">#</a></h2><ol><li>Spring 中的bean 是线程安全的吗： <a href="https://www.cnblogs.com/myseries/p/11729800.html">https://www.cnblogs.com/myseries/p/11729800.html</a></li><li>Bean 文档： <a href="https://wiki.jikexueyuan.com/project/spring/bean-definition.html">https://wiki.jikexueyuan.com/project/spring/bean-definition.html</a></li></ol><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">&lt;p&gt;被称作 bean 的对象是构成应用程序的支柱也是由 Spring IoC 容器管理的。bean 是一个被实例化，组装，并通过 Spring IoC 容器所管理的对象。这些 bean 是由用容器提供的配置元数据创建的，例如，已经在先前章节看到的，在 XML 的表单中的 定义。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/posts/2020/bean-lifecycle.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Spring 只帮我们管理单例模式 Bean 的完整生命周期，对于 prototype 的 bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="源码" scheme="https://blog.beyhub.com/categories/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Java" scheme="https://blog.beyhub.com/tags/Java/"/>
    
    <category term="Spring" scheme="https://blog.beyhub.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>一文看懂Zookeeper</title>
    <link href="https://blog.beyhub.com/p/e1ef1be0d29e/"/>
    <id>https://blog.beyhub.com/p/e1ef1be0d29e/</id>
    <published>2020-03-24T20:12:30.000Z</published>
    <updated>2021-08-21T11:45:53.249Z</updated>
    
    <content type="html"><![CDATA[<p>Apache ZooKeeper是Apache软件基金会的一个软件项目，它为大型分布式计算提供开源的分布式配置服务、同步服务和命名注册。 ZooKeeper曾经是Hadoop的一个子项目，但现在是一个独立的顶级项目。ZooKeeper的架构通过冗余服务实现高可用性（英语：High-availability cluster）。</p><p>因此，如果第一次无应答，客户端就可以询问另一台ZooKeeper主机。ZooKeeper节点将它们的数据存储于一个分层的命名空间，非常类似于一个文件系统或一个前缀树结构。客户端可以在节点读写，从而以这种方式拥有一个共享的配置服务。</p><span id="more"></span><h2><span id="简介"> 简介</span></h2><ol><li>概述</li><li>应用场景<br>目录服务<br>配置管理<br>同步<br>集群节点选举<br>消息队列<br>通知系统</li><li>下载地址</li><li>数据结构<br>文件系统+通知机制（观察者模式）</li></ol><h2><span id="知识点"> 知识点</span></h2><h3><span id="选举机制重要"> 选举机制（重要）</span></h3><ol><li>半数机制：集群中半数以上机器可用，集群可用。所以zookeeper适合奇数台服务器</li><li>Zookeeper虽然在配置文件中没有指定Master和Slave，但Zookeeper在工作时，有一个节点是Leader，其它节点为Follwer，Leader是通过内部选举机制产生的</li></ol><h3><span id="监听器原理重要"> 监听器原理（重要）</span></h3><blockquote><p>常见的监听：1. 监听节点数据变化(get path watch) 2. 监听子节点增减的变化(ls path watch)</p></blockquote><p>监听原理解析</p><ol><li>首先有一个main()线程</li><li>在main线程创建zookeeper客户端，这时就会创建两个线程，一个负责网络通信(connet)，一个负责监听(listener)</li><li>通过connect线程将注册的监听事件发送给zookeeper</li><li>在Zookeeper的注册监听器列表中将注册的监听事件添加到列表中</li><li>Zookeeper监听到有数据或路径变化，就将会把这个消息发送给listener线程</li><li>listener线程内部调用了process()方法<br><img src="/images/posts/2020/zk-listener%E5%8E%9F%E7%90%86.png" alt></li></ol><h3><span id="节点类型"> 节点类型</span></h3><ol><li>持久(Persistent): 客户端和服务器断开连接后，创建节点不删除</li><li>短暂(Ephemeral): 客户端和服务器断开连接后，创建的节点自己删除</li></ol><h3><span id="stat结构体"> Stat结构体</span></h3><h3><span id="写数据流程"> 写数据流程</span></h3><ol><li>client 向Zookeeper的server1上写数据，发送一个写请求</li><li>如果server1不是Leader，则把请求转发给Leader，Leader再广播给Follwer</li><li>当Leader收到大多数Server写成功了</li></ol><p><img src="/images/posts/2020/zk-%E5%86%99%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B.png" alt></p><h2><span id="实战"> 实战</span></h2><h3><span id="分布式安装部署"> 分布式安装部署</span></h3><ol><li>集群规划</li><li>解压</li><li>配置服务器编号</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir zkData</span><br><span class="line"><span class="built_in">cd</span> zkData</span><br><span class="line">touch myid  <span class="comment"># 集群的唯一标识</span></span><br><span class="line"><span class="built_in">echo</span> 1&gt; myid  <span class="comment"># myid为递增的数字</span></span><br></pre></td></tr></table></figure><h3><span id="常用命令命令行"> 常用命令命令行</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bin/zkCli.sh  <span class="comment"># 进入客户端</span></span><br><span class="line">ls <span class="comment"># 查看节点</span></span><br><span class="line">ls2 <span class="comment"># 查看节点详细数据</span></span><br><span class="line">create /sanguo <span class="string">&quot;jinlian&quot;</span> <span class="comment"># 创建节点（必须要写数据）</span></span><br><span class="line">create /sanguo/shuguo <span class="string">&quot;刘备&quot;</span> <span class="comment"># 创建多级节点 </span></span><br><span class="line">delete path <span class="comment"># 删除当前path</span></span><br><span class="line">rmr path <span class="comment"># 递归删除所有下级路径</span></span><br><span class="line">get path <span class="comment"># 取出节点的数据</span></span><br><span class="line">ls /sanguo</span><br><span class="line"><span class="built_in">set</span> path <span class="comment"># 修改节点的数据</span></span><br><span class="line">ls path watch <span class="comment"># 监听子节点增减的变化</span></span><br><span class="line">get path watch <span class="comment"># 监听节点数据变化（注册一次，只生效一次）</span></span><br><span class="line"><span class="built_in">stat</span> path <span class="comment"># 查看路径的详细信息</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="faq"> FAQ</span></h2><ol><li>zookeeper的部署方式有几种？集群中有哪些角色？集群最少要几台机器<ul><li>部署方式：单机模式、集群模式</li><li>集群中最少需要几台机器：3台</li></ul></li><li><a href="https://github.com/tenstone/spring-boot-zookeeper-examples">跳转到github看examples</a></li></ol><p>Zookeeper是大数据框架中比较基础，也比较简单的一个，你已经掌握了吗？</p><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">&lt;p&gt;Apache ZooKeeper是Apache软件基金会的一个软件项目，它为大型分布式计算提供开源的分布式配置服务、同步服务和命名注册。 ZooKeeper曾经是Hadoop的一个子项目，但现在是一个独立的顶级项目。ZooKeeper的架构通过冗余服务实现高可用性（英语：High-availability cluster）。&lt;/p&gt;
&lt;p&gt;因此，如果第一次无应答，客户端就可以询问另一台ZooKeeper主机。ZooKeeper节点将它们的数据存储于一个分层的命名空间，非常类似于一个文件系统或一个前缀树结构。客户端可以在节点读写，从而以这种方式拥有一个共享的配置服务。&lt;/p&gt;</summary>
    
    
    
    <category term="分布式" scheme="https://blog.beyhub.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="zookeeper" scheme="https://blog.beyhub.com/tags/zookeeper/"/>
    
  </entry>
  
</feed>
